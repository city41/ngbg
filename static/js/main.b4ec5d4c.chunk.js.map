{"version":3,"sources":["emulator/neoGeoPalette.ts","emulator/tile.tsx","emulator/spriteData.ts","emulator/sprite.tsx","emulator/sprites.tsx","emulator/emulator.tsx","index.tsx","App.tsx","emulator/sprite.module.css","emulator/sprites.module.css"],"names":["PALETTE_SIZE_IN_BYTES","getRgbFromNeoGeoPalette","paletteIndex","colorIndex","palAddr","window","Module","_get_current_pal_addr","palOffset","colorOffset","color","i","HEAPU8","col16","darkBit","convert","TILE_SIZE_BYTES","TILE_SIZE_INTS","map","0","1","2","3","4","5","6","7","Tile","tileIndex","style","horizontalFlip","transform","ref","r","canvas","cromAddr","_get_rom_ctile_addr","tileOffset","tileData","width","height","context","getContext","imageData","getImageData","y","x","pixelPair","rightPixelColorIndex","leftPixel","rightPixel","length","data","putImageData","renderCanvas","SCB1_SPRITE_SIZE_BYTES","SCB2_BYTE_OFFSET","SCB3_BYTE_OFFSET","SCB4_BYTE_OFFSET","getTileData","spriteIndex","spriteSize","tileRamAddr","_get_tile_ram_addr","spriteOffset","spriteData","w","firstWord","secondWord","push","verticalFlip","getYSpriteSizeSticky","Error","spriteScb3Addr","scb3Word","sticky","fullmode","yScale","getScale","ignoreSticky","getX","xScale","spriteScb4Addr","options","spriteScb2Addr","scb2Word","Sprite","positioned","honorTileSize","tiles","getSpriteData","key","top","left","gridTemplateRows","spriteClassName","classnames","styles","sprite","className","Sprites","useState","dumpCount","setDumpCount","setPositioned","setHonorTileSize","sprites","Array","fill","_","spritesClassName","type","checked","onClick","loadFile","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","name","readAsArrayBuffer","addFileToVirtualFS","a","FS_createDataFile","Uint8Array","Emulator","biosLoaded","setBiosLoaded","romLoaded","setRomLoaded","gameName","setGameName","isPaused","setIsPaused","e","target","files","replace","id","disabled","onChange","argv","stackAlloc","HEAP32","allocateUTF8OnStack","_run_rom","resumeMainLoop","pauseMainLoop","ReactDOM","render","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.b4ec5d4c.chunk.js","sourcesContent":["// each palette has 16 colors, each color is a 32 bit rgb value\n// NOTE: this is due to using gngeo's pc palette instead of actual\n// neo geo palettes, which only have 16bit colors (Thanks gngeo!)\nconst PALETTE_SIZE_IN_BYTES = 16 * 2;\n\n/**\n * Convert from a neo geo palette color to a 32 rgb color\n * https://wiki.neogeodev.org/index.php?title=Colors\n */\nfunction convert(col16: number): number[] {\n    // the least significant bit is shared by each channel\n    // if it is zero, the entire color is a tad darker, hence the name \"dark bit\"\n    const darkBit = (col16 >> 15) & 1;\n\n    const upperB = (col16 & 0xf) << 2;\n    const lowerB = ((col16 >> 12) & 1) << 1;\n    const b5 = upperB | lowerB | darkBit;\n\n    const upperG = ((col16 >> 4) & 0xf) << 2;\n    const lowerG = ((col16 >> 13) & 1) << 1;\n    const g5 = upperG | lowerG | darkBit;\n\n    const upperR = ((col16 >> 8) & 0xf) << 2;\n    const lowerR = ((col16 >> 14) & 1) << 1;\n    const r5 = upperR | lowerR | darkBit;\n\n    // neo geo color channels are six bits (max value of 63), but need to map\n    // them to a 8 bit color channel (max value of 255)\n    const b = (b5 / 63) * 255;\n    const g = (g5 / 63) * 255;\n    const r = (r5 / 63) * 255;\n\n    return [r, g, b, 255];\n}\n\nexport function getRgbFromNeoGeoPalette(\n    paletteIndex: number,\n    colorIndex: number\n): number[] {\n    if (colorIndex === 0) {\n        return [0, 0, 0, 0];\n    }\n\n    const palAddr = window.Module._get_current_pal_addr();\n    const palOffset = paletteIndex * PALETTE_SIZE_IN_BYTES;\n    const colorOffset = colorIndex * 2;\n\n    const color: number[] = [];\n\n    for (let i = 0; i < 2; ++i) {\n        color[i] = window.HEAPU8[palAddr + palOffset + colorOffset + i];\n    }\n\n    const combinedColor = color[0] | (color[1] << 8);\n\n    return convert(combinedColor);\n}\n","import React from \"react\";\nimport { getRgbFromNeoGeoPalette } from \"./neoGeoPalette\";\n\n// 16 rows, each row has 2 ints (32 bits each)\nconst TILE_SIZE_INTS = 2 * 16;\nconst TILE_SIZE_BYTES = TILE_SIZE_INTS * 4;\n\ninterface TileProps {\n    tileIndex: number;\n    paletteIndex: number;\n    horizontalFlip?: boolean;\n}\n\nconst map: Record<string, number> = {\n    0: 3,\n    1: 2,\n    2: 1,\n    3: 0,\n    4: 7,\n    5: 6,\n    6: 5,\n    7: 4\n};\n\nexport const Tile: React.FunctionComponent<TileProps> = ({\n    tileIndex,\n    paletteIndex,\n    horizontalFlip\n}) => {\n    function renderCanvas(canvas: HTMLCanvasElement) {\n        const cromAddr = window.Module._get_rom_ctile_addr();\n        const tileOffset = TILE_SIZE_BYTES * tileIndex;\n\n        const tileData: number[] = [];\n\n        for (let i = 0; i < TILE_SIZE_BYTES; ++i) {\n            tileData[i] = window.HEAPU8[cromAddr + tileOffset + i];\n        }\n\n        canvas.width = 16;\n        canvas.height = 16;\n\n        const context = canvas.getContext(\"2d\")!;\n\n        const imageData = context.getImageData(0, 0, 16, 16);\n\n        for (let y = 0; y < 16; ++y) {\n            for (let x = 0; x < 8; ++x) {\n                const pixelPair = tileData[y * 8 + map[x]];\n\n                const leftPixelColorIndex = (pixelPair >> 4) & 0xf;\n                const rightPixelColorIndex = pixelPair & 0xf;\n\n                const leftPixel = getRgbFromNeoGeoPalette(\n                    paletteIndex,\n                    leftPixelColorIndex\n                );\n                const rightPixel = getRgbFromNeoGeoPalette(\n                    paletteIndex,\n                    rightPixelColorIndex\n                );\n\n                for (let i = 0; i < leftPixel.length; ++i) {\n                    imageData.data[(y * 16 + x * 2) * 4 + i] = leftPixel[i];\n                    imageData.data[(y * 16 + x * 2 + 1) * 4 + i] =\n                        rightPixel[i];\n                }\n            }\n        }\n\n        context.putImageData(imageData, 0, 0);\n    }\n\n    const style = horizontalFlip ? { transform: \"scale(-1, 1)\" } : {};\n    return <canvas ref={r => r && renderCanvas(r)} style={style} />;\n};\n","// ALERT!\n// vram addresses in the neo geo are word wide, not byte wide!\n// TODO: can probably just use HEAPU16 and make this all much simpler\n// ALERT!\n\n// in SCB1,\n// each sprite has 64, 16-bit, words\nconst SCB1_SPRITE_SIZE_BYTES = 64 * 2;\n\n// it starts at word $8000, so *2 to get byte address\nconst SCB2_BYTE_OFFSET = 0x8000 * 2;\n\n// it starts at word $8200, so *2 to get byte address\nconst SCB3_BYTE_OFFSET = 0x8200 * 2;\n\n// it starts at word $8400, so *2 to get byte address\nconst SCB4_BYTE_OFFSET = 0x8400 * 2;\n\ninterface TileData {\n    tileIndex: number;\n    paletteIndex: number;\n    horizontalFlip: boolean;\n    verticalFlip: boolean;\n}\n\ninterface SpriteData {\n    tiles: TileData[];\n    x: number;\n    y: number;\n    sticky: boolean;\n}\n\nfunction getTileData(spriteIndex: number, spriteSize: number): TileData[] {\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const spriteOffset = SCB1_SPRITE_SIZE_BYTES * spriteIndex;\n\n    const spriteData: number[] = [];\n\n    for (let i = 0; i < spriteSize * 4; ++i) {\n        spriteData[i] = window.HEAPU8[tileRamAddr + spriteOffset + i];\n    }\n\n    const tileData = [];\n\n    for (let w = 0; w < spriteData.length; w += 4) {\n        const firstWord = spriteData[w] | (spriteData[w + 1] << 8);\n        const secondWord = spriteData[w + 2] | (spriteData[w + 3] << 8);\n\n        // first word = least sig bits of tile index\n        // second word, bits 4 through 7 = most sig bits of tile index\n        const tileIndex = firstWord | (((secondWord >> 4) & 0xf) << 16);\n\n        // top half of second word is the palette index\n        const paletteIndex = (secondWord >> 8) & 0xff;\n\n        const horizontalFlip = !!(secondWord & 1);\n\n        tileData.push({\n            tileIndex,\n            paletteIndex,\n            horizontalFlip,\n            verticalFlip: false\n        });\n    }\n\n    return tileData;\n}\n\nfunction getYSpriteSizeSticky(\n    spriteIndex: number\n): { y: number; spriteSize: number; sticky: boolean } {\n    if (spriteIndex < 0) {\n        throw new Error(\"getYSpriteSizeSticky: sprite index under zero!\");\n    }\n\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const scb3StartAddr = tileRamAddr + SCB3_BYTE_OFFSET;\n\n    const spriteScb3Addr = scb3StartAddr + spriteIndex * 2;\n\n    const scb3Word =\n        window.HEAPU8[spriteScb3Addr] |\n        (window.HEAPU8[spriteScb3Addr + 1] << 8);\n\n    const sticky = !!((scb3Word >> 6) & 1);\n\n    if (sticky) {\n        return {\n            ...getYSpriteSizeSticky(spriteIndex - 1),\n            sticky\n        };\n    } else {\n        const yScale = getScale(spriteIndex, { ignoreSticky: true }).yScale;\n        const spriteSize = scb3Word & 0x3f;\n\n        let fullmode;\n\n        if (spriteSize === 0x20) {\n            fullmode = 1;\n        } else if (spriteSize >= 0x21) {\n            fullmode = 2;\n        } else {\n            fullmode = 0;\n        }\n\n        // getting the final screen y is very complicated and\n        // honestly don't fully understand it. This code was copied\n        // from gngeo, video.c#draw_screen()\n        let y = 0x200 - (scb3Word >> 7);\n\n        if (y > 0x110) {\n            y -= 0x200;\n        }\n\n        if (fullmode === 2 || (fullmode === 1 && yScale === 0xff)) {\n            while (y < 0) {\n                y += (yScale + 1) << 1;\n            }\n        }\n\n        return { y, spriteSize, sticky };\n    }\n}\n\nfunction getX(spriteIndex: number): number {\n    if (spriteIndex < 0) {\n        throw new Error(\"getX: sprite index under zero!\");\n    }\n\n    const sticky = getYSpriteSizeSticky(spriteIndex).sticky;\n\n    if (sticky) {\n        const xScale = getScale(spriteIndex).xScale;\n        return getX(spriteIndex - 1) + xScale;\n    }\n\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const scb4StartAddr = tileRamAddr + SCB4_BYTE_OFFSET;\n\n    const spriteScb4Addr = scb4StartAddr + spriteIndex * 2;\n\n    const scb4Word =\n        window.HEAPU8[spriteScb4Addr] |\n        (window.HEAPU8[spriteScb4Addr + 1] << 8);\n\n    let x = scb4Word >> 7;\n\n    if (x >= 0x1f0) {\n        x -= 0x200;\n    }\n\n    return x;\n}\n\nfunction getScale(\n    spriteIndex: number,\n    options?: { ignoreSticky: boolean }\n): { yScale: number; xScale: number } {\n    if (spriteIndex < 0) {\n        throw new Error(\"getScale: sprite index under zero!\");\n    }\n\n    if (!options || !options.ignoreSticky) {\n        const sticky = getYSpriteSizeSticky(spriteIndex).sticky;\n\n        if (sticky) {\n            return getScale(spriteIndex - 1);\n        }\n    }\n\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const scb2StartAddr = tileRamAddr + SCB2_BYTE_OFFSET;\n    const spriteScb2Addr = scb2StartAddr + spriteIndex * 2;\n\n    const scb2Word =\n        window.HEAPU8[spriteScb2Addr] |\n        (window.HEAPU8[spriteScb2Addr + 1] << 8);\n\n    const yScale = scb2Word & 0xff;\n    const xScale = ((scb2Word >> 8) & 0xf) + 1;\n\n    return { yScale, xScale };\n}\n\nexport function getSpriteData(\n    spriteIndex: number,\n    honorTileSize: boolean\n): SpriteData {\n    const { y, spriteSize } = getYSpriteSizeSticky(spriteIndex);\n\n    return {\n        tiles: getTileData(spriteIndex, honorTileSize ? spriteSize : 32),\n        x: getX(spriteIndex),\n        sticky: false,\n        y\n    };\n}\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { Tile } from \"./tile\";\nimport { getSpriteData } from \"./spriteData\";\n\nimport styles from \"./sprite.module.css\";\n\ninterface SpriteProps {\n    spriteIndex: number;\n    positioned: boolean;\n    honorTileSize: boolean;\n}\n\nexport const Sprite: React.FunctionComponent<SpriteProps> = ({\n    spriteIndex,\n    positioned,\n    honorTileSize\n}) => {\n    const spriteData = getSpriteData(spriteIndex, honorTileSize);\n\n    if (spriteData.tiles.length === 0) {\n        return null;\n    }\n\n    const tiles = spriteData.tiles.map((tileData, i) => (\n        <Tile\n            key={i}\n            tileIndex={tileData.tileIndex}\n            paletteIndex={tileData.paletteIndex}\n            horizontalFlip={tileData.horizontalFlip}\n        />\n    ));\n\n    const style = {\n        top: spriteData.y,\n        left: spriteData.x,\n        gridTemplateRows: `repeat(${spriteData.tiles.length}, 16px)`\n    };\n\n    const spriteClassName = classnames(styles.sprite, {\n        [styles.positioned]: positioned\n    });\n\n    return (\n        <div className={spriteClassName} style={style}>\n            {tiles}\n        </div>\n    );\n};\n","import React, { useState } from \"react\";\nimport classnames from \"classnames\";\nimport { Sprite } from \"./sprite\";\n\nimport styles from \"./sprites.module.css\";\n\nconst SPRITE_CHUNK_SIZE = 448;\n\nexport const Sprites: React.FunctionComponent = () => {\n    const [dumpCount, setDumpCount] = useState(0);\n    const [positioned, setPositioned] = useState(true);\n    const [honorTileSize, setHonorTileSize] = useState(true);\n\n    const sprites = new Array(dumpCount ? SPRITE_CHUNK_SIZE : 0)\n        .fill(1, 0, SPRITE_CHUNK_SIZE)\n        .map((_, i) => {\n            return (\n                <Sprite\n                    key={i}\n                    spriteIndex={i}\n                    positioned={positioned}\n                    honorTileSize={honorTileSize}\n                />\n            );\n        });\n\n    const spritesClassName = classnames(styles.sprites, {\n        [styles.positioned]: positioned\n    });\n\n    return (\n        <>\n            <input\n                type=\"checkbox\"\n                checked={positioned}\n                onClick={() => setPositioned(!positioned)}\n            />\n            positioned\n            <input\n                type=\"checkbox\"\n                checked={honorTileSize}\n                onClick={() => setHonorTileSize(!honorTileSize)}\n            />\n            honor tile size\n            <button\n                onClick={() => {\n                    setDumpCount(dumpCount + 1);\n                }}\n            >\n                dump sprites\n            </button>\n            <div className={spritesClassName}>{sprites}</div>\n        </>\n    );\n};\n","import React, { useState } from \"react\";\nimport { Sprites } from \"./sprites\";\n\ninterface EmulatorProps {\n    className?: string;\n}\n\nfunction loadFile<T>(file: File): Promise<T> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.addEventListener(\"load\", () => {\n            if (reader.result) {\n                resolve((reader.result as unknown) as T);\n            } else {\n                reject(`Failed to load: ${file.name}`);\n            }\n        });\n\n        reader.readAsArrayBuffer(file);\n    });\n}\n\nasync function addFileToVirtualFS(file: File) {\n    const data: ArrayBuffer = await loadFile(file);\n\n    window.Module.FS_createDataFile(\n        \"/virtualfs\",\n        file.name,\n        new Uint8Array(data),\n        true,\n        true\n    );\n}\n\nexport const Emulator: React.FunctionComponent<EmulatorProps> = () => {\n    const [biosLoaded, setBiosLoaded] = useState(false);\n    const [romLoaded, setRomLoaded] = useState(false);\n    const [gameName, setGameName] = useState(\"\");\n    const [isPaused, setIsPaused] = useState(false);\n\n    function togglePause() {\n        if (isPaused) {\n            window.Module.resumeMainLoop();\n        } else {\n            window.Module.pauseMainLoop();\n        }\n\n        setIsPaused(!isPaused);\n    }\n\n    async function loadBiosFile(e: React.ChangeEvent<HTMLInputElement>) {\n        const file = e.target && e.target.files && e.target.files[0];\n\n        if (!file) {\n            return;\n        }\n\n        await addFileToVirtualFS(file);\n        setBiosLoaded(true);\n    }\n\n    async function loadROMFile(e: React.ChangeEvent<HTMLInputElement>) {\n        const file = e.target && e.target.files && e.target.files[0];\n\n        if (!file) {\n            return;\n        }\n\n        await addFileToVirtualFS(file);\n        setRomLoaded(true);\n        setGameName(file.name.replace(\".zip\", \"\"));\n    }\n\n    function startGame() {\n        const argv = window.stackAlloc(3 * 4);\n\n        window.HEAP32[argv >> 2] = window.allocateUTF8OnStack(\"gngeo\");\n        window.HEAP32[(argv >> 2) + 1] = window.allocateUTF8OnStack(gameName);\n        window.HEAP32[(argv >> 2) + 2] = 0;\n\n        window.Module._run_rom(2, argv);\n    }\n\n    return (\n        <>\n            <canvas id=\"canvas\" />\n            <div>\n                BIOS\n                <input\n                    disabled={biosLoaded}\n                    type=\"file\"\n                    onChange={loadBiosFile}\n                />\n            </div>\n            <div>\n                ROM\n                <input\n                    disabled={romLoaded}\n                    type=\"file\"\n                    onChange={loadROMFile}\n                />\n            </div>\n            <button disabled={!biosLoaded || !romLoaded} onClick={startGame}>\n                start emulation\n            </button>\n            <button disabled={!biosLoaded || !romLoaded} onClick={togglePause}>\n                {isPaused ? \"resume\" : \"pause\"}\n            </button>\n            <Sprites />\n        </>\n    );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n","import React from \"react\";\nimport { Emulator } from \"./emulator\";\n\nexport const App: React.FunctionComponent = () => {\n    return <Emulator />;\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sprite\":\"sprite_sprite__3KcA3\",\"positioned\":\"sprite_positioned__3ip5P\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sprites\":\"sprites_sprites__1RtnD\",\"positioned\":\"sprites_positioned__3qOrZ\"};"],"sourceRoot":""}