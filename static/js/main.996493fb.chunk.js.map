{"version":3,"sources":["composeScreen/cropRect.module.css","spriteTray/spriteEntry.module.css","layers/group.module.css","composeScreen/extractedTile.module.css","layers/layer.module.css","layers/layers.module.css","composeScreen/extractedSprite.module.css","spriteTray/tile.module.css","spriteTray/sprite.module.css","composeScreen/layer.module.css","components/iconButton.module.css","layers/sprite.module.css","chooseGameModal/ss2Title.png","chooseGameModal/streetSlamTitle.png","state/ids.ts","state/spriteUtil.ts","state/spriteData.ts","palette/neoGeoPalette.ts","state/extractSpriteGroup.ts","state/update.ts","state/undoableState.ts","state/state.ts","state/provider.tsx","state/renderTileToCanvas.ts","composeScreen/extractedTile.tsx","composeScreen/extractedSprite.tsx","SpriteGroupDragPreview.tsx","dragPreviewLayer.tsx","state/index.ts","emulator/pauseOverlay.tsx","emulator/emulator.tsx","spriteTray/tile.tsx","spriteTray/sprite.tsx","spriteTray/spriteEntry.tsx","spriteTray/spriteTray.tsx","state/jsgif/LZWEncoder.js","state/jsgif/NeuQuant.js","state/jsgif/GIFEncoder.js","state/layersToCanvas.ts","state/createGif.ts","gifBuilder/buildGifModal.tsx","composeScreen/layer.tsx","composeScreen/cropRect.tsx","composeScreen/composeScreen.tsx","toolbar/toolbar.tsx","components/iconButton.tsx","layers/sprite.tsx","layers/groupPreview.tsx","state/toDataUrl.ts","layers/group.tsx","layers/layerPreview.tsx","layers/layer.tsx","layers/layers.tsx","chooseGameModal/fileDropZone.tsx","chooseGameModal/fileStep.tsx","chooseGameModal/demoChoices.tsx","chooseGameModal/chooseGameModal.tsx","app.tsx","index.tsx"],"names":["module","exports","idCounter","getId","getMaxY","entities","tiles","arr","Array","isArray","length","reduce","b","s","concat","Math","max","map","t","composedY","getMinY","min","getMaxX","sprites","composedX","getMinX","moveSprites","diffX","diffY","baseX","sprite","moveTiles","moveGroups","groups","pauseId","group","pushDownOutOfNegative","layers","minY","getAllTilesFromLayers","layer","deltaY","moveSpritesY","getAllSpritesFromLayers","getAllTilesFromSprites","tile","extendGroupsViaMirroring","ss","rightMirror","maxX","spriteMemoryIndex","horizontalFlip","reverse","mirrorSpritesToRight","leftMirror","minX","width","mirrorSpritesToLeft","id","setGroupToZeroZero","setLayerToZeroZero","undefined","SCB1_SPRITE_SIZE_BYTES","SCB2_BYTE_OFFSET","SCB3_BYTE_OFFSET","SCB4_BYTE_OFFSET","getYSpriteSizeSticky","Error","spriteScb3Addr","window","Module","_get_tile_ram_addr","scb3Word","HEAPU8","sticky","spriteSize","y","rawY","yScale","fullmode","transformY","getScale","ignoreSticky","tileYs","push","getX","x","xScale","spriteScb4Addr","options","spriteScb2Addr","scb2Word","getSpriteData","tileRamAddr","spriteOffset","spriteData","i","tileData","w","firstWord","secondWord","tileIndex","autoAnimation","paletteIndex","verticalFlip","getTileData","COLORS_PER_PALETTE","PALETTE_SIZE_IN_BYTES","convertNeoGeoColorToRGBColor","col16","darkBit","getNeoGeoPalette","paletteMemoryIndex","process","ENABLE_DEMO_DUMP","neededPalettes","palIndexInHeap","_get_current_pal_addr","HEAPU16","slice","convertNeoGeoPaletteToRGB","neoGeoPalette","mapped","getBackdropNeoGeoColor","palAddr","neoGeoColorToCSS","neoGeoColor","asArray","convertTileDataToExtractedTile","rest","rgbPalette","extractSpriteAndStickyCompanionsToGroup","additionalProps","extractSpritesIntoGroup","rootSpriteIndex","spriteMemoryIndices","getSpriteGroup","smi","screenX","screenY","update","obj","collection","updates","o","rotateTiles","maxY","needsToWrap","wrapOffset","rotateSprites","DEMO_PALETTE_ADDRESS","reducer","state","action","nonUndoableState","type","newSpriteGroup","isAdhoc","find","l","hiddenLayers","oldSpriteGroups","filter","esg","a","aIndices","es","sort","bIndices","isEqual","haveSameSprites","newGroup","oldGroups","sameGroup","og","positionSpriteGroupInRelationToExistingGroups","newComposedX","some","g","currentSpriteGroup","sg","movedGroups","indexOf","without","newLayer","hidden","mirroredGroups","originalLayerIndex","deltaX","pushInOutOfNegative","allLayers","Infinity","rotateLayer","pushedLayer","initialState","past","present","future","hasStarted","isPaused","isCropping","crop","isPreviewing","isBuildingGif","showGrid","hiddenGroups","isDemoing","newState","data","nowPaused","pastCopy","newPresent","pop","futureCopy","demoData","spriteMemory","set","Object","keys","forEach","key","keyData","_get_rom_ctile_addr","Number","copyTileDataToHeap","tileMemory","copyPaletteDataToHeap","palettes","stateContext","createContext","dispatchContext","Provider","children","useReducer","dispatch","value","0","1","2","3","4","5","6","7","getTileIndexedColorData","memoize","cromAddr","tileOffset","TILE_SIZE_INTS","tileIndexData","pixelPair","leftPixelColorIndex","rightPixelColorIndex","tileCanvasCache","renderTileToCanvas","destCanvas","neededTiles","height","destContext","getContext","hash","color","innerHash","channel","drawImage","cacheCanvas","document","createElement","cacheContext","indexedTileData","imageData","getImageData","pixel","putImageData","ExtractedTile","React","memo","tileY","outlined","horizontalScale","verticalScale","classes","classnames","styles","root","inlineStyle","transform","top","className","data-tileindex","ref","r","style","ExtractedSprite","autoAnimate","animationCounter","canDrag","outlineTiles","setYToZero","overrideX","useDrag","item","dragRef","preview","useEffect","getEmptyImage","captureDraggingState","left","gridTemplateRows","zIndex","StickySpriteGroupDragPreview","seedSpriteMemoryIndex","AdhocSpriteGroupDragPreview","DragPreviewLayer","useDragLayer","monitor","getItem","initialOffset","getInitialSourceClientOffset","currentOffset","getClientOffset","isDragging","spritesCmp","position","useAppState","actualDispatch","useContext","rawState","actionOrType","undo","redo","canUndo","canRedo","Container","styled","div","PauseOverlay","onTogglePause","Icon","PlayArrow","Pause","onClick","title","DemoDisclaimer","Emulator","props","resumeMainLoop","pauseMainLoop","Tile","canvas","renderCanvas","Sprite","SpriteEntry","focused","index","spriteContainer","Message","SpriteEntries","Filler","SpriteTray","useState","focusedEntryIndices","setFocusedEntryIndices","shiftKeyStartEntryIndex","setShiftKeyStartEntryIndex","firstFillerRef","useRef","begin","divRef","current","getBoundingClientRect","scrollLeft","floor","fei","spriteDatas","setDivRef","fill","_","d","e","ctrlKey","shiftKey","minIndex","maxIndex","minValue","maxValue","count","arrayFrom","gridTemplateColumns","gridColumn","LZWEncoder","imgW","imgH","pixAry","initCodeSize","remaining","curPixel","n_bits","maxcode","g_init_bits","ClearCode","EOFCode","a_count","EOF","BITS","HSIZE","maxbits","maxmaxcode","htab","codetab","hsize","free_ent","clear_flg","cur_accum","cur_bits","masks","accum","pixels","color_depth","char_out","c","outs","flush_char","cl_block","cl_hash","output","compress","init_bits","fcode","ent","disp","hsize_reg","hshift","MAXCODE","nextPixel","outer_loop","encode","os","writeByte","writeBytes","code","apply","this","arguments","NeuQuant","alphadec","thepicture","lengthcount","samplefac","network","netsize","prime1","prime2","prime3","prime4","minpicturebytes","maxnetpos","netbiasshift","ncycles","intbiasshift","intbias","gammashift","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","radbiasshift","radbias","alpharadbshift","alpharadbias","netindex","bias","freq","radpower","thepic","len","sample","p","colorMap","k","j","inxbuild","smallpos","smallval","q","previouscol","startpos","learn","radius","rad","alpha","step","delta","samplepixels","pix","lim","contest","altersingle","alterneigh","unbiasnet","dist","bestd","best","lo","hi","m","n","biasdist","betafreq","bestpos","bestbiaspos","bestbiasd","GIFEncoder","chr","String","fromCharCode","ByteArray","bin","prototype","getData","v","val","writeUTFBytes","string","charCodeAt","array","offset","transIndex","out","image","indexedPixels","colorDepth","colorTab","transparent","repeat","delay","started","usedEntry","palSize","dispose","closeStream","firstFrame","sizeSet","comment","reset","setDelay","ms","round","setDispose","setRepeat","iter","setTransparent","setComment","addFrame","im","is_imageData","ok","ImageData","setSize","Uint8ClampedArray","console","log","getImagePixels","analyzePixels","writeLSD","writePalette","writeNetscapeExt","writeGraphicCtrlExt","writeCommentExt","writeImageDesc","writePixels","download","filename","endsWith","templink","href","URL","createObjectURL","Blob","Uint8Array","click","finish","setFrameRate","fps","setQuality","quality","h","start","cont","nPix","nq","findClosest","minpos","dmin","dr","dg","db","transp","WriteShort","pValue","stream","setProperties","has_start","is_first","layersToCanvas","dimensions","getDimensions","context","layerSprites","tileCanvas","translateX","translateY","newCanvas","save","translate","scale","restore","flip","fullCanvas","cropWidth","cropHeight","croppedCanvas","cropCanvas","FOREVER","createGif","onFrame","onFinish","encoder","totalFrames","validTiles","ts","validLayerTiles","lts","validSpriteTiles","sts","validTilesForSprite","maxAnimation","determineNumberOfFramesToRender","remainingFrames","binaryData","btoa","frameCanvas","setTimeout","clear","firstChild","removeChild","BuildGifModal","isOpen","onRequestClose","containerRef","frameStatus","setFrameStatus","_get_neogeo_frame_counter_speed","frame","appendChild","dataUrl","img","Image","src","Layer","runPreview","spriteCmps","extractedSprite","extractedSprites","CropRect","topRowStyle","gridRow","leftCellStyle","cropStyle","containerStyle","mask","flex","CaptureLayer","ComposeScreen","animation","rafFrameCountdown","setAnimationCounter","setIsCropping","upperLeftCrop","setUpperLeftCrop","lowerRightCrop","setLowerRightCrop","frameCountdown","requestAnimationFrame","diff","useDrop","accept","drop","canDrop","dropRef","backgroundColorStyle","backgroundColor","scrollWidth","scrollHeight","onMouseDown","rect","target","rawX","clientX","clientY","onMouseMove","onMouseUp","Toolbar","disabled","IconButton","icon","role","aria-label","onDelete","Delete","GroupPreview","url","toDataURL","spriteGroupToDataUrl","imgWidth","imgHeight","alt","Group","onToggleVisibility","showSprites","setShowSprites","toolbar","ExpandLess","ExpandMore","IoIosEyeOff","IoIosEye","LayerPreview","layerToDataUrl","onGroupDelete","onGroupToggleVisibility","onExtendViaMirror","onPushDown","showGroups","setShowGroups","IoIosReorder","IoIosPhoneLandscape","VerticalAlignBottom","Layers","buttonIcon","IoIosAdd","isOver","ChooseFile","label","FileInput","input","hasFiles","dataTransfer","types","keyOrIndex","FileDropZone","onFileChosen","fileName","setIsOver","body","onDragOver","onDragLeave","onDrop","file","files","onChange","InnerContainer","StepNumber","TitleContainer","Title","loadingFrames","keyframes","LoadingIndicator","FileStep","stepNumber","description","loading","loadingStyle","visibility","Choice","SS2","ss2Img","StreetSlam","streetSlamImg","DemoChoices","onChoice","StyledModal","Modal","Why","loadFile","Promise","resolve","reject","reader","FileReader","addEventListener","result","name","readAsArrayBuffer","addFileToVirtualFS","FS_createDataFile","ChooseGameModal","showWhy","setShowWhy","setIsOpen","romName","setRomName","biosName","setBiosName","romLoaded","setRomLoaded","biosLoaded","setBiosLoaded","loadingBios","setLoadingBios","loadingRom","setLoadingRom","launch","overrideRomName","argv","stackAlloc","romToLoad","replace","HEAP32","allocateUTF8OnStack","_run_rom","startRom","demoType","fetch","fetchedRawData","json","romDescription","overlayClassName","then","AppRoot","ComposeScreenTrayGrid","EmulatorLayersGrid","setAppElement","ReactDOM","render","backend","HTML5Backend","getElementById","dumpDemo","spriteMemoryStart","spriteMemoryEnd","dump","asJson","JSON","stringify","join"],"mappings":"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","file":"static/js/main.996493fb.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"cropRect_root__LYSAR\",\"mask\":\"cropRect_mask__Vl5ZD\",\"crop\":\"cropRect_crop__2ev0N\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"spriteEntry_root__21-Rc\",\"index\":\"spriteEntry_index__3_j9A\",\"focused\":\"spriteEntry_focused__2e2R9\",\"spriteContainer\":\"spriteEntry_spriteContainer__3BESY\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"group_root__1RKod\",\"toolbar\":\"group_toolbar__1l8sD\",\"spriteContainer\":\"group_spriteContainer__cQlrm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"extractedTile_root__14wnu\",\"outlined\":\"extractedTile_outlined__1tGwy\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"layer_root__NdbK1\",\"toolbar\":\"layer_toolbar__1mN6V\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"layers_root__1VIq8\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"extractedSprite_root__gpe6g\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"canvas\":\"tile_canvas__1tNqN\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sprite\":\"sprite_sprite__38hI5\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"layer_root__1yNTP\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"iconButton_root__J-591\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"sprite_root__1RSYf\"};","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,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\"","let idCounter = 1;\n\nexport function getId() {\n    return idCounter++;\n}\n","import {\n    ExtractedSpriteGroup,\n    ExtractedTile,\n    Layer,\n    ExtractedSprite\n} from \"./types\";\nimport { getId } from \"./ids\";\nimport { isEqual } from \"lodash\";\n\nfunction isExtractedSpriteArray(arr: unknown): arr is ExtractedSprite[] {\n    if (!Array.isArray(arr)) {\n        return false;\n    }\n\n    if (arr.length === 0) {\n        return true;\n    }\n\n    if (\"composedX\" in arr[0]) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function getMaxY(entities: ExtractedTile[] | ExtractedSprite[]): number {\n    let tiles: ExtractedTile[];\n\n    if (isExtractedSpriteArray(entities)) {\n        tiles = entities.reduce<ExtractedTile[]>(\n            (b, s) => b.concat(s.tiles),\n            []\n        );\n    } else {\n        tiles = entities;\n    }\n\n    if (tiles.length === 0) {\n        return 0;\n    }\n\n    return Math.max(...tiles.map(t => t.composedY));\n}\n\nexport function getMinY(tiles: ExtractedTile[]): number {\n    if (tiles.length === 0) {\n        return 0;\n    }\n\n    return Math.min(...tiles.map(s => s.composedY));\n}\n\nexport function getMaxX(sprites: ExtractedSprite[]): number {\n    if (sprites.length === 0) {\n        return 0;\n    }\n\n    return Math.max(...sprites.map(s => s.composedX));\n}\n\nexport function getMinX(sprites: ExtractedSprite[]): number {\n    if (sprites.length === 0) {\n        return 0;\n    }\n\n    return Math.min(...sprites.map(s => s.composedX));\n}\n\n/**\n * Determines if two sprite groups have the same sprites.\n *\n * Note this is not a deterministic check, as video ram changes all the time.\n * This is only a safe check if both sprite groups have the same pauseId\n */\nexport function haveSameSprites(\n    a: ExtractedSpriteGroup,\n    b: ExtractedSpriteGroup\n) {\n    const aIndices = a.sprites.map(es => es.spriteMemoryIndex).sort();\n    const bIndices = b.sprites.map(es => es.spriteMemoryIndex).sort();\n\n    return isEqual(aIndices, bIndices);\n}\n\n/**\n * Given a newly formed sprite group, if there are other sprite groups already from the same pauseId,\n * then position this new group relative to them. This makes it so the user doesn't have to try and manually\n * line up groups.\n *\n * example: Samurai Shodown title screen. User drags in background, then drags in \"Samurai\" sprite, the \"Samurai\"\n * sprite will position itself properly on top of the background\n */\nexport function positionSpriteGroupInRelationToExistingGroups(\n    newGroup: ExtractedSpriteGroup,\n    oldGroups: ExtractedSpriteGroup[]\n): ExtractedSpriteGroup {\n    const sameGroup = oldGroups.find(og => og.pauseId === newGroup.pauseId);\n\n    // first sprite from this pauseId? Then there is nothing to position\n    if (!sameGroup) {\n        return newGroup;\n    }\n\n    const diffX = sameGroup.sprites[0].composedX - sameGroup.sprites[0].screenX;\n\n    return {\n        ...newGroup,\n        sprites: moveSprites(newGroup.sprites, diffX, 0, \"screenX\")\n    };\n}\n\nfunction moveSprites(\n    sprites: ExtractedSprite[],\n    diffX: number,\n    diffY: number,\n    baseX: \"composedX\" | \"screenX\" = \"composedX\"\n): ExtractedSprite[] {\n    return sprites.map(sprite => {\n        return {\n            ...sprite,\n            composedX: sprite[baseX] + diffX,\n            tiles: diffY === 0 ? sprite.tiles : moveTiles(sprite.tiles, diffY)\n        };\n    });\n}\n\nexport function moveGroups(\n    groups: ExtractedSpriteGroup[],\n    diffX: number,\n    diffY: number,\n    pauseId: number | undefined\n): ExtractedSpriteGroup[] {\n    return groups.map(group => {\n        if (typeof pauseId === \"number\" && group.pauseId !== pauseId) {\n            return group;\n        }\n\n        return {\n            ...group,\n            sprites: moveSprites(group.sprites, diffX, diffY)\n        };\n    });\n}\n\n/**\n * When the compose window ends up with sprites that are up in the negative region,\n * this method causes all sprites to move down such that no sprites have a\n * negative y coordinate\n */\nexport function pushDownOutOfNegative(layers: Layer[]): Layer[] {\n    const tiles = getAllTilesFromLayers(layers);\n    const minY = getMinY(tiles);\n\n    if (minY >= 0) {\n        return layers;\n    }\n\n    return layers.map(layer => {\n        return {\n            ...layer,\n            groups: moveGroupsY(layer.groups, minY * -1)\n        };\n    });\n}\n\nexport function getAllTilesFromLayers(layers: Layer[]): ExtractedTile[] {\n    const sprites = getAllSpritesFromLayers(layers);\n\n    return sprites.reduce<ExtractedTile[]>((tiles, sprite) => {\n        return tiles.concat(sprite.tiles);\n    }, []);\n}\n\nexport function getAllSpritesFromLayers(layers: Layer[]): ExtractedSprite[] {\n    return layers.reduce<ExtractedSprite[]>((sprites, layer) => {\n        return sprites.concat(getAllSpritesFromGroups(layer.groups));\n    }, []);\n}\n\nfunction getAllSpritesFromGroups(\n    groups: ExtractedSpriteGroup[]\n): ExtractedSprite[] {\n    return groups.reduce<ExtractedSprite[]>((sprites, group) => {\n        return sprites.concat(group.sprites);\n    }, []);\n}\n\nexport function getAllTilesFromGroups(\n    groups: ExtractedSpriteGroup[]\n): ExtractedTile[] {\n    return groups.reduce<ExtractedTile[]>((tiles, group) => {\n        return tiles.concat(getAllTilesFromSprites(group.sprites));\n    }, []);\n}\n\nfunction getAllTilesFromSprites(sprites: ExtractedSprite[]): ExtractedTile[] {\n    return sprites.reduce<ExtractedTile[]>((tiles, sprite) => {\n        return tiles.concat(sprite.tiles);\n    }, []);\n}\n\nfunction moveGroupsY(\n    groups: ExtractedSpriteGroup[],\n    deltaY: number\n): ExtractedSpriteGroup[] {\n    return groups.map(group => {\n        return {\n            ...group,\n            sprites: moveSpritesY(group.sprites, deltaY)\n        };\n    });\n}\n\nfunction moveSpritesY(\n    sprites: ExtractedSprite[],\n    deltaY: number\n): ExtractedSprite[] {\n    return sprites.map(sprite => {\n        return {\n            ...sprite,\n            tiles: moveTiles(sprite.tiles, deltaY)\n        };\n    });\n}\n\nfunction moveTiles(tiles: ExtractedTile[], deltaY: number): ExtractedTile[] {\n    return tiles.map(tile => {\n        return {\n            ...tile,\n            composedY: tile.composedY + deltaY\n        };\n    });\n}\n\n/**\n * When sprites end up with negative x coordinates (most commonly after\n * extending a layer via mirroring), this method will push all sprites to the right\n * such that no sprite has a negative x coordinate\n */\nexport function pushInOutOfNegative(layers: Layer[]): Layer[] {\n    const sprites = getAllSpritesFromLayers(layers);\n    const minX = getMinX(sprites);\n\n    if (minX >= 0) {\n        return layers;\n    }\n\n    return layers.map(layer => {\n        return {\n            ...layer,\n            groups: moveGroupsX(layer.groups, minX * -1)\n        };\n    });\n}\n\nfunction moveGroupsX(\n    groups: ExtractedSpriteGroup[],\n    deltaX: number\n): ExtractedSpriteGroup[] {\n    return groups.map(group => {\n        return {\n            ...group,\n            sprites: moveSprites(group.sprites, deltaX, 0)\n        };\n    });\n}\n\n/**\n * Given a set of sprites, creates a mirror copy of them that is on the right side.\n * The mirroring is always on the y axis\n */\nfunction mirrorSpritesToRight(sprites: ExtractedSprite[]): ExtractedSprite[] {\n    const maxX = getMaxX(sprites);\n\n    return sprites\n        .map(sprite => {\n            return {\n                ...sprite,\n                spriteMemoryIndex: sprite.spriteMemoryIndex,\n                composedX: 2 * maxX - (sprite.composedX + 16),\n                tiles: sprite.tiles.map(t => {\n                    return {\n                        ...t,\n                        horizontalFlip: !t.horizontalFlip\n                    };\n                })\n            };\n        })\n        .reverse();\n}\n\n/**\n * Given a set of sprites, creates a mirror copy of them that is on the left side.\n * The mirroring is always on the y axis\n */\nfunction mirrorSpritesToLeft(sprites: ExtractedSprite[]): ExtractedSprite[] {\n    const minX = getMinX(sprites);\n    const maxX = getMaxX(sprites) + 16;\n    const width = maxX - minX;\n\n    return sprites\n        .map(sprite => {\n            return {\n                ...sprite,\n                spriteMemoryIndex: sprite.spriteMemoryIndex,\n                composedX: minX - width + (maxX - (sprite.composedX + 16)),\n                tiles: sprite.tiles.map(t => {\n                    return {\n                        ...t,\n                        horizontalFlip: !t.horizontalFlip\n                    };\n                })\n            };\n        })\n        .reverse();\n}\n\n/**\n * Given a set of groups, mirrors them on both sides. The mirrored sprites\n * get lumped into a right and left group\n */\nexport function extendGroupsViaMirroring(\n    groups: ExtractedSpriteGroup[],\n    pauseId: number\n): ExtractedSpriteGroup[] {\n    const sprites = groups.reduce<ExtractedSprite[]>((ss, group) => {\n        return ss.concat(group.sprites);\n    }, []);\n\n    const rightMirror = mirrorSpritesToRight(sprites);\n    const leftMirror = mirrorSpritesToLeft(sprites);\n\n    const newLeftGroup = {\n        id: getId(),\n        pauseId,\n        sprites: leftMirror\n    };\n\n    const newRightGroup = {\n        id: getId(),\n        pauseId,\n        sprites: rightMirror\n    };\n\n    return [newLeftGroup, newRightGroup];\n}\n\nexport function setGroupToZeroZero(\n    group: ExtractedSpriteGroup\n): ExtractedSpriteGroup {\n    const minX = getMinX(group.sprites);\n    const minY = getMinY(getAllTilesFromSprites(group.sprites));\n\n    if (minX === 0 && minY === 0) {\n        return group;\n    }\n\n    return {\n        ...group,\n        sprites: moveSprites(group.sprites, -minX, -minY)\n    };\n}\n\nexport function setLayerToZeroZero(layer: Layer): Layer {\n    const minX = getMinX(getAllSpritesFromLayers([layer]));\n    const minY = getMinY(getAllTilesFromLayers([layer]));\n\n    if (minX === 0 && minY === 0) {\n        return layer;\n    }\n\n    const groups = moveGroups(layer.groups, -minX, -minY, undefined);\n\n    return {\n        ...layer,\n        groups\n    };\n}\n","// ALERT!\n// vram addresses in the neo geo are word wide, not byte wide!\n// TODO: can probably just use HEAPU16 and make this all much simpler\n// ALERT!\n\n// in SCB1,\n// each sprite has 64, 16-bit, words\nconst SCB1_SPRITE_SIZE_BYTES = 64 * 2;\n\n// it starts at word $8000, so *2 to get byte address\nconst SCB2_BYTE_OFFSET = 0x8000 * 2;\n\n// it starts at word $8200, so *2 to get byte address\nconst SCB3_BYTE_OFFSET = 0x8200 * 2;\n\n// it starts at word $8400, so *2 to get byte address\nconst SCB4_BYTE_OFFSET = 0x8400 * 2;\n\nexport interface TileData {\n  y: number;\n  tileIndex: number;\n  paletteIndex: number;\n  horizontalFlip: boolean;\n  verticalFlip: boolean;\n  autoAnimation: 0 | 2 | 3;\n}\n\nexport interface SpriteData {\n  spriteMemoryIndex: number;\n  tiles: TileData[];\n  x: number;\n  y: number;\n  sticky: boolean;\n  spriteSize: number;\n}\n\nfunction getTileData(\n  spriteMemoryIndex: number,\n  spriteSize: number,\n  tileYs: number[]\n): TileData[] {\n  const tileRamAddr = window.Module._get_tile_ram_addr();\n  const spriteOffset = SCB1_SPRITE_SIZE_BYTES * spriteMemoryIndex;\n\n  const spriteData: number[] = [];\n\n  for (let i = 0; i < spriteSize * 4; ++i) {\n    spriteData[i] = window.HEAPU8[tileRamAddr + spriteOffset + i];\n  }\n\n  const tileData = [];\n\n  for (let w = 0; w < spriteData.length; w += 4) {\n    const firstWord = spriteData[w] | (spriteData[w + 1] << 8);\n    const secondWord = spriteData[w + 2] | (spriteData[w + 3] << 8);\n\n    // first word = least sig bits of tile index\n    // second word, bits 4 through 7 = most sig bits of tile index\n    let tileIndex = firstWord | (((secondWord >> 4) & 0xf) << 16);\n\n    let autoAnimation: 0 | 2 | 3 = 0;\n\n    // automatic animation\n    if (secondWord & 0x8) {\n      autoAnimation = 3;\n    } else if (secondWord & 0x4) {\n      autoAnimation = 2;\n    }\n\n    // top half of second word is the palette index\n    const paletteIndex = (secondWord >> 8) & 0xff;\n\n    const horizontalFlip = !!(secondWord & 1);\n    const verticalFlip = !!(secondWord & 2);\n\n    tileData.push({\n      y: tileYs[w / 4],\n      tileIndex,\n      paletteIndex,\n      horizontalFlip,\n      verticalFlip,\n      autoAnimation\n    });\n  }\n\n  return tileData;\n}\n\nfunction transformY(rawY: number, yScale: number, spriteSize: number): number {\n  let fullmode;\n\n  if (spriteSize === 0x20) {\n    fullmode = 1;\n  } else if (spriteSize >= 0x21) {\n    fullmode = 2;\n  } else {\n    fullmode = 0;\n  }\n\n  // getting the final screen y is very complicated and\n  // honestly don't fully understand it. This code was copied\n  // from gngeo, video.c#draw_screen()\n  let y = 0x200 - rawY;\n\n  if (y > 0x110) {\n    y -= 0x200;\n  }\n\n  if (fullmode === 2 || (fullmode === 1 && yScale === 0xff)) {\n    while (y < 0) {\n      y += (yScale + 1) << 1;\n    }\n  }\n\n  return y;\n}\n\nfunction getYSpriteSizeSticky(\n  spriteMemoryIndex: number\n): { y: number; tileYs: number[]; spriteSize: number; sticky: boolean } {\n  if (spriteMemoryIndex < 0) {\n    throw new Error(\"getYSpriteSizeSticky: sprite index under zero!\");\n  }\n\n  const tileRamAddr = window.Module._get_tile_ram_addr();\n  const scb3StartAddr = tileRamAddr + SCB3_BYTE_OFFSET;\n\n  const spriteScb3Addr = scb3StartAddr + spriteMemoryIndex * 2;\n\n  const scb3Word =\n    window.HEAPU8[spriteScb3Addr] | (window.HEAPU8[spriteScb3Addr + 1] << 8);\n\n  const sticky = !!((scb3Word >> 6) & 1);\n\n  if (sticky) {\n    return {\n      ...getYSpriteSizeSticky(spriteMemoryIndex - 1),\n      sticky\n    };\n  } else {\n    const yScale = getScale(spriteMemoryIndex, { ignoreSticky: true }).yScale;\n    const spriteSize = scb3Word & 0x3f;\n    const rawY = scb3Word >> 7;\n\n    const y = transformY(rawY, yScale, spriteSize);\n    const tileYs = [];\n\n    for (let t = 0; t < spriteSize; ++t) {\n      tileYs.push((y + 16 * t) % 512);\n    }\n\n    return { y, tileYs, spriteSize, sticky };\n  }\n}\n\nfunction getX(spriteMemoryIndex: number): number {\n  if (spriteMemoryIndex < 0) {\n    throw new Error(\"getX: sprite index under zero!\");\n  }\n\n  const sticky = getYSpriteSizeSticky(spriteMemoryIndex).sticky;\n\n  let x;\n\n  if (sticky) {\n    const xScale = getScale(spriteMemoryIndex).xScale;\n    x = getX(spriteMemoryIndex - 1) + xScale;\n  } else {\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const scb4StartAddr = tileRamAddr + SCB4_BYTE_OFFSET;\n\n    const spriteScb4Addr = scb4StartAddr + spriteMemoryIndex * 2;\n\n    const scb4Word =\n      window.HEAPU8[spriteScb4Addr] | (window.HEAPU8[spriteScb4Addr + 1] << 8);\n\n    x = scb4Word >> 7;\n  }\n\n  if (x >= 0x1f0) {\n    x -= 0x200;\n  }\n\n  return x;\n}\n\nfunction getScale(\n  spriteMemoryIndex: number,\n  options?: { ignoreSticky: boolean }\n): { yScale: number; xScale: number } {\n  if (spriteMemoryIndex < 0) {\n    throw new Error(\"getScale: sprite index under zero!\");\n  }\n\n  if (!options || !options.ignoreSticky) {\n    const sticky = getYSpriteSizeSticky(spriteMemoryIndex).sticky;\n\n    if (sticky) {\n      return getScale(spriteMemoryIndex - 1);\n    }\n  }\n\n  const tileRamAddr = window.Module._get_tile_ram_addr();\n  const scb2StartAddr = tileRamAddr + SCB2_BYTE_OFFSET;\n  const spriteScb2Addr = scb2StartAddr + spriteMemoryIndex * 2;\n\n  const scb2Word =\n    window.HEAPU8[spriteScb2Addr] | (window.HEAPU8[spriteScb2Addr + 1] << 8);\n\n  const yScale = scb2Word & 0xff;\n  const xScale = ((scb2Word >> 8) & 0xf) + 1;\n\n  return { yScale, xScale };\n}\n\nexport function getSpriteData(spriteMemoryIndex: number): SpriteData {\n  const { sticky, y, tileYs, spriteSize } = getYSpriteSizeSticky(\n    spriteMemoryIndex\n  );\n\n  const tiles = getTileData(spriteMemoryIndex, spriteSize, tileYs);\n\n  return {\n    spriteMemoryIndex,\n    tiles,\n    x: getX(spriteMemoryIndex),\n    sticky,\n    y,\n    spriteSize\n  };\n}\n\nexport function isSpriteEmpty(spriteMemoryIndex: number): boolean {\n  return getYSpriteSizeSticky(spriteMemoryIndex).spriteSize === 0;\n}\n","// each palette has 16 colors, each color is a 16 bit rgb value\nconst COLORS_PER_PALETTE = 16;\nconst PALETTE_SIZE_IN_BYTES = COLORS_PER_PALETTE * 2;\n\n/**\n * Convert from a neo geo palette color to a 32 rgb color\n * https://wiki.neogeodev.org/index.php?title=Colors\n */\nfunction convertNeoGeoColorToRGBColor(\n  col16: number\n): [number, number, number, number] {\n  // the least significant bit is shared by each channel\n  // if it is zero, the entire color is a tad darker, hence the name \"dark bit\"\n  const darkBit = (col16 >> 15) & 1;\n\n  const upperB = (col16 & 0xf) << 2;\n  const lowerB = ((col16 >> 12) & 1) << 1;\n  const b5 = upperB | lowerB | darkBit;\n\n  const upperG = ((col16 >> 4) & 0xf) << 2;\n  const lowerG = ((col16 >> 13) & 1) << 1;\n  const g5 = upperG | lowerG | darkBit;\n\n  const upperR = ((col16 >> 8) & 0xf) << 2;\n  const lowerR = ((col16 >> 14) & 1) << 1;\n  const r5 = upperR | lowerR | darkBit;\n\n  // neo geo color channels are six bits (max value of 63), but need to map\n  // them to a 8 bit color channel (max value of 255)\n  const b = (b5 / 63) * 255;\n  const g = (g5 / 63) * 255;\n  const r = (r5 / 63) * 255;\n\n  return [r, g, b, 255];\n}\n\nexport function getNeoGeoPalette(paletteMemoryIndex: number): number[] {\n  if (process.env.ENABLE_DEMO_DUMP) {\n    // @ts-ignore\n    window.neededPalettes = window.neededPalettes || {};\n    // @ts-ignore\n    window.neededPalettes[paletteMemoryIndex] = true;\n  }\n\n  const palAddr = window.Module._get_current_pal_addr();\n  const palOffset = paletteMemoryIndex * PALETTE_SIZE_IN_BYTES;\n  const palIndexInHeap = (palAddr + palOffset) / 2;\n\n  return [\n    ...window.Module.HEAPU16.slice(\n      palIndexInHeap,\n      palIndexInHeap + COLORS_PER_PALETTE\n    )\n  ];\n}\n\nexport function convertNeoGeoPaletteToRGB(\n  neoGeoPalette: number[]\n): Array<[number, number, number, number]> {\n  const mapped = neoGeoPalette.map(convertNeoGeoColorToRGBColor);\n\n  // the first color is always transparent\n  return [[0, 0, 0, 0], ...mapped.slice(1)];\n}\n\nexport function getRgbFromNeoGeoPalette(\n  paletteIndex: number,\n  colorIndex: number\n): number[] {\n  if (colorIndex === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  const palAddr = window.Module._get_current_pal_addr();\n  const palOffset = paletteIndex * PALETTE_SIZE_IN_BYTES;\n  const colorOffset = colorIndex * 2;\n\n  const color: number[] = [];\n\n  for (let i = 0; i < 2; ++i) {\n    color[i] = window.HEAPU8[palAddr + palOffset + colorOffset + i];\n  }\n\n  const combinedColor = color[0] | (color[1] << 8);\n\n  return convertNeoGeoColorToRGBColor(combinedColor);\n}\n\nexport function getBackdropNeoGeoColor(): number {\n  let palAddr = window.Module._get_current_pal_addr();\n\n  // get to the final color in all the palettes, ie the backdrop color\n  // https://wiki.neogeodev.org/index.php?title=Palettes\n  palAddr += 0x1ffe;\n\n  // since we are going to use HEAPU16, divide the address by two\n  palAddr /= 2;\n\n  return window.Module.HEAPU16[palAddr];\n}\n\nexport function neoGeoColorToCSS(neoGeoColor: number): string {\n  const asArray = convertNeoGeoColorToRGBColor(neoGeoColor);\n\n  return `rgb(${asArray[0]}, ${asArray[1]}, ${asArray[2]})`;\n}\n","import { ExtractedSpriteGroup, ExtractedSprite, ExtractedTile } from \"./types\";\nimport { getSpriteData, TileData } from \"./spriteData\";\nimport {\n    getNeoGeoPalette,\n    convertNeoGeoPaletteToRGB\n} from \"../palette/neoGeoPalette\";\nimport { getId } from \"./ids\";\n\nfunction convertTileDataToExtractedTile(tileData: TileData): ExtractedTile {\n    const { y, paletteIndex, ...rest } = tileData;\n    const neoGeoPalette = getNeoGeoPalette(tileData.paletteIndex);\n    const rgbPalette = convertNeoGeoPaletteToRGB(neoGeoPalette);\n\n    return {\n        ...rest,\n        composedY: y,\n        neoGeoPalette,\n        rgbPalette\n    };\n}\n\nexport function getSpriteGroup(spriteMemoryIndex: number): number[] {\n    let rootSpriteIndex = spriteMemoryIndex;\n\n    let spriteData = getSpriteData(rootSpriteIndex);\n\n    while (spriteData.sticky && rootSpriteIndex > 0) {\n        rootSpriteIndex -= 1;\n        spriteData = getSpriteData(rootSpriteIndex);\n    }\n\n    const spriteMemoryIndices = [];\n\n    do {\n        spriteMemoryIndices.push(rootSpriteIndex);\n        rootSpriteIndex += 1;\n        spriteData = getSpriteData(rootSpriteIndex);\n    } while (spriteData.sticky);\n\n    return spriteMemoryIndices;\n}\n\nexport function extractSpriteAndStickyCompanionsToGroup(\n    spriteMemoryIndex: number,\n    composedX: number,\n    pauseId: number,\n    additionalProps: Partial<ExtractedSprite> = {}\n): ExtractedSpriteGroup {\n    const allSpriteMemoryIndices = getSpriteGroup(spriteMemoryIndex);\n\n    return extractSpritesIntoGroup(\n        allSpriteMemoryIndices,\n        composedX,\n        pauseId,\n        additionalProps\n    );\n}\n\nexport function extractSpritesIntoGroup(\n    spriteMemoryIndices: number[],\n    composedX: number,\n    pauseId: number,\n    additionalProps: Partial<ExtractedSprite> = {}\n): ExtractedSpriteGroup {\n    const sprites: ExtractedSprite[] = spriteMemoryIndices.map((smi, i) => {\n        const spriteData = getSpriteData(smi);\n        return {\n            ...additionalProps,\n            pauseId,\n            spriteMemoryIndex: smi,\n            tiles: spriteData.tiles.map(convertTileDataToExtractedTile),\n            screenX: spriteData.x,\n            screenY: spriteData.y,\n            composedX: composedX + i * 16,\n            composedY: spriteData.y\n        };\n    }) as ExtractedSprite[];\n\n    const group: ExtractedSpriteGroup = {\n        id: getId(),\n        pauseId,\n        sprites\n    };\n\n    return group;\n}\n","export function update<T>(obj: T, collection: T[], updates: Partial<T>) {\n    return collection.map(o => {\n        if (o === obj) {\n            return {\n                ...obj,\n                ...updates\n            };\n        } else {\n            return o;\n        }\n    });\n}\n","import {\n    AppState,\n    Layer,\n    ExtractedSpriteGroup,\n    ExtractedSprite,\n    ExtractedTile\n} from \"./types\";\nimport {\n    extendGroupsViaMirroring,\n    haveSameSprites,\n    moveGroups,\n    positionSpriteGroupInRelationToExistingGroups,\n    pushDownOutOfNegative,\n    pushInOutOfNegative,\n    getAllTilesFromLayers\n} from \"./spriteUtil\";\nimport {\n    extractSpriteAndStickyCompanionsToGroup,\n    extractSpritesIntoGroup\n} from \"./extractSpriteGroup\";\nimport { NonUndoableState } from \"./state\";\nimport { getId } from \"./ids\";\nimport { update } from \"./update\";\nimport { without } from \"lodash\";\n\nexport type UndoableAction =\n    | {\n          type: \"ExtractSprite\";\n          spriteMemoryIndex: number;\n          composedX: number;\n      }\n    | {\n          type: \"ExtractSpritesToGroup\";\n          spriteMemoryIndices: number[];\n          composedX: number;\n      }\n    | {\n          type: \"MoveSprite\";\n          spriteMemoryIndex: number;\n          newComposedX: number;\n          pauseId: number;\n      }\n    | { type: \"DeleteGroup\"; group: ExtractedSpriteGroup }\n    | { type: \"NewLayer\" }\n    | { type: \"DeleteLayer\"; layer: Layer }\n    | { type: \"ExtendLayerViaMirror\"; layer: Layer }\n    | {\n          type: \"RemoveSpriteFromExtractedGroup\";\n          group: ExtractedSpriteGroup;\n          sprite: ExtractedSprite;\n      }\n    | { type: \"RotateLayer\"; layer: Layer }\n    | { type: \"PushDownLayer\"; layer: Layer }\n    | { type: \"PushAllDown\" };\n\nexport const initialState: AppState = {\n    layers: []\n};\n\nfunction rotateTiles(\n    tiles: ExtractedTile[],\n    minY: number,\n    maxY: number\n): ExtractedTile[] {\n    if (tiles.length === 0) {\n        return tiles;\n    }\n\n    return tiles.map(tile => {\n        // if the tile is beyond maxY, then it is not on a 16px boundary.\n        // so when it wraps to the top, need to offset it from minY to maintain\n        // its position\n        const needsToWrap = tile.composedY >= maxY;\n        const wrapOffset = tile.composedY - maxY;\n\n        const newY = needsToWrap ? minY + wrapOffset : tile.composedY + 16;\n\n        return {\n            ...tile,\n            composedY: newY\n        };\n    });\n}\n\nfunction rotateSprites(\n    sprites: ExtractedSprite[],\n    minY: number,\n    maxY: number\n): ExtractedSprite[] {\n    return sprites.map(sprite => {\n        return {\n            ...sprite,\n            tiles: rotateTiles(sprite.tiles, minY, maxY)\n        };\n    });\n}\n\nfunction rotateLayer(layer: Layer, allLayers: Layer[]): Layer {\n    const tiles = getAllTilesFromLayers(allLayers);\n\n    // when wrapping, we only want to wrap on a 16 pixel boundary.\n    // To accomplish that, find min/max tiles that are on the boundary. Tiles that are off the boundary\n    // (typically small sprites on top of a background sprite), let them hang over when wrapping\n    const minY = tiles.reduce((minY, tile) => {\n        if (tile.composedY < minY && tile.composedY % 16 === 0) {\n            return tile.composedY;\n        } else {\n            return minY;\n        }\n    }, Infinity);\n\n    if (minY === Infinity) {\n        return layer;\n    }\n\n    const maxY = tiles.reduce((maxY, tile) => {\n        if (tile.composedY > maxY && tile.composedY % 16 === 0) {\n            return tile.composedY;\n        } else {\n            return maxY;\n        }\n    }, -Infinity);\n\n    if (maxY === -Infinity) {\n        return layer;\n    }\n\n    const groups = layer.groups.map(group => {\n        return {\n            ...group,\n            sprites: rotateSprites(group.sprites, minY, maxY)\n        };\n    });\n\n    return {\n        ...layer,\n        groups\n    };\n}\n\nexport function reducer(\n    state: AppState,\n    action: UndoableAction,\n    nonUndoableState: NonUndoableState\n): AppState {\n    switch (action.type) {\n        case \"ExtractSpritesToGroup\":\n        case \"ExtractSprite\": {\n            let newSpriteGroup: ExtractedSpriteGroup;\n\n            if (\"spriteMemoryIndex\" in action) {\n                const { spriteMemoryIndex, composedX } = action;\n\n                newSpriteGroup = extractSpriteAndStickyCompanionsToGroup(\n                    spriteMemoryIndex,\n                    composedX,\n                    nonUndoableState.pauseId\n                );\n            } else {\n                const { spriteMemoryIndices, composedX } = action;\n\n                newSpriteGroup = extractSpritesIntoGroup(\n                    spriteMemoryIndices,\n                    composedX,\n                    nonUndoableState.pauseId,\n                    { isAdhoc: true }\n                );\n            }\n\n            const layer = [...state.layers]\n                .reverse()\n                .find(l => !nonUndoableState.hiddenLayers[l.id]) || {\n                id: getId(),\n                groups: [newSpriteGroup]\n            };\n\n            const oldSpriteGroups = layer.groups.filter(\n                esg =>\n                    esg.pauseId !== newSpriteGroup.pauseId ||\n                    !haveSameSprites(esg, newSpriteGroup)\n            );\n\n            newSpriteGroup = positionSpriteGroupInRelationToExistingGroups(\n                newSpriteGroup,\n                oldSpriteGroups\n            );\n\n            let layers;\n\n            if (state.layers.length === 0) {\n                layers = [layer];\n            } else {\n                layers = update(layer, state.layers, {\n                    groups: [...layer.groups, newSpriteGroup]\n                });\n            }\n\n            return {\n                ...state,\n                layers\n            };\n        }\n\n        case \"MoveSprite\": {\n            const { spriteMemoryIndex, newComposedX, pauseId } = action;\n\n            const layer = state.layers.find(l => {\n                return l.groups.some(g => {\n                    return g.sprites.some(s => {\n                        return (\n                            s.spriteMemoryIndex === spriteMemoryIndex &&\n                            s.pauseId === pauseId\n                        );\n                    });\n                });\n            });\n\n            if (!layer) {\n                return state;\n            }\n\n            const currentSpriteGroup = layer.groups.find(sg => {\n                return (\n                    sg.pauseId === pauseId &&\n                    sg.sprites.some(\n                        s => s.spriteMemoryIndex === spriteMemoryIndex\n                    )\n                );\n            });\n\n            if (!currentSpriteGroup) {\n                return state;\n            }\n\n            const diffX =\n                newComposedX - currentSpriteGroup.sprites[0].composedX;\n            const movedGroups = moveGroups(layer.groups, diffX, 0, pauseId);\n\n            return {\n                ...state,\n                layers: update(layer, state.layers, {\n                    groups: movedGroups\n                })\n            };\n        }\n\n        case \"DeleteGroup\": {\n            const { group } = action;\n            const layer = state.layers.find(\n                layer => layer.groups.indexOf(group) > -1\n            );\n\n            if (!layer) {\n                throw new Error(\n                    \"DeleteGroup: can't find the layer this group belongs to\"\n                );\n            }\n\n            const groups = without(layer.groups, group);\n            const layers = update(layer, state.layers, { groups });\n\n            return {\n                ...state,\n                layers\n            };\n        }\n\n        case \"NewLayer\": {\n            const newLayer = {\n                id: getId(),\n                groups: [],\n                hidden: false\n            };\n\n            return {\n                ...state,\n                layers: [...state.layers, newLayer]\n            };\n        }\n\n        case \"DeleteLayer\": {\n            const { layer } = action;\n\n            return {\n                ...state,\n                layers: state.layers.filter(l => l !== layer)\n            };\n        }\n\n        case \"ExtendLayerViaMirror\": {\n            const { layer } = action;\n\n            // don't bother to mirror an empty layer\n            if (layer.groups.length === 0) {\n                return state;\n            }\n\n            const mirroredGroups = extendGroupsViaMirroring(\n                layer.groups,\n                nonUndoableState.pauseId\n            );\n\n            const newLayer = {\n                id: getId(),\n                groups: mirroredGroups,\n                hidden: false\n            };\n\n            const originalLayerIndex = state.layers.indexOf(layer);\n\n            let layers;\n\n            if (originalLayerIndex === 0) {\n                layers = [newLayer, ...state.layers];\n            } else {\n                layers = [\n                    ...state.layers.slice(0, originalLayerIndex - 1),\n                    newLayer,\n                    ...state.layers.slice(originalLayerIndex - 1)\n                ];\n            }\n\n            layers = pushInOutOfNegative(layers);\n\n            return {\n                ...state,\n                layers\n            };\n        }\n\n        case \"RemoveSpriteFromExtractedGroup\": {\n            const { group, sprite } = action;\n\n            const layer = state.layers.find(\n                layer => layer.groups.indexOf(group) > -1\n            );\n\n            if (!layer) {\n                throw new Error(\n                    \"RemoveSpriteFromExtractedGroup: cant find layer for group\"\n                );\n            }\n\n            const groups = update(group, layer.groups, {\n                sprites: without(group.sprites, sprite)\n            });\n\n            const layers = update(layer, state.layers, { groups });\n\n            return {\n                ...state,\n                layers\n            };\n        }\n\n        case \"RotateLayer\": {\n            const { layer } = action;\n\n            const layers = update(\n                layer,\n                state.layers,\n                rotateLayer(layer, state.layers)\n            );\n\n            return {\n                ...state,\n                layers\n            };\n        }\n\n        case \"PushDownLayer\": {\n            const { layer } = action;\n\n            const [pushedLayer] = pushDownOutOfNegative([layer]);\n\n            const layers = update(layer, state.layers, pushedLayer);\n\n            return {\n                ...state,\n                layers\n            };\n        }\n\n        case \"PushAllDown\": {\n            const layers = pushDownOutOfNegative(state.layers);\n\n            return {\n                ...state,\n                layers\n            };\n        }\n    }\n}\n","import { AppState, Layer, Crop, ExtractedSpriteGroup } from \"./types\";\nimport { UndoableAction } from \"./undoableState\";\n\nexport type DemoData = {\n  palettes: Record<number, number[]>;\n  spriteMemory: number[];\n  tileMemory: Record<number, number[]>;\n};\n\nexport type Action =\n  | UndoableAction\n  | { type: \"StartEmulation\" }\n  | { type: \"SetDemo\"; demoData: DemoData }\n  | { type: \"TogglePause\" }\n  | { type: \"SetFocusedLayer\"; layer: Layer }\n  | { type: \"SetCrop\"; crop: Crop }\n  | { type: \"ToggleGrid\" }\n  | { type: \"ToggleCropping\" }\n  | { type: \"ClearCrop\" }\n  | { type: \"TogglePreview\" }\n  | { type: \"ToggleVisibilityOfGroup\"; group: ExtractedSpriteGroup }\n  | { type: \"ToggleVisibilityOfLayer\"; layer: Layer }\n  | { type: \"BuildGif\" }\n  | { type: \"StopBuildGif\" }\n  | { type: \"undo\" }\n  | { type: \"redo\" };\n\nexport type ActionType = Action[\"type\"];\n\nexport type State = {\n  past: AppState[];\n  present: AppState;\n  future: AppState[];\n\n  /**\n   * indicates emulation has started, it may have since been paused\n   */\n  hasStarted: boolean;\n\n  /**\n   * true if the emulator has paused, false if is either running\n   * or has yet to start. It is only safe to access Neo Geo memory\n   * during a pause. In general the UI should largely \"shut down\" when\n   * this value is false\n   */\n  isPaused: boolean;\n\n  /**\n   * Indicates which pause session we are currently on.\n   * If this value increments, the user has unpaused then repaused\n   * the emulation. At that point, it is no longer safe to assume\n   * Neo Geo memory has not changed\n   */\n  pauseId: number;\n\n  /**\n   * Whether the user is currently cropping\n   */\n  isCropping: boolean;\n\n  /**\n   * A crop for the compose screen. When the gif is built, only\n   * the tiles inside the crop boundaries are considered\n   */\n  crop?: Crop;\n\n  /**\n   * Whether the animation is currently being previewed or not\n   */\n  isPreviewing: boolean;\n\n  /**\n   * Whether the user is currently having their gif be built\n   */\n  isBuildingGif: boolean;\n\n  /**\n   * Whether to show an outline around extracted tiles. Helps show\n   * the real bounds of a sprite group\n   */\n  showGrid: boolean;\n\n  hiddenLayers: Record<number, boolean>;\n  hiddenGroups: Record<number, boolean>;\n\n  /**\n   * Whether the app is in demo mode\n   */\n  isDemoing: boolean;\n};\n\nexport type NonUndoableState = Omit<State, \"past\" | \"present\" | \"future\">;\n\nconst DEMO_PALETTE_ADDRESS = 1379916;\n\nfunction copySpriteDataToHeap(data: number[]) {\n  window.HEAPU8.set(data, window.Module._get_tile_ram_addr());\n}\n\nfunction copyTileDataToHeap(data: Record<string, number[]>) {\n  Object.keys(data).forEach(key => {\n    const keyData = data[key];\n\n    window.HEAPU8.set(\n      keyData,\n      window.Module._get_rom_ctile_addr() + Number(key) * 16 * 4 * 2\n    );\n  });\n}\n\nfunction copyPaletteDataToHeap(data: Record<string, number[]>) {\n  const PALETTE_SIZE_IN_BYTES = 32;\n\n  Object.keys(data).forEach(key => {\n    const keyData = data[key];\n\n    const palAddr = DEMO_PALETTE_ADDRESS;\n    const palOffset = Number(key) * PALETTE_SIZE_IN_BYTES;\n    const palIndexInHeap = (palAddr + palOffset) / 2;\n\n    window.Module.HEAPU16.set(keyData, palIndexInHeap);\n  });\n}\n\nexport function getReducer(\n  initialAppState: AppState,\n  reducer: (\n    state: AppState,\n    action: UndoableAction,\n    nonUndoableState: NonUndoableState\n  ) => AppState\n) {\n  const initialState: State = {\n    past: [],\n    present: initialAppState,\n    future: [],\n    hasStarted: false,\n    isPaused: false,\n    pauseId: 0,\n    isCropping: false,\n    crop: undefined,\n    isPreviewing: false,\n    isBuildingGif: false,\n    showGrid: false,\n    hiddenLayers: {},\n    hiddenGroups: {},\n    isDemoing: false\n  };\n\n  function proxyReducer(state: State, action: Action): State {\n    let newState;\n\n    switch (action.type) {\n      case \"StartEmulation\":\n        return {\n          ...state,\n          hasStarted: true\n        };\n\n      case \"TogglePause\":\n        const nowPaused = !state.isPaused;\n        return {\n          ...state,\n          isPaused: nowPaused,\n          pauseId: nowPaused ? state.pauseId + 1 : state.pauseId\n        };\n\n      case \"ToggleGrid\": {\n        return {\n          ...state,\n          showGrid: !state.showGrid\n        };\n      }\n\n      case \"ToggleCropping\": {\n        return {\n          ...state,\n          isCropping: !state.isCropping,\n          crop: undefined\n        };\n      }\n\n      case \"SetCrop\": {\n        const { crop } = action;\n\n        return {\n          ...state,\n          crop\n        };\n      }\n\n      case \"ClearCrop\": {\n        return {\n          ...state,\n          crop: undefined,\n          isCropping: false\n        };\n      }\n\n      case \"TogglePreview\": {\n        return {\n          ...state,\n          isPreviewing: !state.isPreviewing\n        };\n      }\n\n      case \"BuildGif\": {\n        return {\n          ...state,\n          isBuildingGif: true\n        };\n      }\n\n      case \"StopBuildGif\": {\n        return {\n          ...state,\n          isBuildingGif: false\n        };\n      }\n\n      case \"ToggleVisibilityOfGroup\": {\n        const { group } = action;\n\n        return {\n          ...state,\n          hiddenGroups: {\n            ...state.hiddenGroups,\n            [group.id]: !state.hiddenGroups[group.id]\n          }\n        };\n      }\n\n      case \"ToggleVisibilityOfLayer\": {\n        const { layer } = action;\n\n        return {\n          ...state,\n          hiddenLayers: {\n            ...state.hiddenLayers,\n            [layer.id]: !state.hiddenLayers[layer.id]\n          }\n        };\n      }\n\n      case \"undo\": {\n        const pastCopy = [...state.past];\n        const newPresent = pastCopy.pop();\n\n        if (!newPresent) {\n          throw new Error(\"undo: nothing to undo!\");\n        }\n\n        newState = {\n          ...state,\n          past: pastCopy,\n          present: newPresent,\n          future: [...state.future, state.present]\n        };\n        break;\n      }\n      case \"redo\": {\n        const futureCopy = [...state.future];\n        const newPresent = futureCopy.pop();\n\n        if (!newPresent) {\n          throw new Error(\"redo: nothing to redo!\");\n        }\n\n        newState = {\n          ...state,\n          past: [...state.past, state.present],\n          present: newPresent,\n          future: futureCopy\n        };\n        break;\n      }\n\n      case \"SetDemo\": {\n        const { demoData } = action;\n\n        copySpriteDataToHeap(demoData.spriteMemory);\n        copyTileDataToHeap(demoData.tileMemory);\n        copyPaletteDataToHeap(demoData.palettes);\n\n        window.Module._get_current_pal_addr = () => DEMO_PALETTE_ADDRESS;\n\n        return {\n          ...state,\n          isDemoing: true,\n          hasStarted: true,\n          isPaused: true,\n          pauseId: 1\n        };\n      }\n\n      default: {\n        newState = {\n          ...state,\n          past: [...state.past, state.present],\n          present: reducer(state.present, action as UndoableAction, state)\n        };\n        break;\n      }\n    }\n\n    return newState;\n  }\n\n  return {\n    initialState,\n    reducer: proxyReducer\n  };\n}\n","import React, {\n    createContext,\n    Dispatch,\n    FunctionComponent,\n    useReducer\n} from \"react\";\nimport {\n    initialState as undoableInitialState,\n    reducer as undoableReducer\n} from \"./undoableState\";\nimport { getReducer, Action } from \"./state\";\n\nconst { initialState, reducer } = getReducer(\n    undoableInitialState,\n    undoableReducer\n);\n\nexport const stateContext = createContext(initialState);\nexport const dispatchContext = createContext((() => 0) as Dispatch<Action>);\n\nexport const Provider: FunctionComponent = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n        <dispatchContext.Provider value={dispatch}>\n            <stateContext.Provider value={state}>\n                {children}\n            </stateContext.Provider>\n        </dispatchContext.Provider>\n    );\n};\n","import { memoize } from \"lodash\";\nimport { RgbPalette } from \"./types\";\n\n// 16 rows, each row has 2 ints (32 bits each)\nconst TILE_SIZE_INTS = 2 * 16;\nconst TILE_SIZE_BYTES = TILE_SIZE_INTS * 4;\n\nconst map: Record<string, number> = {\n  0: 3,\n  1: 2,\n  2: 1,\n  3: 0,\n  4: 7,\n  5: 6,\n  6: 5,\n  7: 4\n};\n\nexport const getTileIndexedColorData = memoize(function getTileIndexedColorData(\n  tileIndex: number\n): number[] {\n  const cromAddr = window.Module._get_rom_ctile_addr();\n  const tileOffset = TILE_SIZE_BYTES * tileIndex;\n\n  const tileData: number[] = [];\n\n  for (let i = 0; i < TILE_SIZE_BYTES; ++i) {\n    tileData[i] = window.HEAPU8[cromAddr + tileOffset + i];\n    // console.log(\"tileData[i]\", tileIndex, tileData[i]);\n  }\n\n  const tileIndexData: number[] = [];\n\n  for (let y = 0; y < 16; ++y) {\n    for (let x = 0; x < 8; ++x) {\n      const pixelPair = tileData[y * 8 + map[x]];\n\n      const leftPixelColorIndex = (pixelPair >> 4) & 0xf;\n      const rightPixelColorIndex = pixelPair & 0xf;\n\n      tileIndexData.push(leftPixelColorIndex, rightPixelColorIndex);\n    }\n  }\n\n  return tileIndexData;\n});\n\nfunction hashPalette(palette: RgbPalette): number {\n  return palette.reduce<number>((hash, color) => {\n    return color.reduce<number>((innerHash, channel) => {\n      return innerHash * 19 + channel;\n    }, hash);\n  }, 17);\n}\n\nconst tileCanvasCache: Record<string, HTMLCanvasElement> = {};\n\nexport function renderTileToCanvas(\n  destCanvas: HTMLCanvasElement,\n  tileIndex: number,\n  rgbPalette: RgbPalette\n) {\n  if (process.env.ENABLE_DEMO_DUMP) {\n    // @ts-ignore\n    window.neededTiles = window.neededTiles || {};\n    // @ts-ignore\n    window.neededTiles[tileIndex] = true;\n  }\n\n  destCanvas.width = 16;\n  destCanvas.height = 16;\n\n  const destContext = destCanvas.getContext(\"2d\")!;\n  const key = `${tileIndex}-${hashPalette(rgbPalette)}`;\n\n  if (tileCanvasCache[key]) {\n    destContext.drawImage(tileCanvasCache[key], 0, 0);\n    return destCanvas;\n  }\n\n  const cacheCanvas = document.createElement(\"canvas\");\n  cacheCanvas.width = 16;\n  cacheCanvas.height = 16;\n  const cacheContext = cacheCanvas.getContext(\"2d\")!;\n\n  const indexedTileData = getTileIndexedColorData(tileIndex);\n\n  const imageData = cacheContext.getImageData(0, 0, 16, 16);\n\n  for (let y = 0; y < 16; ++y) {\n    for (let x = 0; x < 16; ++x) {\n      const pixelPaletteIndex = indexedTileData[y * 16 + x];\n      const pixel = rgbPalette[pixelPaletteIndex];\n\n      for (let i = 0; i < pixel.length; ++i) {\n        imageData.data[(y * 16 + x) * 4 + i] = pixel[i];\n      }\n    }\n  }\n\n  cacheContext.putImageData(imageData, 0, 0);\n\n  tileCanvasCache[key] = cacheCanvas;\n  renderTileToCanvas(destCanvas, tileIndex, rgbPalette);\n}\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { renderTileToCanvas } from \"../state/renderTileToCanvas\";\n\nimport styles from \"./extractedTile.module.css\";\n\ninterface ExtractedTileProps {\n    y: number;\n    tileIndex: number;\n    rgbPalette: Array<[number, number, number, number]>;\n    horizontalFlip?: boolean;\n    verticalFlip?: boolean;\n    outlined?: boolean;\n}\n\nexport const ExtractedTile: React.FunctionComponent<\n    ExtractedTileProps\n> = React.memo<ExtractedTileProps>(\n    ({\n        y: tileY,\n        tileIndex,\n        rgbPalette,\n        horizontalFlip,\n        verticalFlip,\n        outlined\n    }) => {\n        function renderCanvas(canvas: HTMLCanvasElement) {\n            renderTileToCanvas(canvas, tileIndex, rgbPalette);\n        }\n\n        const horizontalScale = horizontalFlip ? -1 : 1;\n        const verticalScale = verticalFlip ? -1 : 1;\n\n        const classes = classnames(styles.root, {\n            [styles.outlined]: outlined\n        });\n\n        const inlineStyle = {\n            transform: `scale(${horizontalScale},${verticalScale})`,\n            top: tileY\n        };\n\n        return (\n            <canvas\n                className={classes}\n                data-tileindex={tileIndex}\n                ref={r => r && renderCanvas(r)}\n                style={inlineStyle}\n            />\n        );\n    }\n);\n","import React, { useEffect } from \"react\";\nimport { useDrag } from \"react-dnd\";\nimport { getEmptyImage } from \"react-dnd-html5-backend\";\nimport { ExtractedSprite as ExtractedSpriteData } from \"../state/types\";\nimport { ExtractedTile } from \"./extractedTile\";\n\nimport styles from \"./extractedSprite.module.css\";\n\ninterface ExtractedSpriteProps {\n  data: ExtractedSpriteData;\n  autoAnimate?: boolean;\n  animationCounter?: number;\n  canDrag: boolean;\n  outlineTiles?: boolean;\n  setYToZero?: boolean;\n  overrideX?: number;\n}\n\nexport const ExtractedSprite: React.FunctionComponent<ExtractedSpriteProps> = ({\n  data,\n  autoAnimate,\n  animationCounter,\n  canDrag,\n  outlineTiles,\n  setYToZero,\n  overrideX\n}) => {\n  const [, dragRef, preview] = useDrag({\n    item: {\n      spriteMemoryIndex: data.spriteMemoryIndex,\n      pauseId: data.pauseId,\n      type: \"Sprite\",\n      isAdhoc: data.isAdhoc\n    },\n    canDrag() {\n      return canDrag;\n    }\n  });\n\n  useEffect(() => {\n    preview(getEmptyImage(), { captureDraggingState: true });\n  }, [preview]);\n\n  const tiles = data.tiles.map((tileData, i) => {\n    let tileIndex = tileData.tileIndex;\n\n    if (autoAnimate && typeof animationCounter === \"number\") {\n      if (tileData.autoAnimation === 3) {\n        // 3 bit auto animation: the 4th bit is set, indicating this tile does 3bit auto animation\n        // that means take its tileIndex, and replace its bottom three bits with those of the animation counter\n        tileIndex = (tileIndex & ~7) + ((tileIndex + animationCounter) & 7);\n      }\n      if (tileData.autoAnimation === 2) {\n        // 2 bit auto animation: like above but replace its bottom two bits\n        tileIndex = (tileIndex & ~3) + ((tileIndex + animationCounter) & 3);\n      }\n    }\n\n    return (\n      <ExtractedTile\n        key={i}\n        y={tileData.composedY - data.composedY}\n        tileIndex={tileIndex}\n        rgbPalette={tileData.rgbPalette}\n        horizontalFlip={tileData.horizontalFlip}\n        verticalFlip={tileData.verticalFlip}\n        outlined={outlineTiles}\n      />\n    );\n  });\n\n  const style = {\n    top: setYToZero ? 0 : data.composedY,\n    left: typeof overrideX === \"number\" ? overrideX : data.composedX,\n    gridTemplateRows: `repeat(${data.tiles.length}, 16px)`,\n    zIndex: data.spriteMemoryIndex\n  };\n\n  return (\n    <div ref={dragRef} className={styles.root} style={style}>\n      {tiles}\n    </div>\n  );\n};\n","import React from \"react\";\nimport {\n    extractSpriteAndStickyCompanionsToGroup,\n    extractSpritesIntoGroup\n} from \"./state/extractSpriteGroup\";\nimport { ExtractedSprite } from \"./composeScreen/extractedSprite\";\n\ninterface StickySpriteGroupDragPreviewProps {\n    seedSpriteMemoryIndex: number;\n}\n\nexport const StickySpriteGroupDragPreview: React.FunctionComponent<\n    StickySpriteGroupDragPreviewProps\n> = React.memo<StickySpriteGroupDragPreviewProps>(\n    ({ seedSpriteMemoryIndex }) => {\n        const spriteGroupData = extractSpriteAndStickyCompanionsToGroup(\n            seedSpriteMemoryIndex,\n            0,\n            0\n        );\n\n        const sprites = spriteGroupData.sprites.map((sprite, i) => (\n            <ExtractedSprite key={i} data={sprite} canDrag={false} setYToZero />\n        ));\n\n        return <div>{sprites}</div>;\n    }\n);\n\ninterface AdhocSpriteGroupDragPreviewProps {\n    spriteMemoryIndices: number[];\n}\n\nexport const AdhocSpriteGroupDragPreview: React.FunctionComponent<\n    AdhocSpriteGroupDragPreviewProps\n> = React.memo<AdhocSpriteGroupDragPreviewProps>(({ spriteMemoryIndices }) => {\n    const spriteGroupData = extractSpritesIntoGroup(spriteMemoryIndices, 0, 0);\n\n    const sprites = spriteGroupData.sprites.map((sprite, i) => (\n        <ExtractedSprite key={i} data={sprite} canDrag={false} setYToZero />\n    ));\n\n    return <div>{sprites}</div>;\n});\n","import React from \"react\";\nimport { useDragLayer } from \"react-dnd\";\nimport {\n    StickySpriteGroupDragPreview,\n    AdhocSpriteGroupDragPreview\n} from \"./SpriteGroupDragPreview\";\n\nexport const DragPreviewLayer: React.FunctionComponent = () => {\n    const { isDragging, item, currentOffset } = useDragLayer(monitor => {\n        return {\n            item: monitor.getItem(),\n            initialOffset: monitor.getInitialSourceClientOffset(),\n            currentOffset: monitor.getClientOffset(),\n            isDragging: monitor.isDragging()\n        };\n    });\n\n    if (\n        !isDragging ||\n        !currentOffset ||\n        (item.type !== \"Sprite\" && item.type !== \"Sprites\")\n    ) {\n        return null;\n    }\n\n    const style = {\n        position: \"fixed\",\n        top: currentOffset.y + 4,\n        left: currentOffset.x + 4,\n        zIndex: 1000\n    } as const;\n\n    let spritesCmp;\n\n    if (item.type === \"Sprite\" && !item.isAdhoc) {\n        spritesCmp = (\n            <StickySpriteGroupDragPreview\n                seedSpriteMemoryIndex={item.spriteMemoryIndex}\n            />\n        );\n    } else if (item.type === \"Sprite\" && item.isAdhoc) {\n        spritesCmp = (\n            <AdhocSpriteGroupDragPreview\n                spriteMemoryIndices={[item.spriteMemoryIndex]}\n            />\n        );\n    } else {\n        spritesCmp = (\n            <AdhocSpriteGroupDragPreview\n                spriteMemoryIndices={item.spriteMemoryIndices}\n            />\n        );\n    }\n\n    return <div style={style}>{spritesCmp}</div>;\n};\n","import { useContext, Dispatch } from \"react\";\nimport { AppState } from \"./types\";\nimport { Action, ActionType, NonUndoableState } from \"./state\";\nimport { stateContext, dispatchContext } from \"./provider\";\n\nexport function useAppState(): {\n  state: AppState & NonUndoableState;\n  dispatch: Dispatch<Action | ActionType>;\n  undo: () => void;\n  redo: () => void;\n  canUndo: boolean;\n  canRedo: boolean;\n} {\n  const actualDispatch = useContext(dispatchContext);\n  const rawState = useContext(stateContext);\n\n  const { past, present, future, ...nonUndoableState } = rawState;\n\n  const state = {\n    ...rawState.present,\n    ...nonUndoableState\n  };\n\n  return {\n    state,\n    dispatch(actionOrType: Action | ActionType) {\n      if (typeof actionOrType === \"string\") {\n        return actualDispatch({ type: actionOrType } as Action);\n      } else {\n        return actualDispatch(actionOrType);\n      }\n    },\n    undo() {\n      actualDispatch({ type: \"undo\" });\n    },\n    redo() {\n      actualDispatch({ type: \"redo\" });\n    },\n    canUndo: rawState.past.length > 0,\n    canRedo: rawState.future.length > 0\n  };\n}\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport PlayArrow from \"@material-ui/icons/PlayArrow\";\nimport Pause from \"@material-ui/icons/Pause\";\n\ninterface PauseOverlayProps {\n  className?: string;\n  onTogglePause: () => void;\n  isPaused: boolean;\n}\n\nconst Container = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: rgba(0, 0, 0, 0.2);\n\n  & svg {\n    width: 30%;\n    height: 30%;\n  }\n`;\n\nexport const PauseOverlay: React.FunctionComponent<PauseOverlayProps> = ({\n  className,\n  onTogglePause,\n  isPaused\n}) => {\n  const Icon = isPaused ? PlayArrow : Pause;\n\n  return (\n    <Container\n      className={className}\n      onClick={() => onTogglePause()}\n      title={`click to ${isPaused ? \"play\" : \"pause\"}`}\n    >\n      <Icon />\n    </Container>\n  );\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport { useAppState } from \"../state\";\nimport { PauseOverlay } from \"./pauseOverlay\";\n\ninterface EmulatorProps {\n  className?: string;\n}\n\nconst Container = styled.div`\n  width: 320px;\n  height: 224px;\n  background-color: var(--dock-color);\n  position: relative;\n\n  & .pauseOverlay {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    transition-property: opacity;\n    transition-duration: 0.25s;\n    cursor: pointer;\n  }\n\n  & .pauseOverlay:hover {\n    opacity: 1;\n  }\n`;\n\nconst DemoDisclaimer = styled.div`\n  height: 100%;\n  padding: 8px;\n\n  display: flex;\n  flex-direction: column;\n  align-content: center;\n  justify-content: center;\n  text-align: center;\n  font-style: italic;\n  color: var(--dock-foreground-color);\n`;\n\nexport const Emulator: React.FunctionComponent<EmulatorProps> = props => {\n  const { state, dispatch } = useAppState();\n\n  function togglePause() {\n    if (state.isPaused) {\n      window.Module.resumeMainLoop();\n    } else {\n      window.Module.pauseMainLoop();\n    }\n\n    dispatch(\"TogglePause\");\n  }\n\n  return (\n    <Container className={props.className}>\n      {!state.isDemoing && (\n        <>\n          <canvas id=\"canvas\" />\n          <PauseOverlay\n            className=\"pauseOverlay\"\n            onTogglePause={() => togglePause()}\n            isPaused={state.isPaused}\n          />\n        </>\n      )}\n      {state.isDemoing && (\n        <DemoDisclaimer>\n          the game plays here in an emulator when not in demo mode\n        </DemoDisclaimer>\n      )}\n    </Container>\n  );\n};\n","import React from \"react\";\nimport { renderTileToCanvas } from \"../state/renderTileToCanvas\";\nimport {\n  getNeoGeoPalette,\n  convertNeoGeoPaletteToRGB\n} from \"../palette/neoGeoPalette\";\n\nimport styles from \"./tile.module.css\";\n\ninterface TileProps {\n  tileIndex: number;\n  paletteIndex: number;\n  horizontalFlip?: boolean;\n  verticalFlip?: boolean;\n}\n\nexport const Tile: React.FunctionComponent<TileProps> = React.memo<TileProps>(\n  ({ tileIndex, paletteIndex, horizontalFlip, verticalFlip }) => {\n    function renderCanvas(canvas: HTMLCanvasElement) {\n      const rgbPalette = convertNeoGeoPaletteToRGB(\n        getNeoGeoPalette(paletteIndex)\n      );\n      renderTileToCanvas(canvas, tileIndex, rgbPalette);\n    }\n\n    const horizontalScale = horizontalFlip ? -1 : 1;\n    const verticalScale = verticalFlip ? -1 : 1;\n\n    const inlineStyle = {\n      transform: `scale(${horizontalScale},${verticalScale})`\n    };\n\n    return (\n      <canvas\n        className={styles.canvas}\n        ref={r => r && renderCanvas(r)}\n        style={inlineStyle}\n      />\n    );\n  }\n);\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { Tile } from \"./tile\";\nimport { SpriteData } from \"../state/spriteData\";\n\nimport styles from \"./sprite.module.css\";\n\ninterface SpriteProps {\n  className?: string;\n  spriteData: SpriteData;\n}\n\nexport const Sprite: React.FunctionComponent<SpriteProps> = ({\n  className,\n  spriteData\n}) => {\n  const { spriteMemoryIndex } = spriteData;\n\n  if (spriteData.tiles.length === 0) {\n    return null;\n  }\n\n  const tiles = spriteData.tiles.map(tileData => (\n    <Tile\n      key={tileData.tileIndex + \"-\" + tileData.y}\n      tileIndex={tileData.tileIndex}\n      paletteIndex={tileData.paletteIndex}\n      horizontalFlip={tileData.horizontalFlip}\n      verticalFlip={tileData.verticalFlip}\n    />\n  ));\n\n  const style = {\n    gridTemplateRows: `repeat(${spriteData.tiles.length}, 8px)`,\n    zIndex: spriteMemoryIndex\n  };\n\n  const classes = classnames(styles.sprite, className);\n\n  return (\n    <div className={classes} style={style}>\n      {tiles}\n    </div>\n  );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { Sprite } from \"./sprite\";\nimport { SpriteData } from \"../state/spriteData\";\n\nimport styles from \"./spriteEntry.module.css\";\n\ninterface SpriteEntryProps {\n    className?: string;\n    spriteData: SpriteData;\n    focused?: boolean;\n    onClick: (e: React.MouseEvent<HTMLDivElement>) => void;\n}\n\nexport const SpriteEntry: React.FunctionComponent<SpriteEntryProps> = ({\n    className,\n    spriteData,\n    focused,\n    onClick\n}) => {\n    const classes = classnames(styles.root, className, {\n        [styles.focused]: focused\n    });\n\n    return (\n        <div className={classes} onClick={onClick}>\n            <div className={styles.index}>{spriteData.spriteMemoryIndex}</div>\n            <div className={styles.spriteContainer}>\n                {<Sprite className={styles.sprite} spriteData={spriteData} />}\n            </div>\n        </div>\n    );\n};\n","import React, { useState, useRef, useEffect } from \"react\";\nimport styled from \"styled-components\";\nimport { useDrag } from \"react-dnd\";\nimport { getEmptyImage } from \"react-dnd-html5-backend\";\nimport { SpriteEntry } from \"./spriteEntry\";\nimport { useAppState } from \"../state\";\nimport { getSpriteData } from \"../state/spriteData\";\n\ninterface SpriteTrayProps {\n  className?: string;\n}\n\nconst TOTAL_SPRITE_COUNT = 381;\n\nfunction arrayFrom(minValue: number, maxValue: number) {\n  const count = maxValue - minValue + 1;\n\n  return new Array(count).fill(0, 0, count).map((_, i) => i + minValue);\n}\n\nconst Container = styled.div`\n  --spriteEntryHeader: 32px;\n\n  width: 100%;\n  /* At most a sprite has 33 tiles, plus the sprite entry header is 32px */\n  height: calc(33 * 8px + var(--spriteEntryHeader));\n  background-color: var(--dock-color);\n  border-right: 1px solid var(--dock-border-color);\n  overflow-x: auto;\n`;\n\nconst Message = styled(Container)`\n  margin: auto;\n  text-align: center;\n  font-style: italic;\n  color: var(--dock-foreground-color);\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n`;\n\nconst SpriteEntries = styled.div`\n  display: grid;\n`;\n\nconst Filler = styled.div`\n  background-color: rgba(0, 0, 0, 0.5);\n  height: var(--spriteEntryHeader);\n  width: 100%;\n`;\n\nexport const SpriteTray: React.FunctionComponent<SpriteTrayProps> = ({\n  className\n}) => {\n  const { state } = useAppState();\n  const [focusedEntryIndices, setFocusedEntryIndices] = useState<number[]>([]);\n  const [shiftKeyStartEntryIndex, setShiftKeyStartEntryIndex] = useState<\n    null | number\n  >(null);\n\n  const firstFillerRef = useRef<HTMLDivElement | null>(null);\n\n  const [, dragRef, preview] = useDrag({\n    // @ts-ignore TS insists this have type, spriteMemoryIndex, etc, but it's not actually used\n    item: { type: \"Sprite\" },\n    begin(monitor: any) {\n      if (divRef && firstFillerRef && firstFillerRef.current) {\n        const x =\n          monitor.getClientOffset().x -\n          divRef.getBoundingClientRect().left -\n          firstFillerRef.current.getBoundingClientRect().width +\n          divRef.scrollLeft;\n\n        const index = Math.floor(x / 8);\n\n        if (focusedEntryIndices.indexOf(index) > -1) {\n          return {\n            type: \"Sprites\",\n            spriteMemoryIndices: focusedEntryIndices.map(\n              fei => spriteDatas[fei].spriteMemoryIndex\n            )\n          };\n        } else if (index >= 0 && index < spriteDatas.length) {\n          return {\n            spriteMemoryIndex: spriteDatas[index].spriteMemoryIndex,\n            type: \"Sprite\"\n          };\n        }\n      }\n    },\n    canDrag() {\n      return state.isPaused;\n    }\n  });\n\n  const [divRef, setDivRef] = useState<null | HTMLDivElement>(null);\n\n  useEffect(() => {\n    preview(getEmptyImage(), { captureDraggingState: true });\n  }, [preview]);\n\n  if (!state.isPaused) {\n    return (\n      <Message className={className}>\n        pause the game to load the current sprites\n      </Message>\n    );\n  }\n\n  const spriteDatas = new Array(TOTAL_SPRITE_COUNT)\n    .fill(1, 0, TOTAL_SPRITE_COUNT)\n    .map((_, i) => getSpriteData(i))\n    .filter(d => d.tiles.length > 0);\n\n  const sprites = spriteDatas.map((spriteData, i) => (\n    <SpriteEntry\n      key={spriteData.spriteMemoryIndex + \"-\" + state.pauseId}\n      spriteData={spriteData}\n      onClick={e => {\n        if (e.ctrlKey) {\n          setFocusedEntryIndices(focusedEntryIndices.concat(i));\n          setShiftKeyStartEntryIndex(null);\n        } else if (e.shiftKey) {\n          if (\n            shiftKeyStartEntryIndex !== null ||\n            focusedEntryIndices.length === 1\n          ) {\n            const minIndex = Math.min(\n              shiftKeyStartEntryIndex || focusedEntryIndices[0],\n              i\n            );\n            const maxIndex = Math.max(\n              shiftKeyStartEntryIndex || focusedEntryIndices[0],\n              i\n            );\n            setFocusedEntryIndices(arrayFrom(minIndex, maxIndex));\n          } else {\n            setFocusedEntryIndices([i]);\n            setShiftKeyStartEntryIndex(i);\n          }\n        } else {\n          setFocusedEntryIndices([i]);\n          setShiftKeyStartEntryIndex(null);\n        }\n      }}\n      focused={focusedEntryIndices.indexOf(i) > -1}\n    />\n  ));\n\n  return (\n    <Container\n      className={className}\n      ref={div => {\n        setDivRef(div);\n        dragRef(div);\n      }}\n    >\n      <SpriteEntries\n        key={state.pauseId}\n        style={{\n          gridTemplateColumns: `1fr repeat(${spriteDatas.length}, max-content) 1fr`\n        }}\n      >\n        <Filler ref={firstFillerRef} style={{ gridColumn: 1 }} />\n        {sprites}\n        <Filler style={{ gridColumn: spriteDatas.length + 2 }} />\n      </SpriteEntries>\n    </Container>\n  );\n};\n","/**\n * This class handles LZW encoding\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nexport const LZWEncoder = function() {\n    var exports = {};\n    var EOF = -1;\n    var imgW;\n    var imgH;\n    var pixAry;\n    var initCodeSize;\n    var remaining;\n    var curPixel;\n\n    // GIFCOMPR.C - GIF Image compression routines\n    // Lempel-Ziv compression based on 'compress'. GIF modifications by\n    // David Rowley (mgardi@watdcsu.waterloo.edu)\n    // General DEFINEs\n\n    var BITS = 12;\n    var HSIZE = 5003; // 80% occupancy\n\n    // GIF Image compression - modified 'compress'\n    // Based on: compress.c - File compression ala IEEE Computer, June 1984.\n    // By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n    // Jim McKie (decvax!mcvax!jim)\n    // Steve Davies (decvax!vax135!petsd!peora!srd)\n    // Ken Turkowski (decvax!decwrl!turtlevax!ken)\n    // James A. Woods (decvax!ihnp4!ames!jaw)\n    // Joe Orost (decvax!vax135!petsd!joe)\n\n    var n_bits; // number of bits/code\n    var maxbits = BITS; // user settable max # bits/code\n    var maxcode; // maximum code, given n_bits\n    var maxmaxcode = 1 << BITS; // should NEVER generate this code\n    var htab = [];\n    var codetab = [];\n    var hsize = HSIZE; // for dynamic table sizing\n    var free_ent = 0; // first unused entry\n\n    // block compression parameters -- after all codes are used up,\n    // and compression rate changes, start over.\n\n    var clear_flg = false;\n\n    // Algorithm: use open addressing double hashing (no chaining) on the\n    // prefix code / next character combination. We do a variant of Knuth's\n    // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n    // secondary probe. Here, the modular division first probe is gives way\n    // to a faster exclusive-or manipulation. Also do block compression with\n    // an adaptive reset, whereby the code table is cleared when the compression\n    // ratio decreases, but after the table fills. The variable-length output\n    // codes are re-sized at this point, and a special CLEAR code is generated\n    // for the decompressor. Late addition: construct the table according to\n    // file size for noticeable speed improvement on small files. Please direct\n    // questions about this implementation to ames!jaw.\n\n    var g_init_bits;\n    var ClearCode;\n    var EOFCode;\n\n    // output\n    // Output the given code.\n    // Inputs:\n    // code: A n_bits-bit integer. If == -1, then EOF. This assumes\n    // that n_bits =< wordsize - 1.\n    // Outputs:\n    // Outputs code to the file.\n    // Assumptions:\n    // Chars are 8 bits long.\n    // Algorithm:\n    // Maintain a BITS character long buffer (so that 8 codes will\n    // fit in it exactly). Use the VAX insv instruction to insert each\n    // code in turn. When the buffer fills up empty it and start over.\n\n    var cur_accum = 0;\n    var cur_bits = 0;\n    var masks = [\n        0x0000,\n        0x0001,\n        0x0003,\n        0x0007,\n        0x000f,\n        0x001f,\n        0x003f,\n        0x007f,\n        0x00ff,\n        0x01ff,\n        0x03ff,\n        0x07ff,\n        0x0fff,\n        0x1fff,\n        0x3fff,\n        0x7fff,\n        0xffff\n    ];\n\n    // Number of characters so far in this 'packet'\n    var a_count;\n\n    // Define the storage for the packet accumulator\n    var accum = [];\n\n    var LZWEncoder = (exports.LZWEncoder = function LZWEncoder(\n        width,\n        height,\n        pixels,\n        color_depth\n    ) {\n        imgW = width;\n        imgH = height;\n        pixAry = pixels;\n        initCodeSize = Math.max(2, color_depth);\n    });\n\n    // Add a character to the end of the current packet, and if it is 254\n    // characters, flush the packet to disk.\n    var char_out = function char_out(c, outs) {\n        accum[a_count++] = c;\n        if (a_count >= 254) flush_char(outs);\n    };\n\n    // Clear out the hash table\n    // table clear for block compress\n\n    var cl_block = function cl_block(outs) {\n        cl_hash(hsize);\n        free_ent = ClearCode + 2;\n        clear_flg = true;\n        output(ClearCode, outs);\n    };\n\n    // reset code table\n    var cl_hash = function cl_hash(hsize) {\n        for (var i = 0; i < hsize; ++i) htab[i] = -1;\n    };\n\n    var compress = (exports.compress = function compress(init_bits, outs) {\n        var fcode;\n        var i; /* = 0 */\n        var c;\n        var ent;\n        var disp;\n        var hsize_reg;\n        var hshift;\n\n        // Set up the globals: g_init_bits - initial number of bits\n        g_init_bits = init_bits;\n\n        // Set up the necessary values\n        clear_flg = false;\n        n_bits = g_init_bits;\n        maxcode = MAXCODE(n_bits);\n\n        ClearCode = 1 << (init_bits - 1);\n        EOFCode = ClearCode + 1;\n        free_ent = ClearCode + 2;\n\n        a_count = 0; // clear packet\n\n        ent = nextPixel();\n\n        hshift = 0;\n        for (fcode = hsize; fcode < 65536; fcode *= 2) ++hshift;\n        hshift = 8 - hshift; // set hash code range bound\n\n        hsize_reg = hsize;\n        cl_hash(hsize_reg); // clear hash table\n\n        output(ClearCode, outs);\n\n        outer_loop: while ((c = nextPixel()) != EOF) {\n            fcode = (c << maxbits) + ent;\n            i = (c << hshift) ^ ent; // xor hashing\n\n            if (htab[i] == fcode) {\n                ent = codetab[i];\n                continue;\n            } else if (htab[i] >= 0) {\n                // non-empty slot\n\n                disp = hsize_reg - i; // secondary hash (after G. Knott)\n                if (i === 0) disp = 1;\n\n                do {\n                    if ((i -= disp) < 0) i += hsize_reg;\n\n                    if (htab[i] == fcode) {\n                        ent = codetab[i];\n                        continue outer_loop;\n                    }\n                } while (htab[i] >= 0);\n            }\n\n            output(ent, outs);\n            ent = c;\n            if (free_ent < maxmaxcode) {\n                codetab[i] = free_ent++; // code -> hashtable\n                htab[i] = fcode;\n            } else cl_block(outs);\n        }\n\n        // Put out the final code.\n        output(ent, outs);\n        output(EOFCode, outs);\n    });\n\n    // ----------------------------------------------------------------------------\n    var encode = (exports.encode = function encode(os) {\n        os.writeByte(initCodeSize); // write \"initial code size\" byte\n        remaining = imgW * imgH; // reset navigation variables\n        curPixel = 0;\n        compress(initCodeSize + 1, os); // compress and write the pixel data\n        os.writeByte(0); // write block terminator\n    });\n\n    // Flush the packet to disk, and reset the accumulator\n    var flush_char = function flush_char(outs) {\n        if (a_count > 0) {\n            outs.writeByte(a_count);\n            outs.writeBytes(accum, 0, a_count);\n            a_count = 0;\n        }\n    };\n\n    var MAXCODE = function MAXCODE(n_bits) {\n        return (1 << n_bits) - 1;\n    };\n\n    // ----------------------------------------------------------------------------\n    // Return the next pixel from the image\n    // ----------------------------------------------------------------------------\n\n    var nextPixel = function nextPixel() {\n        if (remaining === 0) return EOF;\n        --remaining;\n        var pix = pixAry[curPixel++];\n        return pix & 0xff;\n    };\n\n    var output = function output(code, outs) {\n        cur_accum &= masks[cur_bits];\n\n        if (cur_bits > 0) cur_accum |= code << cur_bits;\n        else cur_accum = code;\n\n        cur_bits += n_bits;\n\n        while (cur_bits >= 8) {\n            char_out(cur_accum & 0xff, outs);\n            cur_accum >>= 8;\n            cur_bits -= 8;\n        }\n\n        // If the next entry is going to be too big for the code size,\n        // then increase it, if possible.\n\n        if (free_ent > maxcode || clear_flg) {\n            if (clear_flg) {\n                maxcode = MAXCODE((n_bits = g_init_bits));\n                clear_flg = false;\n            } else {\n                ++n_bits;\n                if (n_bits == maxbits) maxcode = maxmaxcode;\n                else maxcode = MAXCODE(n_bits);\n            }\n        }\n\n        if (code == EOFCode) {\n            // At EOF, write the rest of the buffer.\n            while (cur_bits > 0) {\n                char_out(cur_accum & 0xff, outs);\n                cur_accum >>= 8;\n                cur_bits -= 8;\n            }\n\n            flush_char(outs);\n        }\n    };\n\n    LZWEncoder.apply(this, arguments);\n    return exports;\n};\n","/*\n * NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n\n/*\n * This class handles Neural-Net quantization algorithm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nexport const NeuQuant = function() {\n    var exports = {};\n    var netsize = 256; /* number of colours used */\n\n    /* four primes near 500 - assume no image has a length so large */\n    /* that it is divisible by all four primes */\n\n    var prime1 = 499;\n    var prime2 = 491;\n    var prime3 = 487;\n    var prime4 = 503;\n    var minpicturebytes = 3 * prime4; /* minimum size for input image */\n\n    /*\n     * Program Skeleton ---------------- [select samplefac in range 1..30] [read\n     * image from input file] pic = (unsigned char*) malloc(3*width*height);\n     * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\n     * image header, using writecolourmap(f)] inxbuild(); write output image using\n     * inxsearch(b,g,r)\n     */\n\n    /*\n     * Network Definitions -------------------\n     */\n\n    var maxnetpos = netsize - 1;\n    var netbiasshift = 4; /* bias for colour values */\n    var ncycles = 100; /* no. of learning cycles */\n\n    /* defs for freq and bias */\n    var intbiasshift = 16; /* bias for fractions */\n    var intbias = 1 << intbiasshift;\n    var gammashift = 10; /* gamma = 1024 */\n    var gamma = 1 << gammashift;\n    var betashift = 10;\n    var beta = intbias >> betashift; /* beta = 1/1024 */\n    var betagamma = intbias << (gammashift - betashift);\n\n    /* defs for decreasing radius factor */\n    var initrad = netsize >> 3; /* for 256 cols, radius starts */\n    var radiusbiasshift = 6; /* at 32.0 biased by 6 bits */\n    var radiusbias = 1 << radiusbiasshift;\n    var initradius = initrad * radiusbias; /* and decreases by a */\n    var radiusdec = 30; /* factor of 1/30 each cycle */\n\n    /* defs for decreasing alpha factor */\n    var alphabiasshift = 10; /* alpha starts at 1.0 */\n    var initalpha = 1 << alphabiasshift;\n    var alphadec; /* biased by 10 bits */\n\n    /* radbias and alpharadbias used for radpower calculation */\n    var radbiasshift = 8;\n    var radbias = 1 << radbiasshift;\n    var alpharadbshift = alphabiasshift + radbiasshift;\n    var alpharadbias = 1 << alpharadbshift;\n\n    /*\n     * Types and Global Variables --------------------------\n     */\n\n    var thepicture; /* the input image itself */\n    var lengthcount; /* lengthcount = H*W*3 */\n    var samplefac; /* sampling factor 1..30 */\n\n    // typedef int pixel[4]; /* BGRc */\n    var network; /* the network itself - [netsize][4] */\n    var netindex = [];\n\n    /* for network lookup - really 256 */\n    var bias = [];\n\n    /* bias and freq arrays for learning */\n    var freq = [];\n    var radpower = [];\n\n    var NeuQuant = (exports.NeuQuant = function NeuQuant(thepic, len, sample) {\n        var i;\n        var p;\n\n        thepicture = thepic;\n        lengthcount = len;\n        samplefac = sample;\n\n        network = new Array(netsize);\n\n        for (i = 0; i < netsize; i++) {\n            network[i] = new Array(4);\n            p = network[i];\n            p[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\n            freq[i] = intbias / netsize; /* 1/netsize */\n            bias[i] = 0;\n        }\n    });\n\n    var colorMap = function colorMap() {\n        var map = [];\n        var index = new Array(netsize);\n\n        for (var i = 0; i < netsize; i++) index[network[i][3]] = i;\n\n        var k = 0;\n        for (var l = 0; l < netsize; l++) {\n            var j = index[l];\n            map[k++] = network[j][0];\n            map[k++] = network[j][1];\n            map[k++] = network[j][2];\n        }\n\n        return map;\n    };\n\n    /*\n     * Insertion sort of network and building of netindex[0..255] (to do after\n     * unbias)\n     * -------------------------------------------------------------------------------\n     */\n\n    var inxbuild = function inxbuild() {\n        var i;\n        var j;\n        var smallpos;\n        var smallval;\n        var p;\n        var q;\n        var previouscol;\n        var startpos;\n\n        previouscol = 0;\n        startpos = 0;\n        for (i = 0; i < netsize; i++) {\n            p = network[i];\n            smallpos = i;\n            smallval = p[1]; /* index on g */\n\n            /* find smallest in i..netsize-1 */\n            for (j = i + 1; j < netsize; j++) {\n                q = network[j];\n                if (q[1] < smallval) {\n                    /* index on g */\n                    smallpos = j;\n                    smallval = q[1]; /* index on g */\n                }\n            }\n            q = network[smallpos];\n\n            /* swap p (i) and q (smallpos) entries */\n            if (i != smallpos) {\n                j = q[0];\n                q[0] = p[0];\n                p[0] = j;\n                j = q[1];\n                q[1] = p[1];\n                p[1] = j;\n                j = q[2];\n                q[2] = p[2];\n                p[2] = j;\n                j = q[3];\n                q[3] = p[3];\n                p[3] = j;\n            }\n\n            /* smallval entry is now in position i */\n\n            if (smallval != previouscol) {\n                netindex[previouscol] = (startpos + i) >> 1;\n\n                for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n\n                previouscol = smallval;\n                startpos = i;\n            }\n        }\n\n        netindex[previouscol] = (startpos + maxnetpos) >> 1;\n        for (j = previouscol + 1; j < 256; j++)\n            netindex[j] = maxnetpos; /* really 256 */\n    };\n\n    /*\n     * Main Learning Loop ------------------\n     */\n\n    var learn = function learn() {\n        var i;\n        var j;\n        var b;\n        var g;\n        var r;\n        var radius;\n        var rad;\n        var alpha;\n        var step;\n        var delta;\n        var samplepixels;\n        var p;\n        var pix;\n        var lim;\n\n        if (lengthcount < minpicturebytes) samplefac = 1;\n\n        alphadec = 30 + (samplefac - 1) / 3;\n        p = thepicture;\n        pix = 0;\n        lim = lengthcount;\n        samplepixels = lengthcount / (3 * samplefac);\n        delta = (samplepixels / ncycles) | 0;\n        alpha = initalpha;\n        radius = initradius;\n\n        rad = radius >> radiusbiasshift;\n        if (rad <= 1) rad = 0;\n\n        for (i = 0; i < rad; i++)\n            radpower[i] =\n                alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n\n        if (lengthcount < minpicturebytes) step = 3;\n        else if (lengthcount % prime1 !== 0) step = 3 * prime1;\n        else {\n            if (lengthcount % prime2 !== 0) step = 3 * prime2;\n            else {\n                if (lengthcount % prime3 !== 0) step = 3 * prime3;\n                else step = 3 * prime4;\n            }\n        }\n\n        i = 0;\n        while (i < samplepixels) {\n            b = (p[pix + 0] & 0xff) << netbiasshift;\n            g = (p[pix + 1] & 0xff) << netbiasshift;\n            r = (p[pix + 2] & 0xff) << netbiasshift;\n            j = contest(b, g, r);\n\n            altersingle(alpha, j, b, g, r);\n            if (rad !== 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\n\n            pix += step;\n            if (pix >= lim) pix -= lengthcount;\n\n            i++;\n\n            if (delta === 0) delta = 1;\n\n            if (i % delta === 0) {\n                alpha -= alpha / alphadec;\n                radius -= radius / radiusdec;\n                rad = radius >> radiusbiasshift;\n\n                if (rad <= 1) rad = 0;\n\n                for (j = 0; j < rad; j++)\n                    radpower[j] =\n                        alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n            }\n        }\n    };\n\n    /*\n     ** Search for BGR values 0..255 (after net is unbiased) and return colour\n     * index\n     * ----------------------------------------------------------------------------\n     */\n\n    var map = (exports.map = function map(b, g, r) {\n        var i;\n        var j;\n        var dist;\n        var a;\n        var bestd;\n        var p;\n        var best;\n\n        bestd = 1000; /* biggest possible dist is 256*3 */\n        best = -1;\n        i = netindex[g]; /* index on g */\n        j = i - 1; /* start at netindex[g] and work outwards */\n\n        while (i < netsize || j >= 0) {\n            if (i < netsize) {\n                p = network[i];\n                dist = p[1] - g; /* inx key */\n\n                if (dist >= bestd) i = netsize;\n                /* stop iter */ else {\n                    i++;\n                    if (dist < 0) dist = -dist;\n                    a = p[0] - b;\n                    if (a < 0) a = -a;\n                    dist += a;\n\n                    if (dist < bestd) {\n                        a = p[2] - r;\n                        if (a < 0) a = -a;\n                        dist += a;\n\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n                }\n            }\n\n            if (j >= 0) {\n                p = network[j];\n                dist = g - p[1]; /* inx key - reverse dif */\n\n                if (dist >= bestd) j = -1;\n                /* stop iter */ else {\n                    j--;\n                    if (dist < 0) dist = -dist;\n                    a = p[0] - b;\n                    if (a < 0) a = -a;\n                    dist += a;\n\n                    if (dist < bestd) {\n                        a = p[2] - r;\n                        if (a < 0) a = -a;\n                        dist += a;\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n                }\n            }\n        }\n\n        return best;\n    });\n\n    var process = (exports.process = function process() {\n        learn();\n        unbiasnet();\n        inxbuild();\n        return colorMap();\n    });\n\n    /*\n     * Unbias network to give byte values 0..255 and record position i to prepare\n     * for sort\n     * -----------------------------------------------------------------------------------\n     */\n\n    var unbiasnet = function unbiasnet() {\n        var i;\n        var j;\n\n        for (i = 0; i < netsize; i++) {\n            network[i][0] >>= netbiasshift;\n            network[i][1] >>= netbiasshift;\n            network[i][2] >>= netbiasshift;\n            network[i][3] = i; /* record colour no */\n        }\n    };\n\n    /*\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\n     * radpower[|i-j|]\n     * ---------------------------------------------------------------------------------\n     */\n\n    var alterneigh = function alterneigh(rad, i, b, g, r) {\n        var j;\n        var k;\n        var lo;\n        var hi;\n        var a;\n        var m;\n        var p;\n\n        lo = i - rad;\n        if (lo < -1) lo = -1;\n\n        hi = i + rad;\n        if (hi > netsize) hi = netsize;\n\n        j = i + 1;\n        k = i - 1;\n        m = 1;\n\n        while (j < hi || k > lo) {\n            a = radpower[m++];\n\n            if (j < hi) {\n                p = network[j++];\n\n                try {\n                    p[0] -= (a * (p[0] - b)) / alpharadbias;\n                    p[1] -= (a * (p[1] - g)) / alpharadbias;\n                    p[2] -= (a * (p[2] - r)) / alpharadbias;\n                } catch (e) {} // prevents 1.3 miscompilation\n            }\n\n            if (k > lo) {\n                p = network[k--];\n\n                try {\n                    p[0] -= (a * (p[0] - b)) / alpharadbias;\n                    p[1] -= (a * (p[1] - g)) / alpharadbias;\n                    p[2] -= (a * (p[2] - r)) / alpharadbias;\n                } catch (e) {}\n            }\n        }\n    };\n\n    /*\n     * Move neuron i towards biased (b,g,r) by factor alpha\n     * ----------------------------------------------------\n     */\n\n    var altersingle = function altersingle(alpha, i, b, g, r) {\n        /* alter hit neuron */\n        var n = network[i];\n        n[0] -= (alpha * (n[0] - b)) / initalpha;\n        n[1] -= (alpha * (n[1] - g)) / initalpha;\n        n[2] -= (alpha * (n[2] - r)) / initalpha;\n    };\n\n    /*\n     * Search for biased BGR values ----------------------------\n     */\n\n    var contest = function contest(b, g, r) {\n        /* finds closest neuron (min dist) and updates freq */\n        /* finds best neuron (min dist-bias) and returns position */\n        /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\n        /* bias[i] = gamma*((1/netsize)-freq[i]) */\n\n        var i;\n        var dist;\n        var a;\n        var biasdist;\n        var betafreq;\n        var bestpos;\n        var bestbiaspos;\n        var bestd;\n        var bestbiasd;\n        var n;\n\n        bestd = ~(1 << 31);\n        bestbiasd = bestd;\n        bestpos = -1;\n        bestbiaspos = bestpos;\n\n        for (i = 0; i < netsize; i++) {\n            n = network[i];\n            dist = n[0] - b;\n            if (dist < 0) dist = -dist;\n            a = n[1] - g;\n            if (a < 0) a = -a;\n            dist += a;\n            a = n[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n                bestd = dist;\n                bestpos = i;\n            }\n\n            biasdist = dist - (bias[i] >> (intbiasshift - netbiasshift));\n\n            if (biasdist < bestbiasd) {\n                bestbiasd = biasdist;\n                bestbiaspos = i;\n            }\n\n            betafreq = freq[i] >> betashift;\n            freq[i] -= betafreq;\n            bias[i] += betafreq << gammashift;\n        }\n\n        freq[bestpos] += beta;\n        bias[bestpos] -= betagamma;\n        return bestbiaspos;\n    };\n\n    NeuQuant.apply(this, arguments);\n    return exports;\n};\n","/**\n * This class lets you encode animated GIF files\n * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nimport { LZWEncoder } from \"./LZWEncoder\";\nimport { NeuQuant } from \"./NeuQuant\";\n\nexport const GIFEncoder = function() {\n    for (var i = 0, chr = {}; i < 256; i++) chr[i] = String.fromCharCode(i);\n\n    function ByteArray() {\n        this.bin = [];\n    }\n\n    ByteArray.prototype.getData = function() {\n        for (var v = \"\", l = this.bin.length, i = 0; i < l; i++)\n            v += chr[this.bin[i]];\n        return v;\n    };\n\n    ByteArray.prototype.writeByte = function(val) {\n        this.bin.push(val);\n    };\n\n    ByteArray.prototype.writeUTFBytes = function(string) {\n        for (var l = string.length, i = 0; i < l; i++)\n            this.writeByte(string.charCodeAt(i));\n    };\n\n    ByteArray.prototype.writeBytes = function(array, offset, length) {\n        for (var l = length || array.length, i = offset || 0; i < l; i++)\n            this.writeByte(array[i]);\n    };\n\n    var exports = {};\n    var width; // image size\n    var height;\n    var transparent = null; // transparent color if given\n    var transIndex; // transparent index in color table\n    var repeat = -1; // no repeat\n    var delay = 0; // frame delay (hundredths)\n    var started = false; // ready to output frames\n    var out;\n    var image; // current frame\n    var pixels; // BGR byte array from frame\n    var indexedPixels; // converted frame indexed to palette\n    var colorDepth; // number of bit planes\n    var colorTab; // RGB palette\n    var usedEntry = []; // active palette entries\n    var palSize = 7; // color table size (bits-1)\n    var dispose = -1; // disposal code (-1 = use default)\n    var closeStream = false; // close stream when finished\n    var firstFrame = true;\n    var sizeSet = false; // if false, get size from first frame\n    var sample = 10; // default sample interval for quantizer\n    var comment = \"Generated by jsgif (https://github.com/antimatter15/jsgif/)\"; // default comment for generated gif\n\n    /**\n     * Sets the delay time between each frame, or changes it for subsequent frames\n     * (applies to last frame added)\n     * int delay time in milliseconds\n     * @param ms\n     */\n\n    var setDelay = (exports.setDelay = function setDelay(ms) {\n        delay = Math.round(ms / 10);\n    });\n\n    /**\n     * Sets the GIF frame disposal code for the last added frame and any\n     *\n     * subsequent frames. Default is 0 if no transparent color has been set,\n     * otherwise 2.\n     * @param code\n     * int disposal code.\n     */\n\n    var setDispose = (exports.setDispose = function setDispose(code) {\n        if (code >= 0) dispose = code;\n    });\n\n    /**\n     * Sets the number of times the set of GIF frames should be played. Default is\n     * 1; 0 means play indefinitely. Must be invoked before the first image is\n     * added.\n     *\n     * @param iter\n     * int number of iterations.\n     * @return\n     */\n\n    var setRepeat = (exports.setRepeat = function setRepeat(iter) {\n        if (iter >= 0) repeat = iter;\n    });\n\n    /**\n     * Sets the transparent color for the last added frame and any subsequent\n     * frames. Since all colors are subject to modification in the quantization\n     * process, the color in the final palette for each frame closest to the given\n     * color becomes the transparent color for that frame. May be set to null to\n     * indicate no transparent color.\n     * @param\n     * Color to be treated as transparent on display.\n     */\n\n    var setTransparent = (exports.setTransparent = function setTransparent(c) {\n        transparent = c;\n    });\n\n    /**\n     * Sets the comment for the block comment\n     * @param\n     * string to be insterted as comment\n     */\n\n    var setComment = (exports.setComment = function setComment(c) {\n        comment = c;\n    });\n\n    /**\n     * The addFrame method takes an incoming BitmapData object to create each frames\n     * @param\n     * BitmapData object to be treated as a GIF's frame\n     */\n\n    var addFrame = (exports.addFrame = function addFrame(im, is_imageData) {\n        if (im === null || !started || out === null) {\n            throw new Error(\"Please call start method before calling addFrame\");\n        }\n\n        var ok = true;\n\n        try {\n            if (!is_imageData) {\n                image = im.getImageData(0, 0, im.canvas.width, im.canvas.height)\n                    .data;\n                if (!sizeSet) setSize(im.canvas.width, im.canvas.height);\n            } else {\n                if (im instanceof ImageData) {\n                    image = im.data;\n                    if (!sizeSet || width != im.width || height != im.height) {\n                        setSize(im.width, im.height);\n                    } else {\n                    }\n                } else if (im instanceof Uint8ClampedArray) {\n                    if (im.length == width * height * 4) {\n                        image = im;\n                    } else {\n                        console.log(\n                            \"Please set the correct size: ImageData length mismatch\"\n                        );\n                        ok = false;\n                    }\n                } else {\n                    console.log(\"Please provide correct input\");\n                    ok = false;\n                }\n            }\n            getImagePixels(); // convert to correct format if necessary\n            analyzePixels(); // build color table & map pixels\n\n            if (firstFrame) {\n                writeLSD(); // logical screen descriptior\n                writePalette(); // global color table\n                if (repeat >= 0) {\n                    // use NS app extension to indicate reps\n                    writeNetscapeExt();\n                }\n            }\n\n            writeGraphicCtrlExt(); // write graphic control extension\n            if (comment !== \"\") {\n                writeCommentExt(); // write comment extension\n            }\n            writeImageDesc(); // image descriptor\n            if (!firstFrame) writePalette(); // local color table\n            writePixels(); // encode and write pixel data\n            firstFrame = false;\n        } catch (e) {\n            ok = false;\n        }\n\n        return ok;\n    });\n\n    /**\n     * @description: Downloads the encoded gif with the given name\n     * No need of any conversion from the stream data (out) to base64\n     * Solves the issue of large file sizes when there are more frames\n     * and does not involve in creation of any temporary data in the process\n     * so no wastage of memory, and speeds up the process of downloading\n     * to just calling this function.\n     * @parameter {String} filename filename used for downloading the gif\n     */\n\n    var download = (exports.download = function download(filename) {\n        if (out === null || closeStream == false) {\n            console.log(\n                \"Please call start method and add frames and call finish method before calling download\"\n            );\n        } else {\n            filename =\n                filename !== undefined\n                    ? filename.endsWith(\".gif\")\n                        ? filename\n                        : filename + \".gif\"\n                    : \"download.gif\";\n            var templink = document.createElement(\"a\");\n            templink.download = filename;\n            templink.href = URL.createObjectURL(\n                new Blob([new Uint8Array(out.bin)], { type: \"image/gif\" })\n            );\n            templink.click();\n        }\n    });\n\n    /**\n     * Adds final trailer to the GIF stream, if you don't call the finish method\n     * the GIF stream will not be valid.\n     */\n\n    var finish = (exports.finish = function finish() {\n        if (!started) return false;\n\n        var ok = true;\n        started = false;\n\n        try {\n            out.writeByte(0x3b); // gif trailer\n            closeStream = true;\n        } catch (e) {\n            ok = false;\n        }\n\n        return ok;\n    });\n\n    /**\n     * Resets some members so that a new stream can be started.\n     * This method is actually called by the start method\n     */\n\n    var reset = function reset() {\n        // reset for subsequent use\n        transIndex = 0;\n        image = null;\n        pixels = null;\n        indexedPixels = null;\n        colorTab = null;\n        closeStream = false;\n        firstFrame = true;\n    };\n\n    /**\n     * * Sets frame rate in frames per second. Equivalent to\n     * <code>setDelay(1000/fps)</code>.\n     * @param fps\n     * float frame rate (frames per second)\n     */\n\n    var setFrameRate = (exports.setFrameRate = function setFrameRate(fps) {\n        if (fps != 0xf) delay = Math.round(100 / fps);\n    });\n\n    /**\n     * Sets quality of color quantization (conversion of images to the maximum 256\n     * colors allowed by the GIF specification). Lower values (minimum = 1)\n     * produce better colors, but slow processing significantly. 10 is the\n     * default, and produces good color mapping at reasonable speeds. Values\n     * greater than 20 do not yield significant improvements in speed.\n     * @param quality\n     * int greater than 0.\n     * @return\n     */\n\n    var setQuality = (exports.setQuality = function setQuality(quality) {\n        if (quality < 1) quality = 1;\n        sample = quality;\n    });\n\n    /**\n     * Sets the GIF frame size. The default size is the size of the first frame\n     * added if this method is not invoked.\n     * @param w\n     * int frame width.\n     * @param h\n     * int frame width.\n     */\n\n    var setSize = (exports.setSize = function setSize(w, h) {\n        if (started && !firstFrame) return;\n        width = w;\n        height = h;\n        if (width < 1) width = 320;\n        if (height < 1) height = 240;\n        sizeSet = true;\n    });\n\n    /**\n     * Initiates GIF file creation on the given stream.\n     * @param os\n     * OutputStream on which GIF images are written.\n     * @return false if initial write failed.\n     */\n\n    var start = (exports.start = function start() {\n        reset();\n        var ok = true;\n        closeStream = false;\n        out = new ByteArray();\n        try {\n            out.writeUTFBytes(\"GIF89a\"); // header\n        } catch (e) {\n            ok = false;\n        }\n\n        return (started = ok);\n    });\n\n    var cont = (exports.cont = function cont() {\n        reset();\n        var ok = true;\n        closeStream = false;\n        out = new ByteArray();\n\n        return (started = ok);\n    });\n\n    /**\n     * Analyzes image colors and creates color map.\n     */\n\n    var analyzePixels = function analyzePixels() {\n        var len = pixels.length;\n        var nPix = len / 3;\n        indexedPixels = [];\n        var nq = new NeuQuant(pixels, len, sample);\n\n        // initialize quantizer\n        colorTab = nq.process(); // create reduced palette\n\n        // map image pixels to new palette\n        var k = 0;\n        for (var j = 0; j < nPix; j++) {\n            var index = nq.map(\n                pixels[k++] & 0xff,\n                pixels[k++] & 0xff,\n                pixels[k++] & 0xff\n            );\n            usedEntry[index] = true;\n            indexedPixels[j] = index;\n        }\n\n        pixels = null;\n        colorDepth = 8;\n        palSize = 7;\n\n        // get closest match to transparent color if specified\n        if (transparent !== null) {\n            transIndex = findClosest(transparent);\n        }\n    };\n\n    /**\n     * Returns index of palette color closest to c\n     */\n\n    var findClosest = function findClosest(c) {\n        if (colorTab === null) return -1;\n        var r = (c & 0xff0000) >> 16;\n        var g = (c & 0x00ff00) >> 8;\n        var b = c & 0x0000ff;\n        var minpos = 0;\n        var dmin = 256 * 256 * 256;\n        var len = colorTab.length;\n\n        for (var i = 0; i < len; ) {\n            var dr = r - (colorTab[i++] & 0xff);\n            var dg = g - (colorTab[i++] & 0xff);\n            var db = b - (colorTab[i] & 0xff);\n            var d = dr * dr + dg * dg + db * db;\n            var index = i / 3;\n            if (usedEntry[index] && d < dmin) {\n                dmin = d;\n                minpos = index;\n            }\n            i++;\n        }\n        return minpos;\n    };\n\n    /**\n     * Extracts image pixels into byte array \"pixels\n     */\n\n    var getImagePixels = function getImagePixels() {\n        var w = width;\n        var h = height;\n        pixels = [];\n        var data = image;\n        var count = 0;\n\n        for (var i = 0; i < h; i++) {\n            for (var j = 0; j < w; j++) {\n                var b = i * w * 4 + j * 4;\n                pixels[count++] = data[b];\n                pixels[count++] = data[b + 1];\n                pixels[count++] = data[b + 2];\n            }\n        }\n    };\n\n    /**\n     * Writes Graphic Control Extension\n     */\n\n    var writeGraphicCtrlExt = function writeGraphicCtrlExt() {\n        out.writeByte(0x21); // extension introducer\n        out.writeByte(0xf9); // GCE label\n        out.writeByte(4); // data block size\n        var transp;\n        var disp;\n        if (transparent === null) {\n            transp = 0;\n            disp = 0; // dispose = no action\n        } else {\n            transp = 1;\n            disp = 2; // force clear if using transparent color\n        }\n        if (dispose >= 0) {\n            disp = dispose & 7; // user override\n        }\n        disp <<= 2;\n        // packed fields\n        out.writeByte(\n            0 | // 1:3 reserved\n            disp | // 4:6 disposal\n            0 | // 7 user input - 0 = none\n                transp\n        ); // 8 transparency flag\n\n        WriteShort(delay); // delay x 1/100 sec\n        out.writeByte(transIndex); // transparent color index\n        out.writeByte(0); // block terminator\n    };\n\n    /**\n     * Writes Comment Extention\n     */\n\n    var writeCommentExt = function writeCommentExt() {\n        out.writeByte(0x21); // extension introducer\n        out.writeByte(0xfe); // comment label\n        out.writeByte(comment.length); // Block Size (s)\n        out.writeUTFBytes(comment);\n        out.writeByte(0); // block terminator\n    };\n\n    /**\n     * Writes Image Descriptor\n     */\n\n    var writeImageDesc = function writeImageDesc() {\n        out.writeByte(0x2c); // image separator\n        WriteShort(0); // image position x,y = 0,0\n        WriteShort(0);\n        WriteShort(width); // image size\n        WriteShort(height);\n\n        // packed fields\n        if (firstFrame) {\n            // no LCT - GCT is used for first (or only) frame\n            out.writeByte(0);\n        } else {\n            // specify normal LCT\n            out.writeByte(\n                0x80 | // 1 local color table 1=yes\n                0 | // 2 interlace - 0=no\n                0 | // 3 sorted - 0=no\n                0 | // 4-5 reserved\n                    palSize\n            ); // 6-8 size of color table\n        }\n    };\n\n    /**\n     * Writes Logical Screen Descriptor\n     */\n\n    var writeLSD = function writeLSD() {\n        // logical screen size\n        WriteShort(width);\n        WriteShort(height);\n        // packed fields\n        out.writeByte(\n            0x80 | // 1 : global color table flag = 1 (gct used)\n            0x70 | // 2-4 : color resolution = 7\n            0x00 | // 5 : gct sort flag = 0\n                palSize\n        ); // 6-8 : gct size\n\n        out.writeByte(0); // background color index\n        out.writeByte(0); // pixel aspect ratio - assume 1:1\n    };\n\n    /**\n     * Writes Netscape application extension to define repeat count.\n     */\n\n    var writeNetscapeExt = function writeNetscapeExt() {\n        out.writeByte(0x21); // extension introducer\n        out.writeByte(0xff); // app extension label\n        out.writeByte(11); // block size\n        out.writeUTFBytes(\"NETSCAPE\" + \"2.0\"); // app id + auth code\n        out.writeByte(3); // sub-block size\n        out.writeByte(1); // loop sub-block id\n        WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\n        out.writeByte(0); // block terminator\n    };\n\n    /**\n     * Writes color table\n     */\n\n    var writePalette = function writePalette() {\n        out.writeBytes(colorTab);\n        var n = 3 * 256 - colorTab.length;\n        for (var i = 0; i < n; i++) out.writeByte(0);\n    };\n\n    var WriteShort = function WriteShort(pValue) {\n        out.writeByte(pValue & 0xff);\n        out.writeByte((pValue >> 8) & 0xff);\n    };\n\n    /**\n     * Encodes and writes pixel data\n     */\n\n    var writePixels = function writePixels() {\n        var myencoder = new LZWEncoder(\n            width,\n            height,\n            indexedPixels,\n            colorDepth\n        );\n        myencoder.encode(out);\n    };\n\n    /**\n     * Retrieves the GIF stream\n     */\n\n    var stream = (exports.stream = function stream() {\n        return out;\n    });\n\n    var setProperties = (exports.setProperties = function setProperties(\n        has_start,\n        is_first\n    ) {\n        started = has_start;\n        firstFrame = is_first;\n    });\n\n    return exports;\n};\n","import { Crop, Layer, ExtractedSprite, ExtractedTile } from \"./types\";\nimport { renderTileToCanvas } from \"./renderTileToCanvas\";\nimport { getMaxX, getMaxY, getAllSpritesFromLayers } from \"./spriteUtil\";\n\nfunction getDimensions(\n    sprites: ExtractedSprite[]\n): { width: number; height: number } {\n    const maxX = getMaxX(sprites) + 16;\n    const maxY = getMaxY(sprites) + 16;\n\n    return {\n        width: maxX,\n        height: maxY\n    };\n}\n\nfunction flip(\n    canvas: HTMLCanvasElement,\n    tile: ExtractedTile\n): HTMLCanvasElement {\n    const xScale = tile.horizontalFlip ? -1 : 1;\n    const yScale = tile.verticalFlip ? -1 : 1;\n    const translateX = tile.horizontalFlip ? canvas.width : 0;\n    const translateY = tile.verticalFlip ? canvas.height : 0;\n\n    const newCanvas = document.createElement(\"canvas\");\n    newCanvas.width = canvas.width;\n    newCanvas.height = canvas.height;\n\n    const context = newCanvas.getContext(\"2d\");\n\n    if (context) {\n        context.save();\n        context.translate(translateX, translateY);\n        context.scale(xScale, yScale);\n\n        context.drawImage(canvas, 0, 0);\n        context.restore();\n    }\n\n    return newCanvas;\n}\n\nfunction cropCanvas(\n    fullCanvas: HTMLCanvasElement,\n    crop: Crop\n): HTMLCanvasElement {\n    const cropWidth = crop[1].x - crop[0].x;\n    const cropHeight = crop[1].y - crop[0].y;\n\n    const croppedCanvas = document.createElement(\"canvas\");\n    croppedCanvas.width = cropWidth;\n    croppedCanvas.height = cropHeight;\n\n    const croppedCanvasContext = croppedCanvas.getContext(\"2d\")!;\n\n    croppedCanvasContext.drawImage(\n        fullCanvas,\n        crop[0].x,\n        crop[0].y,\n        cropWidth,\n        cropHeight,\n        0,\n        0,\n        cropWidth,\n        cropHeight\n    );\n\n    return croppedCanvas;\n}\n\n// TODO: account for when sprites didn't compose right up to (0,0)\nexport function layersToCanvas(\n    layers: Layer[],\n    animationCounter = 0,\n    crop?: Crop\n): HTMLCanvasElement {\n    const sprites = getAllSpritesFromLayers(layers);\n    const dimensions = getDimensions(sprites);\n\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = dimensions.width;\n    canvas.height = dimensions.height;\n\n    const context = canvas.getContext(\"2d\");\n\n    layers.forEach(layer => {\n        const layerSprites = getAllSpritesFromLayers([layer]);\n        const sortedSprites = [...layerSprites].sort(\n            (a, b) => a.spriteMemoryIndex - b.spriteMemoryIndex\n        );\n\n        sortedSprites.forEach(sprite => {\n            sprite.tiles.forEach(tile => {\n                let tileCanvas = document.createElement(\"canvas\");\n\n                let tileIndex = tile.tileIndex;\n\n                if (tile.autoAnimation === 3) {\n                    // 3 bit auto animation: the 4th bit is set, indicating this tile does 3bit auto animation\n                    // that means take its tileIndex, and replace its bottom three bits with those of the animation counter\n                    tileIndex =\n                        (tileIndex & ~7) + ((tileIndex + animationCounter) & 7);\n                }\n                if (tile.autoAnimation === 2) {\n                    // 2 bit auto animation: like above but replace its bottom two bits\n                    tileIndex =\n                        (tileIndex & ~3) + ((tileIndex + animationCounter) & 3);\n                }\n\n                renderTileToCanvas(tileCanvas, tileIndex, tile.rgbPalette);\n\n                if (tile.horizontalFlip || tile.verticalFlip) {\n                    tileCanvas = flip(tileCanvas, tile);\n                }\n\n                context!.drawImage(\n                    tileCanvas,\n                    sprite.composedX,\n                    tile.composedY\n                );\n            });\n        });\n    });\n\n    if (crop) {\n        return cropCanvas(canvas, crop);\n    } else {\n        return canvas;\n    }\n}\n","import { Crop, Layer, ExtractedTile } from \"./types\";\n// @ts-ignore\nimport { GIFEncoder } from \"./jsgif/GIFEncoder\";\nimport { layersToCanvas } from \"./layersToCanvas\";\nimport { getAllTilesFromLayers } from \"./spriteUtil\";\n\n// loop set to zero means forever\nconst FOREVER = 0;\n\nfunction determineNumberOfFramesToRender(\n    layers: Layer[],\n    crop: Crop | undefined\n): number {\n    // const tiles = getAllTilesFromLayers(layers);\n\n    let validTiles;\n\n    if (!crop) {\n        validTiles = getAllTilesFromLayers(layers);\n    } else {\n        validTiles = layers.reduce<ExtractedTile[]>((ts, layer) => {\n            const validLayerTiles = layer.groups.reduce<ExtractedTile[]>(\n                (lts, group) => {\n                    const validSpriteTiles = group.sprites.reduce<\n                        ExtractedTile[]\n                    >((sts, sprite) => {\n                        if (\n                            sprite.composedX < crop[0].x ||\n                            sprite.composedX > crop[1].x\n                        ) {\n                            return sts;\n                        }\n\n                        const validTilesForSprite = sprite.tiles.filter(\n                            tile => {\n                                return (\n                                    tile.composedY >= crop[0].y &&\n                                    tile.composedY < crop[1].y\n                                );\n                            }\n                        );\n\n                        return sts.concat(validTilesForSprite);\n                    }, []);\n\n                    return lts.concat(validSpriteTiles);\n                },\n                []\n            );\n\n            return ts.concat(validLayerTiles);\n        }, []);\n    }\n\n    const maxAnimation = Math.max(...validTiles.map(t => t.autoAnimation));\n\n    // 2 raised to maxAnimation\n    return 2 ** maxAnimation;\n}\n\nexport function createGif(\n    layers: Layer[],\n    crop: Crop | undefined,\n    delay: number,\n    onFrame: (\n        canvas: HTMLCanvasElement,\n        frameNumber: number,\n        totalFrames: number\n    ) => void,\n    onFinish: (dataUrl: string) => void\n): void {\n    // @ts-ignore\n    const encoder: any = new GIFEncoder();\n    encoder.setRepeat(FOREVER);\n    encoder.setDelay(delay);\n    encoder.setQuality(1);\n\n    encoder.start();\n\n    const totalFrames = determineNumberOfFramesToRender(layers, crop);\n    console.log(\"totalFrames\", totalFrames);\n\n    let remainingFrames = totalFrames;\n\n    const finish = () => {\n        encoder.finish();\n\n        const binaryData = encoder.stream().getData();\n\n        onFinish(`data:image/gif;base64,${btoa(binaryData)}`);\n    };\n\n    const addFrame = () => {\n        const animationCounter = totalFrames - remainingFrames;\n\n        const frameCanvas = layersToCanvas(layers, animationCounter, crop);\n        encoder.addFrame(frameCanvas.getContext(\"2d\")!);\n\n        --remainingFrames;\n\n        onFrame(frameCanvas, animationCounter, totalFrames);\n\n        if (remainingFrames) {\n            setTimeout(addFrame, 1);\n        } else {\n            setTimeout(finish, 1);\n        }\n    };\n\n    addFrame();\n}\n","import React, { useEffect, useRef, useState } from \"react\";\nimport Modal from \"react-modal\";\nimport { createGif } from \"../state/createGif\";\nimport { useAppState } from \"../state\";\n\ntype FrameStatus = { frame: number; totalFrames: number };\n\nfunction clear(div: HTMLDivElement) {\n    while (div.firstChild) {\n        div.removeChild(div.firstChild);\n    }\n}\n\ninterface BuildGifModalProps {\n    isOpen: boolean;\n    onRequestClose: () => void;\n}\n\nexport const BuildGifModal: React.FunctionComponent<BuildGifModalProps> = ({\n    isOpen,\n    onRequestClose\n}) => {\n    const { state } = useAppState();\n    const containerRef = useRef<null | HTMLDivElement>(null);\n    const [frameStatus, setFrameStatus] = useState<null | FrameStatus>(null);\n\n    useEffect(() => {\n        if (isOpen) {\n            const delay = window.Module._get_neogeo_frame_counter_speed() * 16;\n\n            createGif(\n                state.layers,\n                state.crop,\n                delay,\n                (\n                    canvas: HTMLCanvasElement,\n                    frame: number,\n                    totalFrames: number\n                ) => {\n                    setFrameStatus({ frame, totalFrames });\n\n                    if (containerRef && containerRef.current) {\n                        clear(containerRef.current);\n                        containerRef.current.appendChild(canvas);\n                    }\n                },\n                (dataUrl: string) => {\n                    setFrameStatus(null);\n\n                    if (containerRef && containerRef.current) {\n                        clear(containerRef.current);\n                        const img = new Image();\n                        img.src = dataUrl;\n                        containerRef.current.appendChild(img);\n                    }\n                }\n            );\n        }\n    }, [isOpen, state.crop, state.layers]);\n\n    return (\n        <Modal isOpen={isOpen} onRequestClose={onRequestClose}>\n            {frameStatus && (\n                <div>\n                    {frameStatus.frame} of {frameStatus.totalFrames}\n                </div>\n            )}\n            <div ref={containerRef} />\n        </Modal>\n    );\n};\n","import React from \"react\";\nimport {\n    Layer as LayerData,\n    ExtractedSprite as ExtractedSpriteData\n} from \"../state/types\";\nimport { ExtractedSprite as ExtractedSpriteCmp } from \"./extractedSprite\";\nimport { getMaxX, getMaxY, getAllSpritesFromLayers } from \"../state/spriteUtil\";\nimport { useAppState } from \"../state\";\n\nimport styles from \"./layer.module.css\";\n\ninterface LayerProps {\n    layer: LayerData;\n    index: number;\n    runPreview: boolean;\n    animationCounter: number;\n    canDrag: boolean;\n    outlineTiles: boolean;\n}\n\nexport const Layer: React.FunctionComponent<LayerProps> = ({\n    layer,\n    index,\n    runPreview,\n    animationCounter,\n    canDrag,\n    outlineTiles\n}) => {\n    const { state } = useAppState();\n\n    if (state.hiddenLayers[layer.id]) {\n        return null;\n    }\n\n    const sprites = layer.groups.reduce<ExtractedSpriteData[]>((s, g) => {\n        if (state.hiddenGroups[g.id]) {\n            return s;\n        } else {\n            return s.concat(g.sprites);\n        }\n    }, []);\n\n    const spriteCmps = sprites.map((extractedSprite, i) => (\n        <ExtractedSpriteCmp\n            key={i}\n            data={extractedSprite}\n            autoAnimate={runPreview}\n            animationCounter={animationCounter}\n            canDrag={canDrag}\n            outlineTiles={outlineTiles}\n        />\n    ));\n\n    const extractedSprites = getAllSpritesFromLayers([layer]);\n    const maxX = getMaxX(extractedSprites);\n    const width = Math.max(maxX + 48, 320);\n\n    const maxY = getMaxY(extractedSprites);\n    const height = Math.max(maxY + 48, 240);\n\n    const style = {\n        zIndex: index,\n        width,\n        height\n    };\n\n    return (\n        <div className={styles.root} style={style}>\n            {spriteCmps}\n        </div>\n    );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { Crop } from \"../state/types\";\n\nimport styles from \"./cropRect.module.css\";\n\ninterface CropRectProps {\n    className?: string;\n    crop: Crop;\n    width?: number | null;\n    height?: number | null;\n}\n\nexport const CropRect: React.FunctionComponent<CropRectProps> = ({\n    className,\n    crop,\n    width,\n    height\n}) => {\n    const classes = classnames(styles.root, className);\n\n    const topRowStyle = {\n        height: crop[0].y,\n        gridColumn: \"1 / -1\",\n        gridRow: \"1\"\n    };\n\n    const leftCellStyle = {\n        width: crop[0].x,\n        height: crop[1].y - crop[0].y,\n        gridColumn: \"1\",\n        gridRow: \"2\"\n    };\n\n    const rightCellStyle = {\n        gridColumn: \"3\",\n        gridRow: \"2\"\n    };\n\n    const cropStyle = {\n        width: crop[1].x - crop[0].x,\n        height: crop[1].y - crop[0].y,\n        gridColumn: \"2\",\n        gridRow: \"2\"\n    };\n\n    const bottomRowStyle = {\n        gridColumn: \"1 / -1\",\n        gridRow: \"3\",\n        flex: \"1\"\n    };\n\n    const containerStyle = {\n        width: width || \"100%\",\n        height: height || \"100%\"\n    };\n\n    return (\n        <div className={classes} style={containerStyle}>\n            <div className={styles.mask} style={topRowStyle} />\n            <div className={styles.mask} style={leftCellStyle} />\n            <div className={styles.crop} style={cropStyle} />\n            <div className={styles.mask} style={rightCellStyle} />\n            <div className={styles.mask} style={bottomRowStyle} />\n        </div>\n    );\n};\n","import React, { useState, useEffect } from \"react\";\nimport styled from \"styled-components\";\nimport { useDrop } from \"react-dnd\";\nimport {\n  getBackdropNeoGeoColor,\n  neoGeoColorToCSS\n} from \"../palette/neoGeoPalette\";\nimport { useAppState } from \"../state\";\nimport { BuildGifModal } from \"../gifBuilder/buildGifModal\";\nimport { Layer as LayerCmp } from \"./layer\";\nimport { CropRect } from \"./cropRect\";\n\ninterface ComposeScreenProps {\n  className?: string;\n}\n\nconst Container = styled.div`\n  position: relative;\n  width: 100%;\n  height: 100%;\n  flex: 1;\n  align-self: center;\n  overflow: auto;\n  background-color: var(--dock-color);\n`;\n\nconst CaptureLayer = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n`;\n\nexport const ComposeScreen: React.FunctionComponent<ComposeScreenProps> = ({\n  className\n}) => {\n  const [animationCounter, setAnimationCounter] = useState({\n    animation: 0,\n    rafFrameCountdown: 0\n  });\n  const { state, dispatch } = useAppState();\n  const [divRef, setDivRef] = useState<null | HTMLDivElement>(null);\n  const [isCropping, setIsCropping] = useState(false);\n  const [upperLeftCrop, setUpperLeftCrop] = useState<null | {\n    x: number;\n    y: number;\n  }>(null);\n  const [lowerRightCrop, setLowerRightCrop] = useState<null | {\n    x: number;\n    y: number;\n  }>(null);\n\n  useEffect(() => {\n    if (state.isPreviewing) {\n      // minus one because on my machine the animation can't quite keep up\n      const frameCountdown =\n        window.Module._get_neogeo_frame_counter_speed() - 1;\n      requestAnimationFrame(() => {\n        const diff = animationCounter.rafFrameCountdown === 0 ? 1 : 0;\n\n        setAnimationCounter({\n          animation: animationCounter.animation + diff,\n          rafFrameCountdown:\n            diff === 1 ? frameCountdown : animationCounter.rafFrameCountdown - 1\n        });\n      });\n    }\n  });\n\n  const [, dropRef] = useDrop({\n    accept: [\"Sprite\", \"Sprites\"],\n    drop: (item: any, monitor: any) => {\n      if (divRef) {\n        const x =\n          monitor.getClientOffset().x - divRef.getBoundingClientRect().left;\n\n        const composedX = Math.floor(x / 16) * 16;\n\n        if (item.type === \"Sprite\") {\n          const spriteMemoryIndex = item.spriteMemoryIndex;\n          const pauseId = item.pauseId;\n\n          if (pauseId) {\n            dispatch({\n              type: \"MoveSprite\",\n              spriteMemoryIndex,\n              newComposedX: composedX,\n              pauseId\n            });\n          } else {\n            dispatch({\n              type: \"ExtractSprite\",\n              spriteMemoryIndex,\n              composedX\n            });\n          }\n        } else {\n          dispatch({\n            type: \"ExtractSpritesToGroup\",\n            spriteMemoryIndices: item.spriteMemoryIndices,\n            composedX\n          });\n        }\n      }\n    },\n    canDrop() {\n      return !isCropping;\n    }\n  });\n\n  const layers = state.layers.map((layer, i) => {\n    if (state.hiddenLayers[layer.id]) {\n      return null;\n    } else {\n      return (\n        <LayerCmp\n          key={i}\n          index={i}\n          layer={layer}\n          runPreview={state.isPreviewing}\n          animationCounter={animationCounter.animation}\n          canDrag={!isCropping}\n          outlineTiles={state.showGrid}\n        />\n      );\n    }\n  });\n\n  const backgroundColorStyle = state.isPaused\n    ? {\n        backgroundColor: neoGeoColorToCSS(getBackdropNeoGeoColor())\n      }\n    : {};\n\n  return (\n    <>\n      <BuildGifModal\n        isOpen={state.isBuildingGif}\n        onRequestClose={() => dispatch(\"StopBuildGif\")}\n      />\n      <Container\n        className={className}\n        style={backgroundColorStyle}\n        ref={div => {\n          setDivRef(div);\n          dropRef(div);\n        }}\n      >\n        {layers}\n        {!!((isCropping && upperLeftCrop && lowerRightCrop) || state.crop) && (\n          <CropRect\n            width={divRef && divRef.scrollWidth}\n            height={divRef && divRef.scrollHeight}\n            crop={state.crop || [upperLeftCrop!, lowerRightCrop!]}\n          />\n        )}\n        {isCropping && (\n          <CaptureLayer\n            style={\n              divRef\n                ? {\n                    width: divRef.scrollWidth,\n                    height: divRef.scrollHeight\n                  }\n                : {}\n            }\n            onMouseDown={(e: React.MouseEvent<HTMLDivElement>) => {\n              if (isCropping) {\n                const rect = (e.target as HTMLDivElement).getBoundingClientRect() as DOMRect;\n\n                const rawX = e.clientX - rect.x;\n                const rawY = e.clientY - rect.y;\n\n                const x = Math.floor(rawX / 16) * 16;\n                const y = Math.floor(rawY / 16) * 16;\n\n                setUpperLeftCrop({ x, y });\n              }\n            }}\n            onMouseMove={e => {\n              if (isCropping && upperLeftCrop) {\n                const rect = (e.target as HTMLDivElement).getBoundingClientRect() as DOMRect;\n\n                const rawX = e.clientX - rect.x;\n                const rawY = e.clientY - rect.y;\n\n                const x = Math.floor(rawX / 16) * 16;\n                const y = Math.floor(rawY / 16) * 16;\n\n                setLowerRightCrop({ x, y });\n              }\n            }}\n            onMouseUp={() => {\n              if (isCropping && upperLeftCrop && lowerRightCrop) {\n                dispatch({\n                  type: \"SetCrop\",\n                  crop: [upperLeftCrop, lowerRightCrop]\n                });\n                setIsCropping(false);\n              }\n            }}\n          />\n        )}\n      </Container>\n    </>\n  );\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport { useAppState } from \"../state\";\n\ninterface ToolbarProps {\n  className?: string;\n}\n\nconst Container = styled.div`\n  display: grid;\n  grid-template-columns: 32px;\n  grid-template-rows: repeat(6, 32px) 1fr 32px 32px;\n`;\n\nexport const Toolbar: React.FunctionComponent<ToolbarProps> = ({\n  className\n}) => {\n  const { state, dispatch, undo, redo, canUndo, canRedo } = useAppState();\n\n  return (\n    <Container className={className}>\n      <button\n        title={`${state.showGrid ? \"hide\" : \"show\"} grid`}\n        onClick={() => dispatch(\"ToggleGrid\")}\n      >\n        G\n      </button>\n      <button title=\"crop\" onClick={() => dispatch(\"ToggleCropping\")}>\n        C{state.isCropping ? \"y\" : \"n\"}\n      </button>\n      <button title=\"clear crop\" onClick={() => dispatch(\"ClearCrop\")}>\n        X\n      </button>\n      <button title=\"preview\" onClick={() => dispatch(\"TogglePreview\")}>\n        P\n      </button>\n      <button title=\"build gif\" onClick={() => dispatch(\"BuildGif\")}>\n        G\n      </button>\n      <button title=\"down\" onClick={() => dispatch(\"PushAllDown\")}>\n        D\n      </button>\n\n      <div />\n\n      <button title=\"undo\" disabled={!canUndo} onClick={() => undo()}>\n        U\n      </button>\n      <button title=\"redo\" disabled={!canRedo} onClick={() => redo()}>\n        R\n      </button>\n    </Container>\n  );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\n\nimport styles from \"./iconButton.module.css\";\n\ninterface IconButtonProps {\n    className?: string;\n    title?: string;\n    icon: React.ComponentType<any>;\n    onClick?: (e: React.MouseEvent) => void;\n}\n\nexport const IconButton: React.FunctionComponent<IconButtonProps> = ({\n    className,\n    title,\n    icon,\n    onClick\n}) => {\n    const Icon = icon;\n\n    const classes = classnames(styles.root, className);\n\n    return (\n        <Icon\n            className={classes}\n            onClick={onClick}\n            title={title}\n            role=\"button\"\n            aria-label={title}\n        />\n    );\n};\n","import React from \"react\";\nimport { ExtractedSprite } from \"../state/types\";\nimport { IconButton } from \"../components/iconButton\";\nimport Delete from \"@material-ui/icons/Delete\";\n\nimport styles from \"./sprite.module.css\";\n\ninterface SpriteProps {\n    sprite: ExtractedSprite;\n    onDelete: () => void;\n}\n\nexport const Sprite: React.FunctionComponent<SpriteProps> = ({\n    sprite,\n    onDelete\n}) => {\n    return (\n        <div className={styles.root}>\n            {\" \"}\n            {sprite.spriteMemoryIndex}{\" \"}\n            <IconButton\n                icon={Delete}\n                title=\"Delete Layer\"\n                onClick={() => onDelete()}\n            />\n        </div>\n    );\n};\n","import React from \"react\";\nimport { ExtractedSpriteGroup as ExtractedSpriteGroupData } from \"../state/types\";\nimport { spriteGroupToDataUrl } from \"../state/toDataUrl\";\n\ninterface GroupPreviewProps {\n    group: ExtractedSpriteGroupData;\n}\n\nexport const GroupPreview: React.FunctionComponent<\n    GroupPreviewProps\n> = React.memo<GroupPreviewProps>(({ group }) => {\n    const { width: imgWidth, height: imgHeight, url } = spriteGroupToDataUrl(\n        group\n    );\n\n    const scale = 24 / Math.max(imgWidth, imgHeight);\n\n    return (\n        <img\n            width={imgWidth * scale}\n            height={imgHeight * scale}\n            src={url}\n            alt=\"sprite group thumbnail\"\n        />\n    );\n});\n","import { Layer, ExtractedSpriteGroup } from \"./types\";\nimport { layersToCanvas } from \"./layersToCanvas\";\nimport { setLayerToZeroZero, setGroupToZeroZero } from \"./spriteUtil\";\n\ntype ToDataUrlResult = {\n    url: string;\n    width: number;\n    height: number;\n};\n\nexport function layerToDataUrl(layer: Layer): ToDataUrlResult {\n    const layers = [setLayerToZeroZero(layer)];\n    const canvas = layersToCanvas(layers);\n\n    return {\n        url: canvas.toDataURL(\"image/png\"),\n        width: canvas.width,\n        height: canvas.height\n    };\n}\n\nexport function spriteGroupToDataUrl(\n    group: ExtractedSpriteGroup\n): ToDataUrlResult {\n    const layers = [{ id: 0, groups: [setGroupToZeroZero(group)] }];\n    const canvas = layersToCanvas(layers);\n\n    return {\n        url: canvas.toDataURL(\"image/png\"),\n        width: canvas.width,\n        height: canvas.height\n    };\n}\n","import React, { useState } from \"react\";\nimport { useAppState } from \"../state\";\nimport { ExtractedSpriteGroup } from \"../state/types\";\nimport { IconButton } from \"../components/iconButton\";\nimport Delete from \"@material-ui/icons/Delete\";\nimport ExpandLess from \"@material-ui/icons/ExpandLess\";\nimport ExpandMore from \"@material-ui/icons/ExpandMore\";\nimport { IoIosEye, IoIosEyeOff } from \"react-icons/io\";\nimport { Sprite } from \"./sprite\";\nimport { GroupPreview } from \"./groupPreview\";\n\nimport styles from \"./group.module.css\";\n\ninterface GroupProps {\n  group: ExtractedSpriteGroup;\n  onDelete: () => void;\n  onToggleVisibility: () => void;\n}\n\nexport const Group: React.FunctionComponent<GroupProps> = ({\n  group,\n  onDelete,\n  onToggleVisibility\n}) => {\n  const { dispatch, state } = useAppState();\n  const [showSprites, setShowSprites] = useState(false);\n\n  let sprites = null;\n\n  if (showSprites) {\n    sprites = group.sprites.map(sprite => (\n      <Sprite\n        key={sprite.spriteMemoryIndex + \"-\" + sprite.pauseId}\n        sprite={sprite}\n        onDelete={() =>\n          dispatch({\n            type: \"RemoveSpriteFromExtractedGroup\",\n            group,\n            sprite\n          })\n        }\n      />\n    ));\n  }\n\n  return (\n    <div className={styles.root}>\n      <div className={styles.toolbar}>\n        <IconButton\n          icon={showSprites ? ExpandLess : ExpandMore}\n          title=\"Show sprites\"\n          onClick={() => setShowSprites(!showSprites)}\n        />\n        <GroupPreview group={group} />\n        <div>\n          {(group.sprites[0] && group.sprites[0].spriteMemoryIndex) || \"empty\"}\n        </div>\n        <IconButton\n          icon={state.hiddenGroups[group.id] ? IoIosEyeOff : IoIosEye}\n          onClick={() => onToggleVisibility()}\n          title={`Group is ${\n            state.hiddenLayers[group.id] ? \"hidden\" : \"visible\"\n          }`}\n        />\n        <IconButton\n          icon={Delete}\n          title=\"Delete Group\"\n          onClick={() => onDelete()}\n        />\n      </div>\n      <div className={styles.spriteContainer}>{sprites}</div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { Layer as LayerData } from \"../state/types\";\nimport { layerToDataUrl } from \"../state/toDataUrl\";\n\ninterface LayerPreviewProps {\n    layer: LayerData;\n}\n\nexport const LayerPreview: React.FunctionComponent<\n    LayerPreviewProps\n> = React.memo<LayerPreviewProps>(({ layer }) => {\n    const { width: imgWidth, height: imgHeight, url } = layerToDataUrl(layer);\n\n    const scale = 48 / imgHeight;\n\n    return (\n        <img\n            width={imgWidth * scale}\n            height={imgHeight * scale}\n            src={url}\n            alt=\"layer thumbnail\"\n        />\n    );\n});\n","import React, { useState } from \"react\";\nimport { useAppState } from \"../state\";\nimport { Layer as LayerData, ExtractedSpriteGroup } from \"../state/types\";\nimport { IconButton } from \"../components/iconButton\";\nimport Delete from \"@material-ui/icons/Delete\";\nimport ExpandLess from \"@material-ui/icons/ExpandLess\";\nimport ExpandMore from \"@material-ui/icons/ExpandMore\";\nimport VerticalAlignBottom from \"@material-ui/icons/VerticalAlignBottom\";\nimport {\n  IoIosEye,\n  IoIosEyeOff,\n  IoIosReorder,\n  IoIosPhoneLandscape\n} from \"react-icons/io\";\nimport { Group } from \"./group\";\nimport { LayerPreview } from \"./layerPreview\";\n\nimport styles from \"./layer.module.css\";\n\ninterface LayerProps {\n  layer: LayerData;\n  onGroupDelete: (group: ExtractedSpriteGroup) => void;\n  onGroupToggleVisibility: (group: ExtractedSpriteGroup) => void;\n  onDelete: () => void;\n  onToggleVisibility: () => void;\n  onExtendViaMirror: () => void;\n  onPushDown: () => void;\n}\n\nexport const Layer: React.FunctionComponent<LayerProps> = ({\n  layer,\n  onDelete,\n  onToggleVisibility,\n  onGroupDelete,\n  onGroupToggleVisibility,\n  onExtendViaMirror,\n  onPushDown\n}) => {\n  const { dispatch, state } = useAppState();\n  const [showGroups, setShowGroups] = useState(true);\n\n  const groups = layer.groups.map(group => (\n    <Group\n      key={group.id}\n      group={group}\n      onDelete={() => onGroupDelete(group)}\n      onToggleVisibility={() => onGroupToggleVisibility(group)}\n    />\n  ));\n\n  return (\n    <div className={styles.root}>\n      <div className={styles.toolbar}>\n        <IconButton\n          icon={showGroups ? ExpandLess : ExpandMore}\n          title=\"Show groups\"\n          onClick={() => setShowGroups(!showGroups)}\n        />\n        <LayerPreview layer={layer} />\n        <IconButton\n          icon={IoIosReorder}\n          onClick={() => dispatch({ type: \"RotateLayer\", layer })}\n          title=\"Rotate tiles\"\n        />\n        <IconButton\n          icon={IoIosPhoneLandscape}\n          onClick={() => onExtendViaMirror()}\n          title=\"Mirror\"\n        />\n        <IconButton\n          icon={VerticalAlignBottom}\n          onClick={() => onPushDown()}\n          title=\"Push Down\"\n        />\n        <IconButton\n          icon={state.hiddenLayers[layer.id] ? IoIosEyeOff : IoIosEye}\n          onClick={() => onToggleVisibility()}\n          title={`Layer is ${\n            state.hiddenLayers[layer.id] ? \"hidden\" : \"visible\"\n          }`}\n        />\n        <IconButton\n          icon={Delete}\n          title=\"Delete Layer\"\n          onClick={() => onDelete()}\n        />\n      </div>\n      {showGroups && groups}\n    </div>\n  );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { useAppState } from \"../state\";\nimport { IconButton } from \"../components/iconButton\";\nimport { IoIosAdd } from \"react-icons/io\";\nimport { Layer } from \"./layer\";\n\nimport styles from \"./layers.module.css\";\n\ninterface LayersProps {\n  className?: string;\n}\n\nexport const Layers: React.FunctionComponent<LayersProps> = ({ className }) => {\n  const { state, dispatch } = useAppState();\n\n  const classes = classnames(styles.root, className);\n\n  // reverse layers due to wanting the highest z-index layer to be at the top of\n  // the list, which is opposite of how they are stored\n  const layers = [...state.layers]\n    .reverse()\n    .map(layer => (\n      <Layer\n        key={layer.id}\n        layer={layer}\n        onDelete={() => dispatch({ type: \"DeleteLayer\", layer })}\n        onToggleVisibility={() =>\n          dispatch({ type: \"ToggleVisibilityOfLayer\", layer })\n        }\n        onGroupDelete={group => dispatch({ type: \"DeleteGroup\", group })}\n        onGroupToggleVisibility={group =>\n          dispatch({ type: \"ToggleVisibilityOfGroup\", group })\n        }\n        onExtendViaMirror={() =>\n          dispatch({ type: \"ExtendLayerViaMirror\", layer })\n        }\n        onPushDown={() => dispatch({ type: \"PushDownLayer\", layer })}\n      />\n    ));\n\n  return (\n    <div className={classes}>\n      <IconButton\n        className={styles.buttonIcon}\n        icon={IoIosAdd}\n        onClick={() => dispatch({ type: \"NewLayer\" })}\n        title=\"New Layer\"\n      />\n      {layers}\n    </div>\n  );\n};\n","import React, { useState } from \"react\";\nimport styled from \"styled-components\";\n\ninterface FileDropZoneProps {\n  onFileChosen: (file: File) => void;\n  fileName?: string;\n}\n\ninterface ContainerProps {\n  isOver?: boolean;\n}\n\nconst Container = styled.div<ContainerProps>`\n  border: 1px dotted gray;\n  flex: 1;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-content: center;\n  text-align: center;\n  font-size: 0.8em;\n  color: gray;\n\n  background-color: ${props => (props.isOver ? \"lightgray\" : \"transparent\")};\n`;\n\nconst ChooseFile = styled.label`\n  cursor: pointer;\n  font-weight: bold;\n`;\n\nconst FileInput = styled.input`\n  width: 0.01px;\n  height: 0.01px;\n`;\n\nfunction hasFiles(e: React.DragEvent<HTMLDivElement>): boolean {\n  let hasFiles = false;\n\n  if (e.dataTransfer) {\n    const types = e.dataTransfer.types;\n    for (const keyOrIndex in types) {\n      if (types[keyOrIndex] === \"Files\") {\n        hasFiles = true;\n        break;\n      }\n    }\n  }\n  return hasFiles;\n}\n\nexport const FileDropZone: React.FunctionComponent<FileDropZoneProps> = ({\n  onFileChosen,\n  fileName\n}) => {\n  const [isOver, setIsOver] = useState(false);\n\n  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {\n    if (e.target && e.target.files && e.target.files[0]) {\n      onFileChosen(e.target.files[0]);\n    }\n  }\n\n  function handleDragOver(e: React.DragEvent<HTMLDivElement>) {\n    setIsOver(hasFiles(e));\n  }\n\n  function handleDragLeave() {\n    setIsOver(false);\n  }\n\n  function handleDrop(e: React.DragEvent<HTMLDivElement>) {\n    if (hasFiles(e)) {\n      const file =\n        e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];\n\n      if (file) {\n        onFileChosen(file);\n      }\n    }\n  }\n\n  const body = fileName ? (\n    <>{fileName}</>\n  ) : (\n    <div\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n    >\n      drag a file here, or{\" \"}\n      <ChooseFile>\n        click to choose\n        <FileInput type=\"file\" onChange={handleChange} />\n      </ChooseFile>\n    </div>\n  );\n\n  return <Container isOver={isOver}>{body}</Container>;\n};\n","import React from \"react\";\nimport styled, { keyframes } from \"styled-components\";\nimport { FileDropZone } from \"./fileDropZone\";\n\ninterface FileStepProps {\n  className?: string;\n  stepNumber: number;\n  title: string;\n  description: React.ReactNode;\n  onFileChosen: (file: File) => void;\n  fileName?: string;\n  loading?: boolean;\n}\n\nconst Container = styled.div`\n  display: grid;\n  grid-template-rows: repeat(2, auto);\n\n  color: black;\n  outline: 1px solid gray;\n`;\n\nconst InnerContainer = styled.div`\n  display: grid;\n  grid-template-columns: max-content 1fr 200px;\n  grid-template-rows: repeat(2, auto);\n  column-gap: 16px;\n  row-gap: 16px;\n\n  padding: 16px;\n`;\n\nconst StepNumber = styled.div`\n  font-size: 96px;\n  font-weight: bold;\n\n  color: lightgray;\n`;\n\nconst TitleContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n`;\n\nconst Title = styled.div`\n  font-size: 24px;\n  font-weight: bold;\n`;\n\nconst loadingFrames = keyframes`\n  0% {\n    width: 0%;\n  }\n  50% {\n    width: 100%;\n  }\n  100% {\n    width: 0%;\n  }\n`;\n\nconst LoadingIndicator = styled.div`\n  width: 100%;\n  height: 3px;\n\n  background-color: var(--focal-color);\n  position: relative;\n\n  &:after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    width: 100%;\n    background-image: linear-gradient(\n      90deg,\n      transparent 0,\n      transparent 90%,\n      rgba(255, 255, 255, 0.5) 90%,\n      white 95%,\n      rgba(255, 255, 255, 0.5) 100%\n    );\n\n    animation: 6s ${loadingFrames} ease-in-out infinite;\n  }\n`;\n\nexport const FileStep: React.FunctionComponent<FileStepProps> = ({\n  className,\n  stepNumber,\n  title,\n  description,\n  loading,\n  fileName,\n  onFileChosen\n}) => {\n  const loadingStyle = {\n    visibility: loading ? \"visible\" : \"hidden\"\n  } as const;\n\n  return (\n    <Container className={className}>\n      <LoadingIndicator style={loadingStyle} />\n      <InnerContainer>\n        <StepNumber>{stepNumber}</StepNumber>\n        <TitleContainer>\n          <Title>{title}</Title>\n          <div>{description}</div>\n        </TitleContainer>\n        <FileDropZone onFileChosen={onFileChosen} fileName={fileName} />\n      </InnerContainer>\n    </Container>\n  );\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport ss2Img from \"./ss2Title.png\";\nimport streetSlamImg from \"./streetSlamTitle.png\";\n\ninterface DemoChoicesProps {\n  className?: string;\n  onChoice: (demoType: \"ss2\" | \"streetSlam\") => void;\n}\n\nconst Container = styled.div`\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  grid-template-rows: max-content;\n  column-gap: 8px;\n`;\n\nconst Choice = styled.div`\n  width: 100%;\n  height: 128px;\n  outline: 1px solid gray;\n  cursor: pointer;\n\n  background-color: black;\n  background-image: var(--choice-title-img);\n  background-repeat: no-repeat;\n  background-position: center center;\n  background-size: 80%;\n`;\n\nconst SS2 = styled.div`\n  --choice-title-img: url(${ss2Img});\n`;\n\nconst StreetSlam = styled.div`\n  --choice-title-img: url(${streetSlamImg});\n`;\n\nexport const DemoChoices: React.FunctionComponent<DemoChoicesProps> = ({\n  className,\n  onChoice\n}) => {\n  return (\n    <Container className={className}>\n      <SS2>\n        <Choice onClick={() => onChoice(\"ss2\")} />\n      </SS2>\n      <StreetSlam>\n        <Choice onClick={() => onChoice(\"streetSlam\")} />\n      </StreetSlam>\n    </Container>\n  );\n};\n","import React, { useState } from \"react\";\nimport styled from \"styled-components\";\nimport Modal from \"react-modal\";\nimport { useAppState } from \"../state\";\nimport { DemoData } from \"../state/state\";\nimport { FileStep } from \"./fileStep\";\nimport { DemoChoices } from \"./demoChoices\";\n\nconst StyledModal = styled(Modal)`\n  max-width: 600px;\n  padding: 16px;\n  margin: 96px auto;\n  background-color: white;\n\n  display: grid;\n  grid-template-rows: repeat(3, auto);\n  row-gap: 16px;\n\n  background-color: #eee;\n  color: black;\n  box-shadow: 0px 24px 20px 0px rgba(0, 0, 0, 0.7);\n`;\n\nconst Title = styled.div`\n  font-size: 24px;\n`;\n\nconst Why = styled.div`\n  margin-top: 8px;\n  font-size: 0.8rem;\n\n  & > a {\n    color: blue;\n    cursor: pointer;\n  }\n\n  & > div {\n    margin-top: 8px;\n  }\n`;\n\nfunction loadFile<T>(file: File): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", () => {\n      if (reader.result) {\n        resolve((reader.result as unknown) as T);\n      } else {\n        reject(`Failed to load: ${file.name}`);\n      }\n    });\n\n    reader.readAsArrayBuffer(file);\n  });\n}\n\nasync function addFileToVirtualFS(file: File) {\n  const data: ArrayBuffer = await loadFile(file);\n\n  window.Module.FS_createDataFile(\n    \"/virtualfs\",\n    file.name,\n    new Uint8Array(data),\n    true,\n    true\n  );\n}\n\nexport const ChooseGameModal: React.FunctionComponent = () => {\n  const [showWhy, setShowWhy] = useState(false);\n  const [isOpen, setIsOpen] = useState(true);\n  const [romName, setRomName] = useState(\"\");\n  const [biosName, setBiosName] = useState(\"\");\n  const [romLoaded, setRomLoaded] = useState(false);\n  const [biosLoaded, setBiosLoaded] = useState(false);\n  const [loadingBios, setLoadingBios] = useState(false);\n  const [loadingRom, setLoadingRom] = useState(false);\n\n  const { dispatch } = useAppState();\n\n  function loadBiosFile(file: File) {\n    if (file.name === \"neogeo.zip\") {\n      setLoadingBios(true);\n      setBiosName(file.name);\n\n      addFileToVirtualFS(file).then(() => {\n        setLoadingBios(false);\n        setBiosLoaded(true);\n      });\n    }\n  }\n\n  function loadRomFile(file: File) {\n    setLoadingRom(true);\n    setRomName(file.name);\n\n    addFileToVirtualFS(file).then(() => {\n      setLoadingRom(false);\n      setRomLoaded(true);\n    });\n  }\n\n  function startRom(overrideRomName?: string) {\n    const argv = window.stackAlloc(3 * 4);\n\n    const romToLoad = (overrideRomName || romName).replace(\".zip\", \"\");\n\n    window.HEAP32[argv >> 2] = window.allocateUTF8OnStack(\"gngeo\");\n    window.HEAP32[(argv >> 2) + 1] = window.allocateUTF8OnStack(romToLoad);\n    window.HEAP32[(argv >> 2) + 2] = 0;\n\n    setIsOpen(false);\n    dispatch({ type: \"StartEmulation\" });\n\n    try {\n      window.Module._run_rom(2, argv);\n    } catch (e) {\n      console.log(\"_run_rom threw\");\n    }\n  }\n\n  function launch() {\n    const rom =\n      process.env.NODE_ENV !== \"production\" ? romName || \"samsho2\" : romName;\n    startRom(rom);\n  }\n\n  async function handleDemoChoice(demoType: \"ss2\" | \"streetSlam\") {\n    const fetchedRawData = await fetch(`./${demoType}.json`);\n    const data = await fetchedRawData.json();\n\n    setIsOpen(false);\n    dispatch({ type: \"SetDemo\", demoData: data as DemoData });\n  }\n\n  const romDescription = (\n    <div>\n      The game ROM, such as samsho2.zip\n      <Why>\n        <a onClick={() => setShowWhy(!showWhy)}>why does my ROM not work?</a>\n        {showWhy && (\n          <div>\n            NGBG uses GnGeo as its emulator. GnGeo requires ROMs to be in a\n            specific format, and many ROMs out there today don't match. I will\n            fix this eventually.\n          </div>\n        )}\n      </Why>\n    </div>\n  );\n\n  return (\n    <StyledModal isOpen={isOpen} overlayClassName=\"modalOverlay\">\n      <Title>To start, please provide these two files</Title>\n      <FileStep\n        stepNumber={1}\n        title=\"Neo Geo BIOS\"\n        description=\"The BIOS file for the Neo Geo, it must be named neogeo.zip\"\n        onFileChosen={loadBiosFile}\n        loading={loadingBios}\n        fileName={biosName}\n      />\n      <FileStep\n        stepNumber={2}\n        title=\"Game ROM\"\n        description={romDescription}\n        onFileChosen={loadRomFile}\n        loading={loadingRom}\n        fileName={romName}\n      />\n      <button disabled={!romLoaded || !biosLoaded} onClick={() => launch()}>\n        launch\n      </button>\n      <Title>Or ... choose a demo to taste how the app works</Title>\n      <DemoChoices onChoice={handleDemoChoice} />\n    </StyledModal>\n  );\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport { DndProvider } from \"react-dnd\";\nimport HTML5Backend from \"react-dnd-html5-backend\";\nimport { Provider as AppStateProvider } from \"./state/provider\";\nimport { DragPreviewLayer } from \"./dragPreviewLayer\";\nimport { Emulator } from \"./emulator\";\nimport { SpriteTray } from \"./spriteTray\";\nimport { ComposeScreen } from \"./composeScreen\";\nimport { Toolbar } from \"./toolbar\";\nimport { Layers } from \"./layers\";\nimport { ChooseGameModal } from \"./chooseGameModal\";\n\nconst AppRoot = styled.div`\n  --gutter-width: 16px;\n\n  width: 100vw;\n  height: 100vh;\n\n  display: grid;\n  grid-template-rows: 1fr;\n  grid-template-columns: max-content 1fr 320px;\n  column-gap: var(--gutter-width);\n\n  padding: var(--gutter-width);\n`;\n\nconst ComposeScreenTrayGrid = styled.div`\n  display: grid;\n  grid-template-rows: 1fr max-content;\n  grid-template-columns: 1fr;\n  row-gap: var(--gutter-width);\n\n  & .composeScreen {\n    grid-row: 1;\n  }\n\n  & .spriteTray {\n    grid-row: 2;\n  }\n`;\n\nconst EmulatorLayersGrid = styled.div`\n  display: grid;\n  grid-template-rows: max-content 1fr;\n  grid-template-columns: 1fr;\n  row-gap: var(--gutter-width);\n\n  .emulator {\n    grid-column: 1;\n    grid-row: 1;\n  }\n\n  .layers {\n    grid-column: 1;\n    grid-row: 2;\n  }\n`;\n\nexport const App: React.FunctionComponent = () => {\n  return (\n    <AppStateProvider>\n      <DndProvider backend={HTML5Backend}>\n        <ChooseGameModal />\n        <DragPreviewLayer />\n        <AppRoot>\n          <Toolbar />\n          <ComposeScreenTrayGrid>\n            <ComposeScreen className=\"composeScreen\" />\n            <SpriteTray className=\"spriteTray\" />\n          </ComposeScreenTrayGrid>\n          <EmulatorLayersGrid>\n            <Emulator className=\"emulator\" />\n            <Layers className=\"layers\" />\n          </EmulatorLayersGrid>\n        </AppRoot>\n      </DndProvider>\n    </AppStateProvider>\n  );\n};\n","import React from \"react\";\nimport Modal from \"react-modal\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./app\";\n\nimport \"./index.css\";\n\nModal.setAppElement(\"#root\");\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\nif (process.env.ENABLE_DEMO_DUMP) {\n  // @ts-ignore\n  window.dumpDemo = function() {\n    // @ts-ignore\n    const palettes = Object.keys(window.neededPalettes).reduce((b, k) => {\n      const palAddr = window.Module._get_current_pal_addr();\n      const palOffset = Number(k) * 32;\n      const palIndexInHeap = (palAddr + palOffset) / 2;\n\n      // @ts-ignore\n      b[k] = window.Module.HEAPU16.slice(palIndexInHeap, palIndexInHeap + 16);\n      return b;\n    }, {});\n\n    // @ts-ignore\n    const tileMemory = Object.keys(window.neededTiles).reduce((b, k) => {\n      // @ts-ignore\n      b[k] = window.HEAPU8.slice(\n        window.Module._get_rom_ctile_addr() + Number(k) * 2 * 16 * 4,\n        window.Module._get_rom_ctile_addr() + (Number(k) + 1) * 2 * 16 * 4\n      );\n      return b;\n    }, {});\n\n    const spriteMemoryStart = window.Module._get_tile_ram_addr();\n    const spriteMemoryEnd = spriteMemoryStart + 0x85ff * 2;\n\n    const spriteMemory = window.HEAPU8.slice(\n      spriteMemoryStart,\n      spriteMemoryEnd\n    );\n\n    const dump = {\n      palettes,\n      tileMemory,\n      spriteMemory\n    };\n\n    const asJson = JSON.stringify(dump, (_, v) => {\n      if (v.join) {\n        return \"[\" + v.join(\",\") + \"]\";\n      } else {\n        return v;\n      }\n    });\n\n    console.log(asJson);\n  };\n}\n"],"sourceRoot":""}