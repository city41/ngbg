{"version":3,"sources":["spriteTray/spriteEntry.module.css","composeScreen/cropRect.module.css","composeScreen/layers.module.css","spriteTray/spriteTray.module.css","spriteTray/sprite.module.css","emulator/emulator.module.css","spriteTray/tile.module.css","composeScreen/extractedTile.module.css","composeScreen/extractedSprite.module.css","state/spriteData.ts","palette/neoGeoPalette.ts","state/extractSpriteGroup.ts","state/state.tsx","emulator/emulator.tsx","state/renderTileToCanvas.ts","spriteTray/tile.tsx","spriteTray/sprite.tsx","spriteTray/spriteEntry.tsx","spriteTray/spriteTray.tsx","composeScreen/extractedTile.tsx","composeScreen/extractedSprite.tsx","state/jsgif/LZWEncoder.js","state/jsgif/NeuQuant.js","state/jsgif/GIFEncoder.js","state/spriteGroupToCanvas.ts","state/createGif_jsgif.ts","gifBuilder/buildGifModal.tsx","composeScreen/layers.tsx","composeScreen/cropRect.tsx","composeScreen/composeScreen.tsx","index.tsx","App.tsx","composeScreen/composeScreen.module.css"],"names":["module","exports","SCB1_SPRITE_SIZE_BYTES","SCB2_BYTE_OFFSET","SCB3_BYTE_OFFSET","SCB4_BYTE_OFFSET","getTileData","spriteIndex","spriteSize","tileYs","tileRamAddr","window","Module","_get_tile_ram_addr","spriteOffset","spriteData","i","HEAPU8","tileData","w","length","firstWord","secondWord","tileIndex","autoAnimation","paletteIndex","horizontalFlip","verticalFlip","push","y","getYSpriteSizeSticky","Error","spriteScb3Addr","scb3Word","sticky","rawY","yScale","fullmode","transformY","getScale","ignoreSticky","t","getX","x","xScale","spriteScb4Addr","options","spriteScb2Addr","scb2Word","getSpriteData","honorTileSize","tiles","COLORS_PER_PALETTE","PALETTE_SIZE_IN_BYTES","convertNeoGeoColorToRGBColor","col16","darkBit","getNeoGeoPalette","paletteMemoryIndex","palIndexInHeap","_get_current_pal_addr","HEAPU16","slice","convertNeoGeoPaletteToRGB","neoGeoPalette","mapped","map","convertTileDataToExtractedTile","rest","composedY","rgbPalette","extractSpriteGroup","spriteMemoryIndex","composedX","pauseId","sprites","rootSpriteIndex","spriteMemoryIndices","getSpriteGroup","smi","screenX","screenY","group","hidden","forEach","s","initialState","hasStarted","isPaused","layers","focusedLayerIndex","crop","undefined","pushDownOutOfNegative","reduce","gs","l","concat","groups","ts","sg","sts","mostNegative","Math","min","nudge","extendGroupsViaMirroring","ss","rightMirror","maxX","max","sprite","reverse","mirrorSpritesToRight","newLeftGroup","minX","width","mirrorSpritesToLeft","newRightGroup","reducer","state","action","type","nowPaused","layer","currentSpriteGroup","find","some","focusedGroup","allGroups","newComposedX","xDiff","filter","moveRelatedGroups","newSpriteGroup","oldSpriteGroups","esg","a","b","aIndices","es","sort","bIndices","isEqual","haveSameSprites","newGroup","oldGroups","sameGroup","og","screenToComposeDiffX","positionSpriteGroupInRelationToExistingGroups","indexOf","g","extendedViaMirror","mirroredGroups","pushInOutOfNegative","_","assertUnreachable","stateContext","createContext","dispatchContext","Provider","children","useReducer","dispatch","value","useAppState","useContext","TOGGLE_PAUSE","START_EMULATION","HANDLE_NEGATIVES","NEW_LAYER","CLEAR_CROP","loadFile","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","name","readAsArrayBuffer","addFileToVirtualFS","data","FS_createDataFile","Uint8Array","Emulator","props","useState","gameName","e","target","files","startGame","replace","overrideGameName","argv","stackAlloc","HEAP32","allocateUTF8OnStack","_run_rom","console","log","classes","classnames","styles","root","className","id","onChange","disabled","onClick","resumeMainLoop","pauseMainLoop","TILE_SIZE_BYTES","TILE_SIZE_INTS","0","1","2","3","4","5","6","7","renderTileToCanvas","canvas","cromAddr","_get_rom_ctile_addr","tileOffset","height","context","getContext","imageData","getImageData","pixelPair","rightPixelColorIndex","leftPixel","rightPixel","putImageData","Tile","this","tileY","positioned","verticalScale","inlineStyle","transform","top","ref","r","renderCanvas","style","React","PureComponent","Sprite","overrideX","useDrag","item","dragRef","key","left","gridTemplateRows","zIndex","spriteClassName","SpriteEntry","render","hideIfEmpty","focused","hide","isSpriteEmpty","index","spriteContainer","SpriteTray","focusedIndices","setFocusedIndices","shiftStartIndex","setShiftStartIndex","locked","spriteEntries","gridTemplateColumns","Array","fill","ctrlKey","shiftKey","minIndex","maxIndex","minValue","maxValue","count","arrayFrom","ExtractedTile","ExtractedSprite","autoAnimate","animationCounter","canDrag","LZWEncoder","imgW","imgH","pixAry","initCodeSize","remaining","curPixel","n_bits","maxcode","g_init_bits","ClearCode","EOFCode","a_count","EOF","BITS","HSIZE","maxbits","maxmaxcode","htab","codetab","hsize","free_ent","clear_flg","cur_accum","cur_bits","masks","accum","pixels","color_depth","char_out","c","outs","flush_char","cl_block","cl_hash","output","compress","init_bits","fcode","ent","disp","hsize_reg","hshift","MAXCODE","nextPixel","outer_loop","encode","os","writeByte","writeBytes","code","apply","arguments","NeuQuant","alphadec","thepicture","lengthcount","samplefac","network","netsize","prime1","prime2","prime3","prime4","minpicturebytes","maxnetpos","netbiasshift","ncycles","intbiasshift","intbias","gammashift","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","radbiasshift","radbias","alpharadbshift","alpharadbias","netindex","bias","freq","radpower","thepic","len","sample","p","colorMap","k","j","inxbuild","smallpos","smallval","q","previouscol","startpos","learn","radius","rad","alpha","step","delta","samplepixels","pix","lim","contest","altersingle","alterneigh","unbiasnet","dist","bestd","best","process","lo","hi","m","n","biasdist","betafreq","bestpos","bestbiaspos","bestbiasd","GIFEncoder","chr","String","fromCharCode","ByteArray","bin","prototype","getData","v","val","writeUTFBytes","string","charCodeAt","array","offset","transIndex","out","image","indexedPixels","colorDepth","colorTab","transparent","repeat","delay","started","usedEntry","palSize","dispose","closeStream","firstFrame","sizeSet","comment","reset","setDelay","ms","round","setDispose","setRepeat","iter","setTransparent","setComment","addFrame","im","is_imageData","ok","ImageData","setSize","Uint8ClampedArray","getImagePixels","analyzePixels","writeLSD","writePalette","writeNetscapeExt","writeGraphicCtrlExt","writeCommentExt","writeImageDesc","writePixels","download","filename","endsWith","templink","document","createElement","href","URL","createObjectURL","Blob","click","finish","setFrameRate","fps","setQuality","quality","h","start","cont","nPix","nq","findClosest","minpos","dmin","dr","dg","db","d","transp","WriteShort","pValue","stream","setProperties","has_start","is_first","spriteGroupToCanvas","spriteGroups","dimensions","building","getDimensions","tile","tileCanvas","translateX","translateY","newCanvas","save","translate","scale","drawImage","restore","flip","fullCanvas","cropWidth","cropHeight","croppedCanvas","cropCanvas","TOTAL_FRAMES","FOREVER","clear","div","firstChild","removeChild","BuildGifModal","isOpen","onRequestClose","containerRef","useRef","frameStatus","setFrameStatus","useEffect","_get_neogeo_frame_counter_speed","onFrame","onFinish","encoder","remainingFrames","binaryData","btoa","frameCanvas","setTimeout","createGif","frame","totalFrames","current","appendChild","dataUrl","img","Image","src","Group","onDelete","onToggleVisibility","Layer","onGroupDelete","onGroupToggleVisibility","onExtendViaMirror","Layers","setFocusedLayerAction","deleteLayerAction","toggleVisiblityOfLayerAction","deleteGroupAction","toggleVisiblityOfGroupAction","extendLayerViaMirrorAction","CropRect","totalWidth","totalHeight","topRowStyle","gridColumn","gridRow","leftCellStyle","rightCellStyle","cropStyle","bottomRowStyle","flex","mask","ComposeScreen","animation","rafFrameCountdown","setAnimationCounter","runPreview","setRunPreview","showBuildGifModal","setShowBuildGifModal","divRef","setDivRef","isCropping","setIsCropping","upperLeftCrop","setUpperLeftCrop","lowerRightCrop","setLowerRightCrop","frameCountdown","requestAnimationFrame","diff","useDrop","accept","drop","monitor","getClientOffset","getBoundingClientRect","floor","extractSpriteAction","canDrop","dropRef","extractedSprites","extractedSprite","backgroundColor","neoGeoColor","asArray","neoGeoColorToCSS","palAddr","getBackdropNeoGeoColor","maxY","finalClassName","toolbar","bg","captureLayer","onMouseDown","rect","rawX","clientX","clientY","onMouseMove","onMouseUp","cropRect","handleNegatives","Modal","setAppElement","ReactDOM","backend","HTML5Backend","size","getElementById"],"mappings":"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","file":"static/js/main.c0a3367d.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"spriteEntry_root__21-Rc\",\"hide\":\"spriteEntry_hide__1KLBL\",\"index\":\"spriteEntry_index__3_j9A\",\"focused\":\"spriteEntry_focused__2e2R9\",\"spriteContainer\":\"spriteEntry_spriteContainer__3BESY\",\"sprite\":\"spriteEntry_sprite__3D55Y\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"cropRect_root__LYSAR\",\"mask\":\"cropRect_mask__Vl5ZD\",\"crop\":\"cropRect_crop__2ev0N\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"layers_root__pN2-U\",\"layer\":\"layers_layer__1JaOv\",\"focused\":\"layers_focused__1aScK\",\"group\":\"layers_group__2ZkQp\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"spriteTray_root__1Sixf\",\"locked\":\"spriteTray_locked__Lvuwa\",\"spriteEntries\":\"spriteTray_spriteEntries__16oai\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sprite\":\"sprite_sprite__38hI5\",\"positioned\":\"sprite_positioned__16NC_\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"emulator_root__3kH7Z\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"positioned\":\"tile_positioned__9EsHg\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"extractedTile_root__14wnu\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"extractedSprite_root__gpe6g\"};","// ALERT!\n// vram addresses in the neo geo are word wide, not byte wide!\n// TODO: can probably just use HEAPU16 and make this all much simpler\n// ALERT!\n\n// in SCB1,\n// each sprite has 64, 16-bit, words\nconst SCB1_SPRITE_SIZE_BYTES = 64 * 2;\n\n// it starts at word $8000, so *2 to get byte address\nconst SCB2_BYTE_OFFSET = 0x8000 * 2;\n\n// it starts at word $8200, so *2 to get byte address\nconst SCB3_BYTE_OFFSET = 0x8200 * 2;\n\n// it starts at word $8400, so *2 to get byte address\nconst SCB4_BYTE_OFFSET = 0x8400 * 2;\n\nexport interface TileData {\n    y: number;\n    tileIndex: number;\n    paletteIndex: number;\n    horizontalFlip: boolean;\n    verticalFlip: boolean;\n    autoAnimation: 0 | 2 | 3;\n}\n\ninterface SpriteData {\n    tiles: TileData[];\n    x: number;\n    y: number;\n    sticky: boolean;\n    spriteSize: number;\n}\n\nfunction getTileData(\n    spriteIndex: number,\n    spriteSize: number,\n    tileYs: number[]\n): TileData[] {\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const spriteOffset = SCB1_SPRITE_SIZE_BYTES * spriteIndex;\n\n    const spriteData: number[] = [];\n\n    for (let i = 0; i < spriteSize * 4; ++i) {\n        spriteData[i] = window.HEAPU8[tileRamAddr + spriteOffset + i];\n    }\n\n    const tileData = [];\n\n    for (let w = 0; w < spriteData.length; w += 4) {\n        const firstWord = spriteData[w] | (spriteData[w + 1] << 8);\n        const secondWord = spriteData[w + 2] | (spriteData[w + 3] << 8);\n\n        // first word = least sig bits of tile index\n        // second word, bits 4 through 7 = most sig bits of tile index\n        let tileIndex = firstWord | (((secondWord >> 4) & 0xf) << 16);\n\n        let autoAnimation: 0 | 2 | 3 = 0;\n\n        // automatic animation\n        if (secondWord & 0x8) {\n            autoAnimation = 3;\n        } else if (secondWord & 0x4) {\n            autoAnimation = 2;\n        }\n\n        // top half of second word is the palette index\n        const paletteIndex = (secondWord >> 8) & 0xff;\n\n        const horizontalFlip = !!(secondWord & 1);\n        const verticalFlip = !!(secondWord & 2);\n\n        tileData.push({\n            y: tileYs[w / 4],\n            tileIndex,\n            paletteIndex,\n            horizontalFlip,\n            verticalFlip,\n            autoAnimation\n        });\n    }\n\n    return tileData;\n}\n\nfunction transformY(rawY: number, yScale: number, spriteSize: number): number {\n    let fullmode;\n\n    if (spriteSize === 0x20) {\n        fullmode = 1;\n    } else if (spriteSize >= 0x21) {\n        fullmode = 2;\n    } else {\n        fullmode = 0;\n    }\n\n    // getting the final screen y is very complicated and\n    // honestly don't fully understand it. This code was copied\n    // from gngeo, video.c#draw_screen()\n    let y = 0x200 - rawY;\n\n    if (y > 0x110) {\n        y -= 0x200;\n    }\n\n    if (fullmode === 2 || (fullmode === 1 && yScale === 0xff)) {\n        while (y < 0) {\n            y += (yScale + 1) << 1;\n        }\n    }\n\n    return y;\n}\n\nfunction getYSpriteSizeSticky(\n    spriteIndex: number\n): { y: number; tileYs: number[]; spriteSize: number; sticky: boolean } {\n    if (spriteIndex < 0) {\n        throw new Error(\"getYSpriteSizeSticky: sprite index under zero!\");\n    }\n\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const scb3StartAddr = tileRamAddr + SCB3_BYTE_OFFSET;\n\n    const spriteScb3Addr = scb3StartAddr + spriteIndex * 2;\n\n    const scb3Word =\n        window.HEAPU8[spriteScb3Addr] |\n        (window.HEAPU8[spriteScb3Addr + 1] << 8);\n\n    const sticky = !!((scb3Word >> 6) & 1);\n\n    if (sticky) {\n        return {\n            ...getYSpriteSizeSticky(spriteIndex - 1),\n            sticky\n        };\n    } else {\n        const yScale = getScale(spriteIndex, { ignoreSticky: true }).yScale;\n        const spriteSize = scb3Word & 0x3f;\n        const rawY = scb3Word >> 7;\n\n        const y = transformY(rawY, yScale, spriteSize);\n        const tileYs = [];\n\n        for (let t = 0; t < spriteSize; ++t) {\n            tileYs.push((y + 16 * t) % 512);\n        }\n\n        return { y, tileYs, spriteSize, sticky };\n    }\n}\n\nfunction getX(spriteIndex: number): number {\n    if (spriteIndex < 0) {\n        throw new Error(\"getX: sprite index under zero!\");\n    }\n\n    const sticky = getYSpriteSizeSticky(spriteIndex).sticky;\n\n    let x;\n\n    if (sticky) {\n        const xScale = getScale(spriteIndex).xScale;\n        x = getX(spriteIndex - 1) + xScale;\n    } else {\n        const tileRamAddr = window.Module._get_tile_ram_addr();\n        const scb4StartAddr = tileRamAddr + SCB4_BYTE_OFFSET;\n\n        const spriteScb4Addr = scb4StartAddr + spriteIndex * 2;\n\n        const scb4Word =\n            window.HEAPU8[spriteScb4Addr] |\n            (window.HEAPU8[spriteScb4Addr + 1] << 8);\n\n        x = scb4Word >> 7;\n    }\n\n    if (x >= 0x1f0) {\n        x -= 0x200;\n    }\n\n    return x;\n}\n\nfunction getScale(\n    spriteIndex: number,\n    options?: { ignoreSticky: boolean }\n): { yScale: number; xScale: number } {\n    if (spriteIndex < 0) {\n        throw new Error(\"getScale: sprite index under zero!\");\n    }\n\n    if (!options || !options.ignoreSticky) {\n        const sticky = getYSpriteSizeSticky(spriteIndex).sticky;\n\n        if (sticky) {\n            return getScale(spriteIndex - 1);\n        }\n    }\n\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const scb2StartAddr = tileRamAddr + SCB2_BYTE_OFFSET;\n    const spriteScb2Addr = scb2StartAddr + spriteIndex * 2;\n\n    const scb2Word =\n        window.HEAPU8[spriteScb2Addr] |\n        (window.HEAPU8[spriteScb2Addr + 1] << 8);\n\n    const yScale = scb2Word & 0xff;\n    const xScale = ((scb2Word >> 8) & 0xf) + 1;\n\n    return { yScale, xScale };\n}\n\nexport function getSpriteData(\n    spriteIndex: number,\n    honorTileSize: boolean\n): SpriteData {\n    const { sticky, y, tileYs, spriteSize } = getYSpriteSizeSticky(spriteIndex);\n\n    return {\n        tiles: getTileData(\n            spriteIndex,\n            honorTileSize ? spriteSize : 32,\n            tileYs\n        ),\n        x: getX(spriteIndex),\n        sticky,\n        y,\n        spriteSize\n    };\n}\n\nexport function isSpriteEmpty(spriteIndex: number): boolean {\n    return getYSpriteSizeSticky(spriteIndex).spriteSize === 0;\n}\n","// each palette has 16 colors, each color is a 16 bit rgb value\nconst COLORS_PER_PALETTE = 16;\nconst PALETTE_SIZE_IN_BYTES = COLORS_PER_PALETTE * 2;\n\n/**\n * Convert from a neo geo palette color to a 32 rgb color\n * https://wiki.neogeodev.org/index.php?title=Colors\n */\nfunction convertNeoGeoColorToRGBColor(\n    col16: number\n): [number, number, number, number] {\n    // the least significant bit is shared by each channel\n    // if it is zero, the entire color is a tad darker, hence the name \"dark bit\"\n    const darkBit = (col16 >> 15) & 1;\n\n    const upperB = (col16 & 0xf) << 2;\n    const lowerB = ((col16 >> 12) & 1) << 1;\n    const b5 = upperB | lowerB | darkBit;\n\n    const upperG = ((col16 >> 4) & 0xf) << 2;\n    const lowerG = ((col16 >> 13) & 1) << 1;\n    const g5 = upperG | lowerG | darkBit;\n\n    const upperR = ((col16 >> 8) & 0xf) << 2;\n    const lowerR = ((col16 >> 14) & 1) << 1;\n    const r5 = upperR | lowerR | darkBit;\n\n    // neo geo color channels are six bits (max value of 63), but need to map\n    // them to a 8 bit color channel (max value of 255)\n    const b = (b5 / 63) * 255;\n    const g = (g5 / 63) * 255;\n    const r = (r5 / 63) * 255;\n\n    return [r, g, b, 255];\n}\n\nexport function getNeoGeoPalette(paletteMemoryIndex: number): number[] {\n    const palAddr = window.Module._get_current_pal_addr();\n    const palOffset = paletteMemoryIndex * PALETTE_SIZE_IN_BYTES;\n    const palIndexInHeap = (palAddr + palOffset) / 2;\n\n    return [\n        ...window.Module.HEAPU16.slice(\n            palIndexInHeap,\n            palIndexInHeap + COLORS_PER_PALETTE\n        )\n    ];\n}\n\nexport function convertNeoGeoPaletteToRGB(\n    neoGeoPalette: number[]\n): Array<[number, number, number, number]> {\n    const mapped = neoGeoPalette.map(convertNeoGeoColorToRGBColor);\n\n    // the first color is always transparent\n    return [[0, 0, 0, 0], ...mapped.slice(1)];\n}\n\nexport function getRgbFromNeoGeoPalette(\n    paletteIndex: number,\n    colorIndex: number\n): number[] {\n    if (colorIndex === 0) {\n        return [0, 0, 0, 0];\n    }\n\n    const palAddr = window.Module._get_current_pal_addr();\n    const palOffset = paletteIndex * PALETTE_SIZE_IN_BYTES;\n    const colorOffset = colorIndex * 2;\n\n    const color: number[] = [];\n\n    for (let i = 0; i < 2; ++i) {\n        color[i] = window.HEAPU8[palAddr + palOffset + colorOffset + i];\n    }\n\n    const combinedColor = color[0] | (color[1] << 8);\n\n    return convertNeoGeoColorToRGBColor(combinedColor);\n}\n\nexport function getBackdropNeoGeoColor(): number {\n    let palAddr = window.Module._get_current_pal_addr();\n\n    // get to the final color in all the palettes, ie the backdrop color\n    // https://wiki.neogeodev.org/index.php?title=Palettes\n    palAddr += 0x1ffe;\n\n    // since we are going to use HEAPU16, divide the address by two\n    palAddr /= 2;\n\n    return window.Module.HEAPU16[palAddr];\n}\n\nexport function neoGeoColorToCSS(neoGeoColor: number): string {\n    const asArray = convertNeoGeoColorToRGBColor(neoGeoColor);\n\n    return `rgb(${asArray[0]}, ${asArray[1]}, ${asArray[2]})`;\n}\n","import { ExtractedSpriteGroup, ExtractedSprite, ExtractedTile } from \"./types\";\nimport { getSpriteData, TileData } from \"./spriteData\";\nimport {\n    getNeoGeoPalette,\n    convertNeoGeoPaletteToRGB\n} from \"../palette/neoGeoPalette\";\n\nfunction convertTileDataToExtractedTile(tileData: TileData): ExtractedTile {\n    const { y, paletteIndex, ...rest } = tileData;\n    const neoGeoPalette = getNeoGeoPalette(tileData.paletteIndex);\n    const rgbPalette = convertNeoGeoPaletteToRGB(neoGeoPalette);\n\n    return {\n        ...rest,\n        composedY: y,\n        neoGeoPalette,\n        rgbPalette\n    };\n}\n\nfunction getSpriteGroup(spriteMemoryIndex: number): number[] {\n    let rootSpriteIndex = spriteMemoryIndex;\n\n    let spriteData = getSpriteData(rootSpriteIndex, true);\n\n    while (spriteData.sticky && rootSpriteIndex > 0) {\n        rootSpriteIndex -= 1;\n        spriteData = getSpriteData(rootSpriteIndex, true);\n    }\n\n    const spriteMemoryIndices = [];\n\n    do {\n        spriteMemoryIndices.push(rootSpriteIndex);\n        rootSpriteIndex += 1;\n        spriteData = getSpriteData(rootSpriteIndex, true);\n    } while (spriteData.sticky);\n\n    return spriteMemoryIndices;\n}\n\ntype ExtractedSpriteMinusGroup = Omit<ExtractedSprite, \"group\">;\n\nexport function extractSpriteGroup(\n    spriteMemoryIndex: number,\n    composedX: number,\n    pauseId: number\n): ExtractedSpriteGroup {\n    const allSpriteMemoryIndices = getSpriteGroup(spriteMemoryIndex);\n\n    const sprites: ExtractedSpriteMinusGroup[] = allSpriteMemoryIndices.map(\n        (smi, i) => {\n            const spriteData = getSpriteData(smi, true);\n            return {\n                spriteMemoryIndex: smi,\n                tiles: spriteData.tiles.map(convertTileDataToExtractedTile),\n                screenX: spriteData.x,\n                screenY: spriteData.y,\n                composedX: composedX + i * 16,\n                composedY: spriteData.y\n            };\n        }\n    );\n\n    const group: ExtractedSpriteGroup = {\n        pauseId,\n        sprites: sprites as ExtractedSprite[],\n        hidden: false\n    };\n\n    sprites.forEach(s => ((s as ExtractedSprite).group = group));\n\n    return group;\n}\n","import React, {\n    createContext,\n    useContext,\n    useReducer,\n    Dispatch,\n    FunctionComponent\n} from \"react\";\nimport {\n    AppState,\n    Crop,\n    Layer,\n    ExtractedSpriteGroup,\n    ExtractedSprite,\n    ExtractedTile\n} from \"./types\";\nimport { extractSpriteGroup } from \"./extractSpriteGroup\";\nimport { isEqual } from \"lodash\";\n\nexport interface Action {\n    type:\n        | \"StartEmulation\"\n        | \"TogglePause\"\n        | \"ExtractSprite\"\n        | \"HandleNegatives\"\n        | \"DeleteGroup\"\n        | \"ToggleVisibilityOfGroup\"\n        | \"NewLayer\"\n        | \"DeleteLayer\"\n        | \"ToggleVisibilityOfLayer\"\n        | \"SetFocusedLayer\"\n        | \"SetCrop\"\n        | \"ClearCrop\"\n        | \"ExtendLayerViaMirror\";\n}\n\nexport interface ExtractSpriteAction extends Action {\n    type: \"ExtractSprite\";\n    spriteMemoryIndex: number;\n    composedX: number;\n    pauseId?: number;\n}\n\nexport interface DeleteGroupAction extends Action {\n    type: \"DeleteGroup\";\n    group: ExtractedSpriteGroup;\n}\n\nexport interface ToggleVisibilityOfGroupAction extends Action {\n    type: \"ToggleVisibilityOfGroup\";\n    group: ExtractedSpriteGroup;\n}\n\nexport interface DeleteLayerAction extends Action {\n    type: \"DeleteLayer\";\n    layer: Layer;\n}\n\nexport interface ToggleVisibilityOfLayerAction extends Action {\n    type: \"ToggleVisibilityOfLayer\";\n    layer: Layer;\n}\n\nexport interface SetFocusedLayerAction extends Action {\n    type: \"SetFocusedLayer\";\n    layer: Layer;\n}\n\nexport interface SetCropAction extends Action {\n    type: \"SetCrop\";\n    crop: Crop;\n}\n\nexport interface ExtendLayerViaMirrorAction extends Action {\n    type: \"ExtendLayerViaMirror\";\n    layer: Layer;\n}\n\nexport const initialState: AppState = {\n    hasStarted: false,\n    isPaused: false,\n    pauseId: 0,\n    layers: [],\n    focusedLayerIndex: -1,\n    crop: undefined\n};\n\nfunction assertUnreachable(_: never): never {\n    throw new Error(\"Non exhaustive switch statement\");\n}\n\nfunction haveSameSprites(a: ExtractedSpriteGroup, b: ExtractedSpriteGroup) {\n    const aIndices = a.sprites.map(es => es.spriteMemoryIndex).sort();\n    const bIndices = b.sprites.map(es => es.spriteMemoryIndex).sort();\n\n    return isEqual(aIndices, bIndices);\n}\n\n/**\n * Given a newly formed sprite group, if there are other sprite groups already from the same pauseId,\n * then position this new group relative to them. This makes it so the user doesn't have to try and manually\n * line up groups.\n *\n * example: Samurai Shodown title screen. User drags in background, then drags in \"Samurai\" sprite, the \"Samurai\"\n * sprite will position itself properly on top of the background\n */\nfunction positionSpriteGroupInRelationToExistingGroups(\n    newGroup: ExtractedSpriteGroup,\n    oldGroups: ExtractedSpriteGroup[]\n) {\n    const sameGroup = oldGroups.find(og => og.pauseId === newGroup.pauseId);\n\n    // first sprite from this pauseId? Then there is nothing to position\n    if (!sameGroup) {\n        return;\n    }\n\n    const screenToComposeDiffX =\n        sameGroup.sprites[0].composedX - sameGroup.sprites[0].screenX;\n\n    newGroup.sprites.forEach(\n        s => (s.composedX = s.screenX + screenToComposeDiffX)\n    );\n}\n\nfunction moveRelatedGroups(\n    focusedGroup: ExtractedSpriteGroup,\n    allGroups: ExtractedSpriteGroup[],\n    newComposedX: number\n) {\n    const xDiff = newComposedX - focusedGroup.sprites[0].composedX;\n\n    const sameGroup = allGroups.filter(\n        sg => sg.pauseId === focusedGroup.pauseId\n    );\n\n    sameGroup.forEach(group => {\n        group.sprites.forEach(s => {\n            s.composedX += xDiff;\n        });\n    });\n}\n\n// TODO: make this create new groups and not mutate to support undo/redo in future\nfunction pushDownOutOfNegative(layers: Layer[]): Layer[] {\n    const groups = layers.reduce<ExtractedSpriteGroup[]>((gs, l) => {\n        return gs.concat(l.groups);\n    }, []);\n\n    const tiles = groups.reduce<ExtractedTile[]>((ts, sg) => {\n        const tiles = sg.sprites.reduce<ExtractedTile[]>((sts, s) => {\n            return sts.concat(s.tiles);\n        }, []);\n\n        return ts.concat(tiles);\n    }, []);\n\n    const mostNegative = Math.min(...tiles.map(t => t.composedY));\n\n    if (mostNegative < 0) {\n        const nudge = mostNegative * -1;\n\n        tiles.forEach(t => (t.composedY += nudge));\n    }\n\n    return layers;\n}\n\n// TODO: make this create new groups and not mutate to support undo/redo in future\nfunction pushInOutOfNegative(layers: Layer[]): Layer[] {\n    const groups = layers.reduce<ExtractedSpriteGroup[]>((gs, l) => {\n        return gs.concat(l.groups);\n    }, []);\n\n    const sprites = groups.reduce<ExtractedSprite[]>((ss, sg) => {\n        return ss.concat(sg.sprites);\n    }, []);\n\n    const mostNegative = Math.min(...sprites.map(s => s.composedX));\n\n    if (mostNegative < 0) {\n        const nudge = mostNegative * -1;\n\n        sprites.forEach(s => (s.composedX += nudge));\n    }\n\n    return layers;\n}\n\nfunction mirrorSpritesToRight(sprites: ExtractedSprite[]): ExtractedSprite[] {\n    const maxX = Math.max(...sprites.map(t => t.composedX)) + 16;\n\n    return sprites\n        .map(sprite => {\n            return {\n                ...sprite,\n                spriteMemoryIndex: sprite.spriteMemoryIndex,\n                composedX: 2 * maxX - (sprite.composedX + 16),\n                tiles: sprite.tiles.map(t => {\n                    return {\n                        ...t,\n                        horizontalFlip: !t.horizontalFlip\n                    };\n                })\n            };\n        })\n        .reverse();\n}\n\nfunction mirrorSpritesToLeft(sprites: ExtractedSprite[]): ExtractedSprite[] {\n    const minX = Math.min(...sprites.map(t => t.composedX));\n    const maxX = Math.max(...sprites.map(t => t.composedX)) + 16;\n    const width = maxX - minX;\n\n    return sprites\n        .map(sprite => {\n            return {\n                ...sprite,\n                spriteMemoryIndex: sprite.spriteMemoryIndex,\n                composedX: minX - width + (maxX - (sprite.composedX + 16)),\n                tiles: sprite.tiles.map(t => {\n                    return {\n                        ...t,\n                        horizontalFlip: !t.horizontalFlip\n                    };\n                })\n            };\n        })\n        .reverse();\n}\n\nfunction extendGroupsViaMirroring(\n    groups: ExtractedSpriteGroup[],\n    pauseId: number\n): ExtractedSpriteGroup[] {\n    const sprites = groups.reduce<ExtractedSprite[]>((ss, group) => {\n        return ss.concat(group.sprites);\n    }, []);\n\n    const rightMirror = mirrorSpritesToRight(sprites);\n    const leftMirror = mirrorSpritesToLeft(sprites);\n\n    const newLeftGroup = {\n        pauseId,\n        hidden: false,\n        sprites: leftMirror\n    };\n\n    const newRightGroup = {\n        pauseId,\n        hidden: false,\n        sprites: rightMirror\n    };\n\n    newLeftGroup.sprites.forEach(s => (s.group = newLeftGroup));\n    newRightGroup.sprites.forEach(s => (s.group = newRightGroup));\n\n    return [newLeftGroup, newRightGroup];\n}\n\nexport function reducer(state: AppState, action: Action): AppState {\n    switch (action.type) {\n        case \"StartEmulation\":\n            return {\n                ...state,\n                hasStarted: true\n            };\n\n        case \"TogglePause\":\n            const nowPaused = !state.isPaused;\n            return {\n                ...state,\n                isPaused: nowPaused,\n                pauseId: nowPaused ? state.pauseId + 1 : state.pauseId\n            };\n\n        // TODO: make this handler not mutate, to support undo/redo in the future\n        case \"ExtractSprite\":\n            const {\n                spriteMemoryIndex,\n                composedX,\n                pauseId\n            } = action as ExtractSpriteAction;\n\n            if (pauseId) {\n                const layer = state.layers[state.focusedLayerIndex];\n\n                if (!layer) {\n                    return state;\n                }\n\n                const currentSpriteGroup = layer.groups.find(sg => {\n                    return (\n                        sg.pauseId === pauseId &&\n                        sg.sprites.some(\n                            s => s.spriteMemoryIndex === spriteMemoryIndex\n                        )\n                    );\n                });\n\n                if (!currentSpriteGroup) {\n                    return state;\n                }\n\n                moveRelatedGroups(currentSpriteGroup, layer.groups, composedX);\n\n                return {\n                    ...state\n                };\n            } else {\n                const newSpriteGroup = extractSpriteGroup(\n                    spriteMemoryIndex,\n                    composedX,\n                    state.pauseId\n                );\n\n                const layer = state.layers[state.focusedLayerIndex] ||\n                    state.layers[state.layers.length - 1] || {\n                        groups: [newSpriteGroup],\n                        hidden: false\n                    };\n                const oldSpriteGroups = layer.groups.filter(\n                    esg =>\n                        esg.pauseId !== newSpriteGroup.pauseId ||\n                        !haveSameSprites(esg, newSpriteGroup)\n                );\n\n                // TODO: have this method not mutate to support undo/redo in the future\n                positionSpriteGroupInRelationToExistingGroups(\n                    newSpriteGroup,\n                    oldSpriteGroups\n                );\n\n                let layers;\n\n                if (state.layers.length === 0) {\n                    layers = [layer];\n                } else {\n                    layers = state.layers.map(l => {\n                        if (l === layer) {\n                            return {\n                                ...layer,\n                                groups: [...layer.groups, newSpriteGroup]\n                            };\n                        } else {\n                            return l;\n                        }\n                    });\n                }\n\n                return {\n                    ...state,\n                    layers,\n                    focusedLayerIndex:\n                        layers.length === 1 ? 0 : state.focusedLayerIndex\n                };\n            }\n\n        case \"HandleNegatives\":\n            return {\n                ...state,\n                layers: pushDownOutOfNegative(state.layers)\n            };\n\n        case \"DeleteGroup\": {\n            const { group } = action as DeleteGroupAction;\n\n            const layers = state.layers.map(layer => {\n                if (layer.groups.indexOf(group) > -1) {\n                    const groups = layer.groups.filter(g => g !== group);\n                    return {\n                        ...layer,\n                        groups\n                    };\n                } else {\n                    return layer;\n                }\n            });\n\n            return {\n                ...state,\n                layers\n            };\n        }\n        case \"ToggleVisibilityOfGroup\": {\n            const { group } = action as ToggleVisibilityOfGroupAction;\n\n            const layers = state.layers.map(layer => {\n                if (layer.groups.indexOf(group) > -1) {\n                    const groups = layer.groups.map(g => {\n                        if (g === group) {\n                            return {\n                                ...g,\n                                hidden: !g.hidden\n                            };\n                        } else {\n                            return g;\n                        }\n                    });\n                    return {\n                        ...layer,\n                        groups\n                    };\n                } else {\n                    return layer;\n                }\n            });\n\n            return {\n                ...state,\n                layers\n            };\n        }\n\n        case \"NewLayer\": {\n            return {\n                ...state,\n                layers: state.layers.concat({\n                    groups: [],\n                    hidden: false,\n                    extendedViaMirror: false\n                }),\n                focusedLayerIndex: state.layers.length\n            };\n        }\n\n        case \"DeleteLayer\": {\n            const { layer } = action as DeleteLayerAction;\n\n            return {\n                ...state,\n                layers: state.layers.filter(l => l !== layer),\n                focusedLayerIndex: -1\n            };\n        }\n\n        case \"ToggleVisibilityOfLayer\": {\n            const { layer } = action as DeleteLayerAction;\n\n            const layers = state.layers.map(l => {\n                if (l === layer) {\n                    return {\n                        ...l,\n                        hidden: !l.hidden\n                    };\n                } else {\n                    return l;\n                }\n            });\n\n            return {\n                ...state,\n                layers\n            };\n        }\n\n        case \"SetFocusedLayer\": {\n            const { layer } = action as SetFocusedLayerAction;\n\n            return {\n                ...state,\n                focusedLayerIndex: state.layers.indexOf(layer)\n            };\n        }\n\n        case \"SetCrop\": {\n            const { crop } = action as SetCropAction;\n\n            return {\n                ...state,\n                crop\n            };\n        }\n\n        case \"ClearCrop\": {\n            return {\n                ...state,\n                crop: undefined\n            };\n        }\n\n        case \"ExtendLayerViaMirror\": {\n            const { layer } = action as ExtendLayerViaMirrorAction;\n\n            const mirroredGroups = extendGroupsViaMirroring(\n                layer.groups,\n                state.pauseId\n            );\n\n            let layers = state.layers.concat({\n                groups: mirroredGroups,\n                hidden: false,\n                extendedViaMirror: false\n            });\n\n            layers = pushInOutOfNegative(layers);\n\n            return {\n                ...state,\n                layers\n            };\n        }\n    }\n\n    return assertUnreachable(action.type);\n}\n\nconst stateContext = createContext(initialState);\nconst dispatchContext = createContext((() => 0) as Dispatch<Action>);\n\nexport const Provider: FunctionComponent = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n        <dispatchContext.Provider value={dispatch}>\n            <stateContext.Provider value={state}>\n                {children}\n            </stateContext.Provider>\n        </dispatchContext.Provider>\n    );\n};\n\nexport function useAppState(): [AppState, Dispatch<Action>] {\n    return [useContext(stateContext), useContext(dispatchContext)];\n}\n\nexport const TOGGLE_PAUSE: Action = {\n    type: \"TogglePause\"\n};\n\nexport const START_EMULATION: Action = {\n    type: \"StartEmulation\"\n};\n\nexport function extractSpriteAction(\n    spriteMemoryIndex: number,\n    composedX: number,\n    pauseId: number\n): ExtractSpriteAction {\n    return {\n        type: \"ExtractSprite\",\n        spriteMemoryIndex,\n        composedX,\n        pauseId\n    };\n}\n\nexport const HANDLE_NEGATIVES: Action = {\n    type: \"HandleNegatives\"\n};\n\nexport function deleteGroupAction(\n    group: ExtractedSpriteGroup\n): DeleteGroupAction {\n    return {\n        type: \"DeleteGroup\",\n        group\n    };\n}\n\nexport function toggleVisiblityOfGroupAction(\n    group: ExtractedSpriteGroup\n): ToggleVisibilityOfGroupAction {\n    return {\n        type: \"ToggleVisibilityOfGroup\",\n        group\n    };\n}\n\nexport const NEW_LAYER: Action = {\n    type: \"NewLayer\"\n};\n\nexport function deleteLayerAction(layer: Layer): DeleteLayerAction {\n    return {\n        type: \"DeleteLayer\",\n        layer\n    };\n}\n\nexport function toggleVisiblityOfLayerAction(\n    layer: Layer\n): ToggleVisibilityOfLayerAction {\n    return {\n        type: \"ToggleVisibilityOfLayer\",\n        layer\n    };\n}\n\nexport function setFocusedLayerAction(layer: Layer): SetFocusedLayerAction {\n    return {\n        type: \"SetFocusedLayer\",\n        layer\n    };\n}\n\nexport function setCropAction(crop: Crop): SetCropAction {\n    return {\n        type: \"SetCrop\",\n        crop\n    };\n}\n\nexport const CLEAR_CROP: Action = {\n    type: \"ClearCrop\"\n};\n\nexport function extendLayerViaMirrorAction(\n    layer: Layer\n): ExtendLayerViaMirrorAction {\n    return {\n        type: \"ExtendLayerViaMirror\",\n        layer\n    };\n}\n","import React, { useState } from \"react\";\nimport classnames from \"classnames\";\nimport { useAppState, START_EMULATION, TOGGLE_PAUSE } from \"../state\";\n\nimport styles from \"./emulator.module.css\";\n\ninterface EmulatorProps {\n    className?: string;\n}\n\nfunction loadFile<T>(file: File): Promise<T> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.addEventListener(\"load\", () => {\n            if (reader.result) {\n                resolve((reader.result as unknown) as T);\n            } else {\n                reject(`Failed to load: ${file.name}`);\n            }\n        });\n\n        reader.readAsArrayBuffer(file);\n    });\n}\n\nasync function addFileToVirtualFS(file: File) {\n    const data: ArrayBuffer = await loadFile(file);\n\n    window.Module.FS_createDataFile(\n        \"/virtualfs\",\n        file.name,\n        new Uint8Array(data),\n        true,\n        true\n    );\n}\n\nexport const Emulator: React.FunctionComponent<EmulatorProps> = props => {\n    const [state, dispatch] = useAppState();\n    const [gameName, setGameName] = useState(\"\");\n\n    function togglePause() {\n        if (state.isPaused) {\n            window.Module.resumeMainLoop();\n        } else {\n            window.Module.pauseMainLoop();\n        }\n\n        dispatch(TOGGLE_PAUSE);\n    }\n\n    async function loadBiosFile(e: React.ChangeEvent<HTMLInputElement>) {\n        const file = e.target && e.target.files && e.target.files[0];\n\n        if (!file) {\n            return;\n        }\n\n        await addFileToVirtualFS(file);\n    }\n\n    async function loadROMFile(e: React.ChangeEvent<HTMLInputElement>) {\n        const file = e.target && e.target.files && e.target.files[0];\n\n        if (!file) {\n            return;\n        }\n\n        await addFileToVirtualFS(file);\n\n        const gameName = file.name.replace(\".zip\", \"\");\n\n        startGame(gameName);\n    }\n\n    function startGame(overrideGameName?: string) {\n        const argv = window.stackAlloc(3 * 4);\n\n        window.HEAP32[argv >> 2] = window.allocateUTF8OnStack(\"gngeo\");\n        window.HEAP32[(argv >> 2) + 1] = window.allocateUTF8OnStack(\n            overrideGameName || gameName\n        );\n        window.HEAP32[(argv >> 2) + 2] = 0;\n\n        dispatch(START_EMULATION);\n\n        try {\n            window.Module._run_rom(2, argv);\n        } catch (e) {\n            console.log(\"_run_rom threw\");\n        }\n    }\n\n    let debugButton = null;\n\n    if (process.env.NODE_ENV !== \"production\") {\n        debugButton = (\n            <button onClick={() => startGame(\"samsho2\")}>samsho2</button>\n        );\n    }\n\n    const classes = classnames(styles.root, props.className);\n\n    return (\n        <div className={classes}>\n            <canvas id=\"canvas\" />\n            <div>\n                BIOS\n                <input type=\"file\" onChange={loadBiosFile} />\n            </div>\n            <div>\n                ROM\n                <input type=\"file\" onChange={loadROMFile} />\n            </div>\n            {debugButton}\n            <button disabled={!state.hasStarted} onClick={togglePause}>\n                {state.isPaused ? \"resume\" : \"pause\"}\n            </button>\n        </div>\n    );\n};\n","// 16 rows, each row has 2 ints (32 bits each)\nconst TILE_SIZE_INTS = 2 * 16;\nconst TILE_SIZE_BYTES = TILE_SIZE_INTS * 4;\n\nconst map: Record<string, number> = {\n    0: 3,\n    1: 2,\n    2: 1,\n    3: 0,\n    4: 7,\n    5: 6,\n    6: 5,\n    7: 4\n};\n\nexport function renderTileToCanvas(\n    canvas: HTMLCanvasElement,\n    tileIndex: number,\n    rgbPalette: Array<[number, number, number, number]>\n) {\n    const cromAddr = window.Module._get_rom_ctile_addr();\n    const tileOffset = TILE_SIZE_BYTES * tileIndex;\n\n    const tileData: number[] = [];\n\n    for (let i = 0; i < TILE_SIZE_BYTES; ++i) {\n        tileData[i] = window.HEAPU8[cromAddr + tileOffset + i];\n    }\n\n    canvas.width = 16;\n    canvas.height = 16;\n\n    const context = canvas.getContext(\"2d\")!;\n\n    const imageData = context.getImageData(0, 0, 16, 16);\n\n    for (let y = 0; y < 16; ++y) {\n        for (let x = 0; x < 8; ++x) {\n            const pixelPair = tileData[y * 8 + map[x]];\n\n            const leftPixelColorIndex = (pixelPair >> 4) & 0xf;\n            const rightPixelColorIndex = pixelPair & 0xf;\n\n            const leftPixel = rgbPalette[leftPixelColorIndex];\n            const rightPixel = rgbPalette[rightPixelColorIndex];\n\n            for (let i = 0; i < leftPixel.length; ++i) {\n                imageData.data[(y * 16 + x * 2) * 4 + i] = leftPixel[i];\n                imageData.data[(y * 16 + x * 2 + 1) * 4 + i] = rightPixel[i];\n            }\n        }\n    }\n\n    context.putImageData(imageData, 0, 0);\n}\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { renderTileToCanvas } from \"../state/renderTileToCanvas\";\nimport {\n    getNeoGeoPalette,\n    convertNeoGeoPaletteToRGB\n} from \"../palette/neoGeoPalette\";\n\nimport styles from \"./tile.module.css\";\n\ninterface TileProps {\n    y: number;\n    tileIndex: number;\n    paletteIndex: number;\n    horizontalFlip?: boolean;\n    verticalFlip?: boolean;\n    positioned: boolean;\n}\n\nexport class Tile extends React.PureComponent<TileProps> {\n    render() {\n        const {\n            y: tileY,\n            tileIndex,\n            paletteIndex,\n            horizontalFlip,\n            verticalFlip,\n            positioned\n        } = this.props;\n\n        function renderCanvas(canvas: HTMLCanvasElement) {\n            const rgbPalette = convertNeoGeoPaletteToRGB(\n                getNeoGeoPalette(paletteIndex)\n            );\n            renderTileToCanvas(canvas, tileIndex, rgbPalette);\n        }\n\n        const horizontalScale = horizontalFlip ? -1 : 1;\n        const verticalScale = verticalFlip ? -1 : 1;\n\n        const inlineStyle = {\n            transform: `scale(${horizontalScale},${verticalScale})`,\n            top: tileY\n        };\n\n        const className = classnames({\n            [styles.positioned]: positioned\n        });\n\n        return (\n            <canvas\n                className={className}\n                ref={r => r && renderCanvas(r)}\n                style={inlineStyle}\n            />\n        );\n    }\n}\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { useDrag } from \"react-dnd\";\nimport { Tile } from \"./tile\";\nimport { getSpriteData } from \"../state/spriteData\";\n\nimport styles from \"./sprite.module.css\";\n\ninterface SpriteProps {\n    className?: string;\n    spriteIndex: number;\n    positioned: boolean;\n    overrideX?: number;\n    honorTileSize: boolean;\n}\n\ninterface PreviewProps {\n    connect: any;\n}\n\nexport const Sprite: React.FunctionComponent<SpriteProps> = ({\n    className,\n    spriteIndex,\n    positioned,\n    overrideX,\n    honorTileSize\n}) => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [_, dragRef] = useDrag({\n        item: { spriteIndex, type: \"Sprite\" }\n    });\n\n    const spriteData = getSpriteData(spriteIndex, honorTileSize);\n\n    if (spriteData.tiles.length === 0) {\n        return null;\n    }\n\n    const tiles = spriteData.tiles.map((tileData, i) => (\n        <Tile\n            key={i}\n            positioned={positioned}\n            y={tileData.y - spriteData.y}\n            tileIndex={tileData.tileIndex}\n            paletteIndex={tileData.paletteIndex}\n            horizontalFlip={tileData.horizontalFlip}\n            verticalFlip={tileData.verticalFlip}\n        />\n    ));\n\n    const style = {\n        top: spriteData.y,\n        left: typeof overrideX === \"number\" ? overrideX : spriteData.x,\n        gridTemplateRows: `repeat(${spriteData.tiles.length}, 16px)`,\n        zIndex: spriteIndex\n    };\n\n    const spriteClassName = classnames(styles.sprite, className, {\n        [styles.positioned]: positioned\n    });\n\n    return (\n        <div ref={dragRef} className={spriteClassName} style={style}>\n            {tiles}\n        </div>\n    );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { Sprite } from \"./sprite\";\nimport { isSpriteEmpty } from \"../state/spriteData\";\n\nimport styles from \"./spriteEntry.module.css\";\n\ninterface SpriteEntryProps {\n    className?: string;\n    spriteIndex: number;\n    render?: boolean;\n    hideIfEmpty: boolean;\n    focused?: boolean;\n    honorTileSize: boolean;\n    onClick: (e: React.MouseEvent<HTMLDivElement>) => void;\n}\n\nexport const SpriteEntry: React.FunctionComponent<SpriteEntryProps> = ({\n    className,\n    spriteIndex,\n    render,\n    hideIfEmpty,\n    focused,\n    honorTileSize,\n    onClick\n}) => {\n    const classes = classnames(styles.root, className, {\n        [styles.hide]: render && hideIfEmpty && isSpriteEmpty(spriteIndex),\n        [styles.focused]: focused\n    });\n\n    return (\n        <div className={classes} onClick={onClick}>\n            <div className={styles.index}>{spriteIndex}</div>\n            <div className={styles.spriteContainer}>\n                {render && (\n                    <Sprite\n                        className={styles.sprite}\n                        spriteIndex={spriteIndex}\n                        positioned={false}\n                        honorTileSize={honorTileSize}\n                    />\n                )}\n            </div>\n        </div>\n    );\n};\n","import React, { useState } from \"react\";\nimport classnames from \"classnames\";\nimport { SpriteEntry } from \"./spriteEntry\";\nimport { useAppState } from \"../state\";\n\nimport styles from \"./spriteTray.module.css\";\n\nconst TOTAL_SPRITE_COUNT = 381;\n\nfunction arrayFrom(minValue: number, maxValue: number) {\n    const count = maxValue - minValue + 1;\n\n    return new Array(count).fill(0, 0, count).map((_, i) => i + minValue);\n}\n\ninterface SpriteTrayProps {\n    className?: string;\n}\n\nexport const SpriteTray: React.FunctionComponent<SpriteTrayProps> = ({\n    className\n}) => {\n    const [state] = useAppState();\n    const [focusedIndices, setFocusedIndices] = useState<number[]>([]);\n    const [shiftStartIndex, setShiftStartIndex] = useState<null | number>(null);\n\n    const classes = classnames(styles.root, className, {\n        [styles.locked]: !state.isPaused\n    });\n\n    return (\n        <div className={classes}>\n            <div\n                key={state.pauseId}\n                className={styles.spriteEntries}\n                style={{\n                    gridTemplateColumns: `repeat(${TOTAL_SPRITE_COUNT}, max-content)`\n                }}\n            >\n                {new Array(TOTAL_SPRITE_COUNT)\n                    .fill(1, 0, TOTAL_SPRITE_COUNT)\n                    .map((_, i) => (\n                        <SpriteEntry\n                            key={i}\n                            spriteIndex={i}\n                            render={state.isPaused}\n                            hideIfEmpty\n                            onClick={e => {\n                                if (e.ctrlKey) {\n                                    setFocusedIndices(focusedIndices.concat(i));\n                                    setShiftStartIndex(null);\n                                } else if (e.shiftKey) {\n                                    if (\n                                        shiftStartIndex !== null ||\n                                        focusedIndices.length === 1\n                                    ) {\n                                        const minIndex = Math.min(\n                                            shiftStartIndex ||\n                                                focusedIndices[0],\n                                            i\n                                        );\n                                        const maxIndex = Math.max(\n                                            shiftStartIndex ||\n                                                focusedIndices[0],\n                                            i\n                                        );\n                                        setFocusedIndices(\n                                            arrayFrom(minIndex, maxIndex)\n                                        );\n                                    } else {\n                                        setFocusedIndices([i]);\n                                        setShiftStartIndex(i);\n                                    }\n                                } else {\n                                    setFocusedIndices([i]);\n                                    setShiftStartIndex(null);\n                                }\n                            }}\n                            focused={focusedIndices.indexOf(i) > -1}\n                            honorTileSize\n                        />\n                    ))}\n            </div>\n        </div>\n    );\n};\n","import React from \"react\";\nimport { renderTileToCanvas } from \"../state/renderTileToCanvas\";\n\nimport styles from \"./extractedTile.module.css\";\n\ninterface ExtractedTileProps {\n    y: number;\n    tileIndex: number;\n    rgbPalette: Array<[number, number, number, number]>;\n    horizontalFlip?: boolean;\n    verticalFlip?: boolean;\n}\n\nexport class ExtractedTile extends React.PureComponent<ExtractedTileProps> {\n    render() {\n        const {\n            y: tileY,\n            tileIndex,\n            rgbPalette,\n            horizontalFlip,\n            verticalFlip\n        } = this.props;\n\n        function renderCanvas(canvas: HTMLCanvasElement) {\n            renderTileToCanvas(canvas, tileIndex, rgbPalette);\n        }\n\n        const horizontalScale = horizontalFlip ? -1 : 1;\n        const verticalScale = verticalFlip ? -1 : 1;\n\n        const inlineStyle = {\n            transform: `scale(${horizontalScale},${verticalScale})`,\n            top: tileY\n        };\n\n        return (\n            <canvas\n                className={styles.root}\n                ref={r => r && renderCanvas(r)}\n                style={inlineStyle}\n            />\n        );\n    }\n}\n","import React from \"react\";\nimport { useDrag } from \"react-dnd\";\nimport { ExtractedSprite as ExtractedSpriteData } from \"../state/types\";\nimport { ExtractedTile } from \"./extractedTile\";\n\nimport styles from \"./extractedSprite.module.css\";\n\ninterface ExtractedSpriteProps {\n    data: ExtractedSpriteData;\n    autoAnimate?: boolean;\n    animationCounter?: number;\n    canDrag: boolean;\n}\n\nexport const ExtractedSprite: React.FunctionComponent<ExtractedSpriteProps> = ({\n    data,\n    autoAnimate,\n    animationCounter,\n    canDrag\n}) => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [_, dragRef] = useDrag({\n        item: {\n            spriteIndex: data.spriteMemoryIndex,\n            pauseId: data.group.pauseId,\n            type: \"Sprite\"\n        },\n        canDrag() {\n            return canDrag;\n        }\n    });\n\n    const tiles = data.tiles.map((tileData, i) => {\n        let tileIndex = tileData.tileIndex;\n\n        if (autoAnimate && typeof animationCounter === \"number\") {\n            if (tileData.autoAnimation === 3) {\n                // 3 bit auto animation: the 4th bit is set, indicating this tile does 3bit auto animation\n                // that means take its tileIndex, and replace its bottom three bits with those of the animation counter\n                tileIndex =\n                    (tileIndex & ~7) + ((tileIndex + animationCounter) & 7);\n            }\n            if (tileData.autoAnimation === 2) {\n                // 2 bit auto animation: like above but replace its bottom two bits\n                tileIndex =\n                    (tileIndex & ~3) + ((tileIndex + animationCounter) & 3);\n            }\n        }\n\n        return (\n            <ExtractedTile\n                key={i}\n                y={tileData.composedY - data.composedY}\n                tileIndex={tileIndex}\n                rgbPalette={tileData.rgbPalette}\n                horizontalFlip={tileData.horizontalFlip}\n                verticalFlip={tileData.verticalFlip}\n            />\n        );\n    });\n\n    const style = {\n        top: data.composedY,\n        left: data.composedX,\n        gridTemplateRows: `repeat(${data.tiles.length}, 16px)`,\n        zIndex: data.spriteMemoryIndex\n    };\n\n    return (\n        <div ref={dragRef} className={styles.root} style={style}>\n            {tiles}\n        </div>\n    );\n};\n","/**\n * This class handles LZW encoding\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nexport const LZWEncoder = function() {\n    var exports = {};\n    var EOF = -1;\n    var imgW;\n    var imgH;\n    var pixAry;\n    var initCodeSize;\n    var remaining;\n    var curPixel;\n\n    // GIFCOMPR.C - GIF Image compression routines\n    // Lempel-Ziv compression based on 'compress'. GIF modifications by\n    // David Rowley (mgardi@watdcsu.waterloo.edu)\n    // General DEFINEs\n\n    var BITS = 12;\n    var HSIZE = 5003; // 80% occupancy\n\n    // GIF Image compression - modified 'compress'\n    // Based on: compress.c - File compression ala IEEE Computer, June 1984.\n    // By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n    // Jim McKie (decvax!mcvax!jim)\n    // Steve Davies (decvax!vax135!petsd!peora!srd)\n    // Ken Turkowski (decvax!decwrl!turtlevax!ken)\n    // James A. Woods (decvax!ihnp4!ames!jaw)\n    // Joe Orost (decvax!vax135!petsd!joe)\n\n    var n_bits; // number of bits/code\n    var maxbits = BITS; // user settable max # bits/code\n    var maxcode; // maximum code, given n_bits\n    var maxmaxcode = 1 << BITS; // should NEVER generate this code\n    var htab = [];\n    var codetab = [];\n    var hsize = HSIZE; // for dynamic table sizing\n    var free_ent = 0; // first unused entry\n\n    // block compression parameters -- after all codes are used up,\n    // and compression rate changes, start over.\n\n    var clear_flg = false;\n\n    // Algorithm: use open addressing double hashing (no chaining) on the\n    // prefix code / next character combination. We do a variant of Knuth's\n    // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n    // secondary probe. Here, the modular division first probe is gives way\n    // to a faster exclusive-or manipulation. Also do block compression with\n    // an adaptive reset, whereby the code table is cleared when the compression\n    // ratio decreases, but after the table fills. The variable-length output\n    // codes are re-sized at this point, and a special CLEAR code is generated\n    // for the decompressor. Late addition: construct the table according to\n    // file size for noticeable speed improvement on small files. Please direct\n    // questions about this implementation to ames!jaw.\n\n    var g_init_bits;\n    var ClearCode;\n    var EOFCode;\n\n    // output\n    // Output the given code.\n    // Inputs:\n    // code: A n_bits-bit integer. If == -1, then EOF. This assumes\n    // that n_bits =< wordsize - 1.\n    // Outputs:\n    // Outputs code to the file.\n    // Assumptions:\n    // Chars are 8 bits long.\n    // Algorithm:\n    // Maintain a BITS character long buffer (so that 8 codes will\n    // fit in it exactly). Use the VAX insv instruction to insert each\n    // code in turn. When the buffer fills up empty it and start over.\n\n    var cur_accum = 0;\n    var cur_bits = 0;\n    var masks = [\n        0x0000,\n        0x0001,\n        0x0003,\n        0x0007,\n        0x000f,\n        0x001f,\n        0x003f,\n        0x007f,\n        0x00ff,\n        0x01ff,\n        0x03ff,\n        0x07ff,\n        0x0fff,\n        0x1fff,\n        0x3fff,\n        0x7fff,\n        0xffff\n    ];\n\n    // Number of characters so far in this 'packet'\n    var a_count;\n\n    // Define the storage for the packet accumulator\n    var accum = [];\n\n    var LZWEncoder = (exports.LZWEncoder = function LZWEncoder(\n        width,\n        height,\n        pixels,\n        color_depth\n    ) {\n        imgW = width;\n        imgH = height;\n        pixAry = pixels;\n        initCodeSize = Math.max(2, color_depth);\n    });\n\n    // Add a character to the end of the current packet, and if it is 254\n    // characters, flush the packet to disk.\n    var char_out = function char_out(c, outs) {\n        accum[a_count++] = c;\n        if (a_count >= 254) flush_char(outs);\n    };\n\n    // Clear out the hash table\n    // table clear for block compress\n\n    var cl_block = function cl_block(outs) {\n        cl_hash(hsize);\n        free_ent = ClearCode + 2;\n        clear_flg = true;\n        output(ClearCode, outs);\n    };\n\n    // reset code table\n    var cl_hash = function cl_hash(hsize) {\n        for (var i = 0; i < hsize; ++i) htab[i] = -1;\n    };\n\n    var compress = (exports.compress = function compress(init_bits, outs) {\n        var fcode;\n        var i; /* = 0 */\n        var c;\n        var ent;\n        var disp;\n        var hsize_reg;\n        var hshift;\n\n        // Set up the globals: g_init_bits - initial number of bits\n        g_init_bits = init_bits;\n\n        // Set up the necessary values\n        clear_flg = false;\n        n_bits = g_init_bits;\n        maxcode = MAXCODE(n_bits);\n\n        ClearCode = 1 << (init_bits - 1);\n        EOFCode = ClearCode + 1;\n        free_ent = ClearCode + 2;\n\n        a_count = 0; // clear packet\n\n        ent = nextPixel();\n\n        hshift = 0;\n        for (fcode = hsize; fcode < 65536; fcode *= 2) ++hshift;\n        hshift = 8 - hshift; // set hash code range bound\n\n        hsize_reg = hsize;\n        cl_hash(hsize_reg); // clear hash table\n\n        output(ClearCode, outs);\n\n        outer_loop: while ((c = nextPixel()) != EOF) {\n            fcode = (c << maxbits) + ent;\n            i = (c << hshift) ^ ent; // xor hashing\n\n            if (htab[i] == fcode) {\n                ent = codetab[i];\n                continue;\n            } else if (htab[i] >= 0) {\n                // non-empty slot\n\n                disp = hsize_reg - i; // secondary hash (after G. Knott)\n                if (i === 0) disp = 1;\n\n                do {\n                    if ((i -= disp) < 0) i += hsize_reg;\n\n                    if (htab[i] == fcode) {\n                        ent = codetab[i];\n                        continue outer_loop;\n                    }\n                } while (htab[i] >= 0);\n            }\n\n            output(ent, outs);\n            ent = c;\n            if (free_ent < maxmaxcode) {\n                codetab[i] = free_ent++; // code -> hashtable\n                htab[i] = fcode;\n            } else cl_block(outs);\n        }\n\n        // Put out the final code.\n        output(ent, outs);\n        output(EOFCode, outs);\n    });\n\n    // ----------------------------------------------------------------------------\n    var encode = (exports.encode = function encode(os) {\n        os.writeByte(initCodeSize); // write \"initial code size\" byte\n        remaining = imgW * imgH; // reset navigation variables\n        curPixel = 0;\n        compress(initCodeSize + 1, os); // compress and write the pixel data\n        os.writeByte(0); // write block terminator\n    });\n\n    // Flush the packet to disk, and reset the accumulator\n    var flush_char = function flush_char(outs) {\n        if (a_count > 0) {\n            outs.writeByte(a_count);\n            outs.writeBytes(accum, 0, a_count);\n            a_count = 0;\n        }\n    };\n\n    var MAXCODE = function MAXCODE(n_bits) {\n        return (1 << n_bits) - 1;\n    };\n\n    // ----------------------------------------------------------------------------\n    // Return the next pixel from the image\n    // ----------------------------------------------------------------------------\n\n    var nextPixel = function nextPixel() {\n        if (remaining === 0) return EOF;\n        --remaining;\n        var pix = pixAry[curPixel++];\n        return pix & 0xff;\n    };\n\n    var output = function output(code, outs) {\n        cur_accum &= masks[cur_bits];\n\n        if (cur_bits > 0) cur_accum |= code << cur_bits;\n        else cur_accum = code;\n\n        cur_bits += n_bits;\n\n        while (cur_bits >= 8) {\n            char_out(cur_accum & 0xff, outs);\n            cur_accum >>= 8;\n            cur_bits -= 8;\n        }\n\n        // If the next entry is going to be too big for the code size,\n        // then increase it, if possible.\n\n        if (free_ent > maxcode || clear_flg) {\n            if (clear_flg) {\n                maxcode = MAXCODE((n_bits = g_init_bits));\n                clear_flg = false;\n            } else {\n                ++n_bits;\n                if (n_bits == maxbits) maxcode = maxmaxcode;\n                else maxcode = MAXCODE(n_bits);\n            }\n        }\n\n        if (code == EOFCode) {\n            // At EOF, write the rest of the buffer.\n            while (cur_bits > 0) {\n                char_out(cur_accum & 0xff, outs);\n                cur_accum >>= 8;\n                cur_bits -= 8;\n            }\n\n            flush_char(outs);\n        }\n    };\n\n    LZWEncoder.apply(this, arguments);\n    return exports;\n};\n","/*\n * NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n\n/*\n * This class handles Neural-Net quantization algorithm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nexport const NeuQuant = function() {\n    var exports = {};\n    var netsize = 256; /* number of colours used */\n\n    /* four primes near 500 - assume no image has a length so large */\n    /* that it is divisible by all four primes */\n\n    var prime1 = 499;\n    var prime2 = 491;\n    var prime3 = 487;\n    var prime4 = 503;\n    var minpicturebytes = 3 * prime4; /* minimum size for input image */\n\n    /*\n     * Program Skeleton ---------------- [select samplefac in range 1..30] [read\n     * image from input file] pic = (unsigned char*) malloc(3*width*height);\n     * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\n     * image header, using writecolourmap(f)] inxbuild(); write output image using\n     * inxsearch(b,g,r)\n     */\n\n    /*\n     * Network Definitions -------------------\n     */\n\n    var maxnetpos = netsize - 1;\n    var netbiasshift = 4; /* bias for colour values */\n    var ncycles = 100; /* no. of learning cycles */\n\n    /* defs for freq and bias */\n    var intbiasshift = 16; /* bias for fractions */\n    var intbias = 1 << intbiasshift;\n    var gammashift = 10; /* gamma = 1024 */\n    var gamma = 1 << gammashift;\n    var betashift = 10;\n    var beta = intbias >> betashift; /* beta = 1/1024 */\n    var betagamma = intbias << (gammashift - betashift);\n\n    /* defs for decreasing radius factor */\n    var initrad = netsize >> 3; /* for 256 cols, radius starts */\n    var radiusbiasshift = 6; /* at 32.0 biased by 6 bits */\n    var radiusbias = 1 << radiusbiasshift;\n    var initradius = initrad * radiusbias; /* and decreases by a */\n    var radiusdec = 30; /* factor of 1/30 each cycle */\n\n    /* defs for decreasing alpha factor */\n    var alphabiasshift = 10; /* alpha starts at 1.0 */\n    var initalpha = 1 << alphabiasshift;\n    var alphadec; /* biased by 10 bits */\n\n    /* radbias and alpharadbias used for radpower calculation */\n    var radbiasshift = 8;\n    var radbias = 1 << radbiasshift;\n    var alpharadbshift = alphabiasshift + radbiasshift;\n    var alpharadbias = 1 << alpharadbshift;\n\n    /*\n     * Types and Global Variables --------------------------\n     */\n\n    var thepicture; /* the input image itself */\n    var lengthcount; /* lengthcount = H*W*3 */\n    var samplefac; /* sampling factor 1..30 */\n\n    // typedef int pixel[4]; /* BGRc */\n    var network; /* the network itself - [netsize][4] */\n    var netindex = [];\n\n    /* for network lookup - really 256 */\n    var bias = [];\n\n    /* bias and freq arrays for learning */\n    var freq = [];\n    var radpower = [];\n\n    var NeuQuant = (exports.NeuQuant = function NeuQuant(thepic, len, sample) {\n        var i;\n        var p;\n\n        thepicture = thepic;\n        lengthcount = len;\n        samplefac = sample;\n\n        network = new Array(netsize);\n\n        for (i = 0; i < netsize; i++) {\n            network[i] = new Array(4);\n            p = network[i];\n            p[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\n            freq[i] = intbias / netsize; /* 1/netsize */\n            bias[i] = 0;\n        }\n    });\n\n    var colorMap = function colorMap() {\n        var map = [];\n        var index = new Array(netsize);\n\n        for (var i = 0; i < netsize; i++) index[network[i][3]] = i;\n\n        var k = 0;\n        for (var l = 0; l < netsize; l++) {\n            var j = index[l];\n            map[k++] = network[j][0];\n            map[k++] = network[j][1];\n            map[k++] = network[j][2];\n        }\n\n        return map;\n    };\n\n    /*\n     * Insertion sort of network and building of netindex[0..255] (to do after\n     * unbias)\n     * -------------------------------------------------------------------------------\n     */\n\n    var inxbuild = function inxbuild() {\n        var i;\n        var j;\n        var smallpos;\n        var smallval;\n        var p;\n        var q;\n        var previouscol;\n        var startpos;\n\n        previouscol = 0;\n        startpos = 0;\n        for (i = 0; i < netsize; i++) {\n            p = network[i];\n            smallpos = i;\n            smallval = p[1]; /* index on g */\n\n            /* find smallest in i..netsize-1 */\n            for (j = i + 1; j < netsize; j++) {\n                q = network[j];\n                if (q[1] < smallval) {\n                    /* index on g */\n                    smallpos = j;\n                    smallval = q[1]; /* index on g */\n                }\n            }\n            q = network[smallpos];\n\n            /* swap p (i) and q (smallpos) entries */\n            if (i != smallpos) {\n                j = q[0];\n                q[0] = p[0];\n                p[0] = j;\n                j = q[1];\n                q[1] = p[1];\n                p[1] = j;\n                j = q[2];\n                q[2] = p[2];\n                p[2] = j;\n                j = q[3];\n                q[3] = p[3];\n                p[3] = j;\n            }\n\n            /* smallval entry is now in position i */\n\n            if (smallval != previouscol) {\n                netindex[previouscol] = (startpos + i) >> 1;\n\n                for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n\n                previouscol = smallval;\n                startpos = i;\n            }\n        }\n\n        netindex[previouscol] = (startpos + maxnetpos) >> 1;\n        for (j = previouscol + 1; j < 256; j++)\n            netindex[j] = maxnetpos; /* really 256 */\n    };\n\n    /*\n     * Main Learning Loop ------------------\n     */\n\n    var learn = function learn() {\n        var i;\n        var j;\n        var b;\n        var g;\n        var r;\n        var radius;\n        var rad;\n        var alpha;\n        var step;\n        var delta;\n        var samplepixels;\n        var p;\n        var pix;\n        var lim;\n\n        if (lengthcount < minpicturebytes) samplefac = 1;\n\n        alphadec = 30 + (samplefac - 1) / 3;\n        p = thepicture;\n        pix = 0;\n        lim = lengthcount;\n        samplepixels = lengthcount / (3 * samplefac);\n        delta = (samplepixels / ncycles) | 0;\n        alpha = initalpha;\n        radius = initradius;\n\n        rad = radius >> radiusbiasshift;\n        if (rad <= 1) rad = 0;\n\n        for (i = 0; i < rad; i++)\n            radpower[i] =\n                alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n\n        if (lengthcount < minpicturebytes) step = 3;\n        else if (lengthcount % prime1 !== 0) step = 3 * prime1;\n        else {\n            if (lengthcount % prime2 !== 0) step = 3 * prime2;\n            else {\n                if (lengthcount % prime3 !== 0) step = 3 * prime3;\n                else step = 3 * prime4;\n            }\n        }\n\n        i = 0;\n        while (i < samplepixels) {\n            b = (p[pix + 0] & 0xff) << netbiasshift;\n            g = (p[pix + 1] & 0xff) << netbiasshift;\n            r = (p[pix + 2] & 0xff) << netbiasshift;\n            j = contest(b, g, r);\n\n            altersingle(alpha, j, b, g, r);\n            if (rad !== 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\n\n            pix += step;\n            if (pix >= lim) pix -= lengthcount;\n\n            i++;\n\n            if (delta === 0) delta = 1;\n\n            if (i % delta === 0) {\n                alpha -= alpha / alphadec;\n                radius -= radius / radiusdec;\n                rad = radius >> radiusbiasshift;\n\n                if (rad <= 1) rad = 0;\n\n                for (j = 0; j < rad; j++)\n                    radpower[j] =\n                        alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n            }\n        }\n    };\n\n    /*\n     ** Search for BGR values 0..255 (after net is unbiased) and return colour\n     * index\n     * ----------------------------------------------------------------------------\n     */\n\n    var map = (exports.map = function map(b, g, r) {\n        var i;\n        var j;\n        var dist;\n        var a;\n        var bestd;\n        var p;\n        var best;\n\n        bestd = 1000; /* biggest possible dist is 256*3 */\n        best = -1;\n        i = netindex[g]; /* index on g */\n        j = i - 1; /* start at netindex[g] and work outwards */\n\n        while (i < netsize || j >= 0) {\n            if (i < netsize) {\n                p = network[i];\n                dist = p[1] - g; /* inx key */\n\n                if (dist >= bestd) i = netsize;\n                /* stop iter */ else {\n                    i++;\n                    if (dist < 0) dist = -dist;\n                    a = p[0] - b;\n                    if (a < 0) a = -a;\n                    dist += a;\n\n                    if (dist < bestd) {\n                        a = p[2] - r;\n                        if (a < 0) a = -a;\n                        dist += a;\n\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n                }\n            }\n\n            if (j >= 0) {\n                p = network[j];\n                dist = g - p[1]; /* inx key - reverse dif */\n\n                if (dist >= bestd) j = -1;\n                /* stop iter */ else {\n                    j--;\n                    if (dist < 0) dist = -dist;\n                    a = p[0] - b;\n                    if (a < 0) a = -a;\n                    dist += a;\n\n                    if (dist < bestd) {\n                        a = p[2] - r;\n                        if (a < 0) a = -a;\n                        dist += a;\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n                }\n            }\n        }\n\n        return best;\n    });\n\n    var process = (exports.process = function process() {\n        learn();\n        unbiasnet();\n        inxbuild();\n        return colorMap();\n    });\n\n    /*\n     * Unbias network to give byte values 0..255 and record position i to prepare\n     * for sort\n     * -----------------------------------------------------------------------------------\n     */\n\n    var unbiasnet = function unbiasnet() {\n        var i;\n        var j;\n\n        for (i = 0; i < netsize; i++) {\n            network[i][0] >>= netbiasshift;\n            network[i][1] >>= netbiasshift;\n            network[i][2] >>= netbiasshift;\n            network[i][3] = i; /* record colour no */\n        }\n    };\n\n    /*\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\n     * radpower[|i-j|]\n     * ---------------------------------------------------------------------------------\n     */\n\n    var alterneigh = function alterneigh(rad, i, b, g, r) {\n        var j;\n        var k;\n        var lo;\n        var hi;\n        var a;\n        var m;\n        var p;\n\n        lo = i - rad;\n        if (lo < -1) lo = -1;\n\n        hi = i + rad;\n        if (hi > netsize) hi = netsize;\n\n        j = i + 1;\n        k = i - 1;\n        m = 1;\n\n        while (j < hi || k > lo) {\n            a = radpower[m++];\n\n            if (j < hi) {\n                p = network[j++];\n\n                try {\n                    p[0] -= (a * (p[0] - b)) / alpharadbias;\n                    p[1] -= (a * (p[1] - g)) / alpharadbias;\n                    p[2] -= (a * (p[2] - r)) / alpharadbias;\n                } catch (e) {} // prevents 1.3 miscompilation\n            }\n\n            if (k > lo) {\n                p = network[k--];\n\n                try {\n                    p[0] -= (a * (p[0] - b)) / alpharadbias;\n                    p[1] -= (a * (p[1] - g)) / alpharadbias;\n                    p[2] -= (a * (p[2] - r)) / alpharadbias;\n                } catch (e) {}\n            }\n        }\n    };\n\n    /*\n     * Move neuron i towards biased (b,g,r) by factor alpha\n     * ----------------------------------------------------\n     */\n\n    var altersingle = function altersingle(alpha, i, b, g, r) {\n        /* alter hit neuron */\n        var n = network[i];\n        n[0] -= (alpha * (n[0] - b)) / initalpha;\n        n[1] -= (alpha * (n[1] - g)) / initalpha;\n        n[2] -= (alpha * (n[2] - r)) / initalpha;\n    };\n\n    /*\n     * Search for biased BGR values ----------------------------\n     */\n\n    var contest = function contest(b, g, r) {\n        /* finds closest neuron (min dist) and updates freq */\n        /* finds best neuron (min dist-bias) and returns position */\n        /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\n        /* bias[i] = gamma*((1/netsize)-freq[i]) */\n\n        var i;\n        var dist;\n        var a;\n        var biasdist;\n        var betafreq;\n        var bestpos;\n        var bestbiaspos;\n        var bestd;\n        var bestbiasd;\n        var n;\n\n        bestd = ~(1 << 31);\n        bestbiasd = bestd;\n        bestpos = -1;\n        bestbiaspos = bestpos;\n\n        for (i = 0; i < netsize; i++) {\n            n = network[i];\n            dist = n[0] - b;\n            if (dist < 0) dist = -dist;\n            a = n[1] - g;\n            if (a < 0) a = -a;\n            dist += a;\n            a = n[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n                bestd = dist;\n                bestpos = i;\n            }\n\n            biasdist = dist - (bias[i] >> (intbiasshift - netbiasshift));\n\n            if (biasdist < bestbiasd) {\n                bestbiasd = biasdist;\n                bestbiaspos = i;\n            }\n\n            betafreq = freq[i] >> betashift;\n            freq[i] -= betafreq;\n            bias[i] += betafreq << gammashift;\n        }\n\n        freq[bestpos] += beta;\n        bias[bestpos] -= betagamma;\n        return bestbiaspos;\n    };\n\n    NeuQuant.apply(this, arguments);\n    return exports;\n};\n","/**\n * This class lets you encode animated GIF files\n * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nimport { LZWEncoder } from \"./LZWEncoder\";\nimport { NeuQuant } from \"./NeuQuant\";\n\nexport const GIFEncoder = function() {\n    for (var i = 0, chr = {}; i < 256; i++) chr[i] = String.fromCharCode(i);\n\n    function ByteArray() {\n        this.bin = [];\n    }\n\n    ByteArray.prototype.getData = function() {\n        for (var v = \"\", l = this.bin.length, i = 0; i < l; i++)\n            v += chr[this.bin[i]];\n        return v;\n    };\n\n    ByteArray.prototype.writeByte = function(val) {\n        this.bin.push(val);\n    };\n\n    ByteArray.prototype.writeUTFBytes = function(string) {\n        for (var l = string.length, i = 0; i < l; i++)\n            this.writeByte(string.charCodeAt(i));\n    };\n\n    ByteArray.prototype.writeBytes = function(array, offset, length) {\n        for (var l = length || array.length, i = offset || 0; i < l; i++)\n            this.writeByte(array[i]);\n    };\n\n    var exports = {};\n    var width; // image size\n    var height;\n    var transparent = null; // transparent color if given\n    var transIndex; // transparent index in color table\n    var repeat = -1; // no repeat\n    var delay = 0; // frame delay (hundredths)\n    var started = false; // ready to output frames\n    var out;\n    var image; // current frame\n    var pixels; // BGR byte array from frame\n    var indexedPixels; // converted frame indexed to palette\n    var colorDepth; // number of bit planes\n    var colorTab; // RGB palette\n    var usedEntry = []; // active palette entries\n    var palSize = 7; // color table size (bits-1)\n    var dispose = -1; // disposal code (-1 = use default)\n    var closeStream = false; // close stream when finished\n    var firstFrame = true;\n    var sizeSet = false; // if false, get size from first frame\n    var sample = 10; // default sample interval for quantizer\n    var comment = \"Generated by jsgif (https://github.com/antimatter15/jsgif/)\"; // default comment for generated gif\n\n    /**\n     * Sets the delay time between each frame, or changes it for subsequent frames\n     * (applies to last frame added)\n     * int delay time in milliseconds\n     * @param ms\n     */\n\n    var setDelay = (exports.setDelay = function setDelay(ms) {\n        delay = Math.round(ms / 10);\n    });\n\n    /**\n     * Sets the GIF frame disposal code for the last added frame and any\n     *\n     * subsequent frames. Default is 0 if no transparent color has been set,\n     * otherwise 2.\n     * @param code\n     * int disposal code.\n     */\n\n    var setDispose = (exports.setDispose = function setDispose(code) {\n        if (code >= 0) dispose = code;\n    });\n\n    /**\n     * Sets the number of times the set of GIF frames should be played. Default is\n     * 1; 0 means play indefinitely. Must be invoked before the first image is\n     * added.\n     *\n     * @param iter\n     * int number of iterations.\n     * @return\n     */\n\n    var setRepeat = (exports.setRepeat = function setRepeat(iter) {\n        if (iter >= 0) repeat = iter;\n    });\n\n    /**\n     * Sets the transparent color for the last added frame and any subsequent\n     * frames. Since all colors are subject to modification in the quantization\n     * process, the color in the final palette for each frame closest to the given\n     * color becomes the transparent color for that frame. May be set to null to\n     * indicate no transparent color.\n     * @param\n     * Color to be treated as transparent on display.\n     */\n\n    var setTransparent = (exports.setTransparent = function setTransparent(c) {\n        transparent = c;\n    });\n\n    /**\n     * Sets the comment for the block comment\n     * @param\n     * string to be insterted as comment\n     */\n\n    var setComment = (exports.setComment = function setComment(c) {\n        comment = c;\n    });\n\n    /**\n     * The addFrame method takes an incoming BitmapData object to create each frames\n     * @param\n     * BitmapData object to be treated as a GIF's frame\n     */\n\n    var addFrame = (exports.addFrame = function addFrame(im, is_imageData) {\n        if (im === null || !started || out === null) {\n            throw new Error(\"Please call start method before calling addFrame\");\n        }\n\n        var ok = true;\n\n        try {\n            if (!is_imageData) {\n                image = im.getImageData(0, 0, im.canvas.width, im.canvas.height)\n                    .data;\n                if (!sizeSet) setSize(im.canvas.width, im.canvas.height);\n            } else {\n                if (im instanceof ImageData) {\n                    image = im.data;\n                    if (!sizeSet || width != im.width || height != im.height) {\n                        setSize(im.width, im.height);\n                    } else {\n                    }\n                } else if (im instanceof Uint8ClampedArray) {\n                    if (im.length == width * height * 4) {\n                        image = im;\n                    } else {\n                        console.log(\n                            \"Please set the correct size: ImageData length mismatch\"\n                        );\n                        ok = false;\n                    }\n                } else {\n                    console.log(\"Please provide correct input\");\n                    ok = false;\n                }\n            }\n            getImagePixels(); // convert to correct format if necessary\n            analyzePixels(); // build color table & map pixels\n\n            if (firstFrame) {\n                writeLSD(); // logical screen descriptior\n                writePalette(); // global color table\n                if (repeat >= 0) {\n                    // use NS app extension to indicate reps\n                    writeNetscapeExt();\n                }\n            }\n\n            writeGraphicCtrlExt(); // write graphic control extension\n            if (comment !== \"\") {\n                writeCommentExt(); // write comment extension\n            }\n            writeImageDesc(); // image descriptor\n            if (!firstFrame) writePalette(); // local color table\n            writePixels(); // encode and write pixel data\n            firstFrame = false;\n        } catch (e) {\n            ok = false;\n        }\n\n        return ok;\n    });\n\n    /**\n     * @description: Downloads the encoded gif with the given name\n     * No need of any conversion from the stream data (out) to base64\n     * Solves the issue of large file sizes when there are more frames\n     * and does not involve in creation of any temporary data in the process\n     * so no wastage of memory, and speeds up the process of downloading\n     * to just calling this function.\n     * @parameter {String} filename filename used for downloading the gif\n     */\n\n    var download = (exports.download = function download(filename) {\n        if (out === null || closeStream == false) {\n            console.log(\n                \"Please call start method and add frames and call finish method before calling download\"\n            );\n        } else {\n            filename =\n                filename !== undefined\n                    ? filename.endsWith(\".gif\")\n                        ? filename\n                        : filename + \".gif\"\n                    : \"download.gif\";\n            var templink = document.createElement(\"a\");\n            templink.download = filename;\n            templink.href = URL.createObjectURL(\n                new Blob([new Uint8Array(out.bin)], { type: \"image/gif\" })\n            );\n            templink.click();\n        }\n    });\n\n    /**\n     * Adds final trailer to the GIF stream, if you don't call the finish method\n     * the GIF stream will not be valid.\n     */\n\n    var finish = (exports.finish = function finish() {\n        if (!started) return false;\n\n        var ok = true;\n        started = false;\n\n        try {\n            out.writeByte(0x3b); // gif trailer\n            closeStream = true;\n        } catch (e) {\n            ok = false;\n        }\n\n        return ok;\n    });\n\n    /**\n     * Resets some members so that a new stream can be started.\n     * This method is actually called by the start method\n     */\n\n    var reset = function reset() {\n        // reset for subsequent use\n        transIndex = 0;\n        image = null;\n        pixels = null;\n        indexedPixels = null;\n        colorTab = null;\n        closeStream = false;\n        firstFrame = true;\n    };\n\n    /**\n     * * Sets frame rate in frames per second. Equivalent to\n     * <code>setDelay(1000/fps)</code>.\n     * @param fps\n     * float frame rate (frames per second)\n     */\n\n    var setFrameRate = (exports.setFrameRate = function setFrameRate(fps) {\n        if (fps != 0xf) delay = Math.round(100 / fps);\n    });\n\n    /**\n     * Sets quality of color quantization (conversion of images to the maximum 256\n     * colors allowed by the GIF specification). Lower values (minimum = 1)\n     * produce better colors, but slow processing significantly. 10 is the\n     * default, and produces good color mapping at reasonable speeds. Values\n     * greater than 20 do not yield significant improvements in speed.\n     * @param quality\n     * int greater than 0.\n     * @return\n     */\n\n    var setQuality = (exports.setQuality = function setQuality(quality) {\n        if (quality < 1) quality = 1;\n        sample = quality;\n    });\n\n    /**\n     * Sets the GIF frame size. The default size is the size of the first frame\n     * added if this method is not invoked.\n     * @param w\n     * int frame width.\n     * @param h\n     * int frame width.\n     */\n\n    var setSize = (exports.setSize = function setSize(w, h) {\n        if (started && !firstFrame) return;\n        width = w;\n        height = h;\n        if (width < 1) width = 320;\n        if (height < 1) height = 240;\n        sizeSet = true;\n    });\n\n    /**\n     * Initiates GIF file creation on the given stream.\n     * @param os\n     * OutputStream on which GIF images are written.\n     * @return false if initial write failed.\n     */\n\n    var start = (exports.start = function start() {\n        reset();\n        var ok = true;\n        closeStream = false;\n        out = new ByteArray();\n        try {\n            out.writeUTFBytes(\"GIF89a\"); // header\n        } catch (e) {\n            ok = false;\n        }\n\n        return (started = ok);\n    });\n\n    var cont = (exports.cont = function cont() {\n        reset();\n        var ok = true;\n        closeStream = false;\n        out = new ByteArray();\n\n        return (started = ok);\n    });\n\n    /**\n     * Analyzes image colors and creates color map.\n     */\n\n    var analyzePixels = function analyzePixels() {\n        var len = pixels.length;\n        var nPix = len / 3;\n        indexedPixels = [];\n        var nq = new NeuQuant(pixels, len, sample);\n\n        // initialize quantizer\n        colorTab = nq.process(); // create reduced palette\n\n        // map image pixels to new palette\n        var k = 0;\n        for (var j = 0; j < nPix; j++) {\n            var index = nq.map(\n                pixels[k++] & 0xff,\n                pixels[k++] & 0xff,\n                pixels[k++] & 0xff\n            );\n            usedEntry[index] = true;\n            indexedPixels[j] = index;\n        }\n\n        pixels = null;\n        colorDepth = 8;\n        palSize = 7;\n\n        // get closest match to transparent color if specified\n        if (transparent !== null) {\n            transIndex = findClosest(transparent);\n        }\n    };\n\n    /**\n     * Returns index of palette color closest to c\n     */\n\n    var findClosest = function findClosest(c) {\n        if (colorTab === null) return -1;\n        var r = (c & 0xff0000) >> 16;\n        var g = (c & 0x00ff00) >> 8;\n        var b = c & 0x0000ff;\n        var minpos = 0;\n        var dmin = 256 * 256 * 256;\n        var len = colorTab.length;\n\n        for (var i = 0; i < len; ) {\n            var dr = r - (colorTab[i++] & 0xff);\n            var dg = g - (colorTab[i++] & 0xff);\n            var db = b - (colorTab[i] & 0xff);\n            var d = dr * dr + dg * dg + db * db;\n            var index = i / 3;\n            if (usedEntry[index] && d < dmin) {\n                dmin = d;\n                minpos = index;\n            }\n            i++;\n        }\n        return minpos;\n    };\n\n    /**\n     * Extracts image pixels into byte array \"pixels\n     */\n\n    var getImagePixels = function getImagePixels() {\n        var w = width;\n        var h = height;\n        pixels = [];\n        var data = image;\n        var count = 0;\n\n        for (var i = 0; i < h; i++) {\n            for (var j = 0; j < w; j++) {\n                var b = i * w * 4 + j * 4;\n                pixels[count++] = data[b];\n                pixels[count++] = data[b + 1];\n                pixels[count++] = data[b + 2];\n            }\n        }\n    };\n\n    /**\n     * Writes Graphic Control Extension\n     */\n\n    var writeGraphicCtrlExt = function writeGraphicCtrlExt() {\n        out.writeByte(0x21); // extension introducer\n        out.writeByte(0xf9); // GCE label\n        out.writeByte(4); // data block size\n        var transp;\n        var disp;\n        if (transparent === null) {\n            transp = 0;\n            disp = 0; // dispose = no action\n        } else {\n            transp = 1;\n            disp = 2; // force clear if using transparent color\n        }\n        if (dispose >= 0) {\n            disp = dispose & 7; // user override\n        }\n        disp <<= 2;\n        // packed fields\n        out.writeByte(\n            0 | // 1:3 reserved\n            disp | // 4:6 disposal\n            0 | // 7 user input - 0 = none\n                transp\n        ); // 8 transparency flag\n\n        WriteShort(delay); // delay x 1/100 sec\n        out.writeByte(transIndex); // transparent color index\n        out.writeByte(0); // block terminator\n    };\n\n    /**\n     * Writes Comment Extention\n     */\n\n    var writeCommentExt = function writeCommentExt() {\n        out.writeByte(0x21); // extension introducer\n        out.writeByte(0xfe); // comment label\n        out.writeByte(comment.length); // Block Size (s)\n        out.writeUTFBytes(comment);\n        out.writeByte(0); // block terminator\n    };\n\n    /**\n     * Writes Image Descriptor\n     */\n\n    var writeImageDesc = function writeImageDesc() {\n        out.writeByte(0x2c); // image separator\n        WriteShort(0); // image position x,y = 0,0\n        WriteShort(0);\n        WriteShort(width); // image size\n        WriteShort(height);\n\n        // packed fields\n        if (firstFrame) {\n            // no LCT - GCT is used for first (or only) frame\n            out.writeByte(0);\n        } else {\n            // specify normal LCT\n            out.writeByte(\n                0x80 | // 1 local color table 1=yes\n                0 | // 2 interlace - 0=no\n                0 | // 3 sorted - 0=no\n                0 | // 4-5 reserved\n                    palSize\n            ); // 6-8 size of color table\n        }\n    };\n\n    /**\n     * Writes Logical Screen Descriptor\n     */\n\n    var writeLSD = function writeLSD() {\n        // logical screen size\n        WriteShort(width);\n        WriteShort(height);\n        // packed fields\n        out.writeByte(\n            0x80 | // 1 : global color table flag = 1 (gct used)\n            0x70 | // 2-4 : color resolution = 7\n            0x00 | // 5 : gct sort flag = 0\n                palSize\n        ); // 6-8 : gct size\n\n        out.writeByte(0); // background color index\n        out.writeByte(0); // pixel aspect ratio - assume 1:1\n    };\n\n    /**\n     * Writes Netscape application extension to define repeat count.\n     */\n\n    var writeNetscapeExt = function writeNetscapeExt() {\n        out.writeByte(0x21); // extension introducer\n        out.writeByte(0xff); // app extension label\n        out.writeByte(11); // block size\n        out.writeUTFBytes(\"NETSCAPE\" + \"2.0\"); // app id + auth code\n        out.writeByte(3); // sub-block size\n        out.writeByte(1); // loop sub-block id\n        WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\n        out.writeByte(0); // block terminator\n    };\n\n    /**\n     * Writes color table\n     */\n\n    var writePalette = function writePalette() {\n        out.writeBytes(colorTab);\n        var n = 3 * 256 - colorTab.length;\n        for (var i = 0; i < n; i++) out.writeByte(0);\n    };\n\n    var WriteShort = function WriteShort(pValue) {\n        out.writeByte(pValue & 0xff);\n        out.writeByte((pValue >> 8) & 0xff);\n    };\n\n    /**\n     * Encodes and writes pixel data\n     */\n\n    var writePixels = function writePixels() {\n        var myencoder = new LZWEncoder(\n            width,\n            height,\n            indexedPixels,\n            colorDepth\n        );\n        myencoder.encode(out);\n    };\n\n    /**\n     * Retrieves the GIF stream\n     */\n\n    var stream = (exports.stream = function stream() {\n        return out;\n    });\n\n    var setProperties = (exports.setProperties = function setProperties(\n        has_start,\n        is_first\n    ) {\n        started = has_start;\n        firstFrame = is_first;\n    });\n\n    return exports;\n};\n","import {\n    Crop,\n    ExtractedSpriteGroup,\n    ExtractedSprite,\n    ExtractedTile\n} from \"./types\";\nimport { renderTileToCanvas } from \"./renderTileToCanvas\";\n\nfunction getDimensions(\n    sprites: ExtractedSprite[]\n): { width: number; height: number } {\n    const maxX = Math.max(...sprites.map(s => s.composedX)) + 16;\n\n    const tiles = sprites.reduce<ExtractedTile[]>((building, sprite) => {\n        return building.concat(sprite.tiles);\n    }, []);\n\n    const maxY = Math.max(...tiles.map(t => t.composedY)) + 16;\n\n    return {\n        width: maxX,\n        height: maxY\n    };\n}\n\nfunction flip(\n    canvas: HTMLCanvasElement,\n    tile: ExtractedTile\n): HTMLCanvasElement {\n    const xScale = tile.horizontalFlip ? -1 : 1;\n    const yScale = tile.verticalFlip ? -1 : 1;\n    const translateX = tile.horizontalFlip ? canvas.width : 0;\n    const translateY = tile.verticalFlip ? canvas.height : 0;\n\n    const newCanvas = document.createElement(\"canvas\");\n    newCanvas.width = canvas.width;\n    newCanvas.height = canvas.height;\n\n    const context = newCanvas.getContext(\"2d\");\n\n    if (context) {\n        context.save();\n        context.translate(translateX, translateY);\n        context.scale(xScale, yScale);\n\n        context.drawImage(canvas, 0, 0);\n\n        context.restore();\n    }\n\n    return newCanvas;\n}\n\nfunction cropCanvas(\n    fullCanvas: HTMLCanvasElement,\n    crop: Crop\n): HTMLCanvasElement {\n    const cropWidth = crop[1].x - crop[0].x;\n    const cropHeight = crop[1].y - crop[0].y;\n\n    const croppedCanvas = document.createElement(\"canvas\");\n    croppedCanvas.width = cropWidth;\n    croppedCanvas.height = cropHeight;\n\n    const croppedCanvasContext = croppedCanvas.getContext(\"2d\")!;\n\n    croppedCanvasContext.drawImage(\n        fullCanvas,\n        crop[0].x,\n        crop[0].y,\n        cropWidth,\n        cropHeight,\n        0,\n        0,\n        cropWidth,\n        cropHeight\n    );\n\n    return croppedCanvas;\n}\n\n// TODO: account for when sprites didn't compose right up to (0,0)\nexport function spriteGroupToCanvas(\n    spriteGroups: ExtractedSpriteGroup[],\n    animationCounter = 0,\n    crop?: Crop\n): HTMLCanvasElement {\n    const sprites = spriteGroups.reduce<ExtractedSprite[]>(\n        (b, sg) => b.concat(sg.sprites),\n        []\n    );\n\n    const dimensions = getDimensions(sprites);\n\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = dimensions.width;\n    canvas.height = dimensions.height;\n\n    const context = canvas.getContext(\"2d\");\n\n    const sortedSprites = [...sprites].sort(\n        (a, b) => a.spriteMemoryIndex - b.spriteMemoryIndex\n    );\n\n    sortedSprites.forEach(sprite => {\n        sprite.tiles.forEach(tile => {\n            let tileCanvas = document.createElement(\"canvas\");\n\n            let tileIndex = tile.tileIndex;\n\n            if (tile.autoAnimation === 3) {\n                // 3 bit auto animation: the 4th bit is set, indicating this tile does 3bit auto animation\n                // that means take its tileIndex, and replace its bottom three bits with those of the animation counter\n                tileIndex =\n                    (tileIndex & ~7) + ((tileIndex + animationCounter) & 7);\n            }\n            if (tile.autoAnimation === 2) {\n                // 2 bit auto animation: like above but replace its bottom two bits\n                tileIndex =\n                    (tileIndex & ~3) + ((tileIndex + animationCounter) & 3);\n            }\n\n            renderTileToCanvas(tileCanvas, tileIndex, tile.rgbPalette);\n\n            if (tile.horizontalFlip || tile.verticalFlip) {\n                tileCanvas = flip(tileCanvas, tile);\n            }\n\n            context!.drawImage(tileCanvas, sprite.composedX, tile.composedY);\n        });\n    });\n\n    if (crop) {\n        return cropCanvas(canvas, crop);\n    } else {\n        return canvas;\n    }\n}\n","import { Crop, ExtractedSpriteGroup } from \"./types\";\n// @ts-ignore\nimport { GIFEncoder } from \"./jsgif/GIFEncoder\";\nimport { spriteGroupToCanvas } from \"./spriteGroupToCanvas\";\n\nconst TOTAL_FRAMES = 8;\n// loop set to zero means forever\nconst FOREVER = 0;\n\nexport function createGif(\n    spriteGroups: ExtractedSpriteGroup[],\n    crop: Crop | undefined,\n    delay: number,\n    onFrame: (\n        canvas: HTMLCanvasElement,\n        frameNumber: number,\n        totalFrames: number\n    ) => void,\n    onFinish: (dataUrl: string) => void\n): void {\n    // @ts-ignore\n    const encoder: any = new GIFEncoder();\n    encoder.setRepeat(FOREVER);\n    encoder.setDelay(delay);\n    encoder.setQuality(1);\n\n    encoder.start();\n\n    let remainingFrames = TOTAL_FRAMES;\n\n    const finish = () => {\n        encoder.finish();\n\n        const binaryData = encoder.stream().getData();\n\n        onFinish(`data:image/gif;base64,${btoa(binaryData)}`);\n    };\n\n    const addFrame = () => {\n        const animationCounter = TOTAL_FRAMES - remainingFrames;\n\n        const frameCanvas = spriteGroupToCanvas(\n            spriteGroups,\n            animationCounter,\n            crop\n        );\n        encoder.addFrame(frameCanvas.getContext(\"2d\")!);\n\n        --remainingFrames;\n\n        onFrame(frameCanvas, animationCounter, TOTAL_FRAMES);\n\n        if (remainingFrames) {\n            setTimeout(addFrame, 1);\n        } else {\n            setTimeout(finish, 1);\n        }\n    };\n\n    addFrame();\n}\n","import React, { useEffect, useRef, useState } from \"react\";\nimport Modal from \"react-modal\";\nimport { createGif } from \"../state/createGif_jsgif\";\nimport { useAppState } from \"../state\";\nimport { ExtractedSpriteGroup } from \"../state/types\";\n\ntype FrameStatus = { frame: number; totalFrames: number };\n\nfunction clear(div: HTMLDivElement) {\n    while (div.firstChild) {\n        div.removeChild(div.firstChild);\n    }\n}\n\ninterface BuildGifModalProps {\n    isOpen: boolean;\n    onRequestClose: () => void;\n}\n\nexport const BuildGifModal: React.FunctionComponent<BuildGifModalProps> = ({\n    isOpen,\n    onRequestClose\n}) => {\n    const [state] = useAppState();\n    const containerRef = useRef<null | HTMLDivElement>(null);\n    const [frameStatus, setFrameStatus] = useState<null | FrameStatus>(null);\n\n    useEffect(() => {\n        if (isOpen) {\n            const delay = window.Module._get_neogeo_frame_counter_speed() * 16;\n\n            const extractedSpriteGroups = state.layers.reduce<\n                ExtractedSpriteGroup[]\n            >((b, layer) => {\n                return b.concat(layer.groups);\n            }, []);\n\n            createGif(\n                extractedSpriteGroups,\n                state.crop,\n                delay,\n                (\n                    canvas: HTMLCanvasElement,\n                    frame: number,\n                    totalFrames: number\n                ) => {\n                    setFrameStatus({ frame, totalFrames });\n\n                    if (containerRef && containerRef.current) {\n                        clear(containerRef.current);\n                        containerRef.current.appendChild(canvas);\n                    }\n                },\n                (dataUrl: string) => {\n                    setFrameStatus(null);\n\n                    if (containerRef && containerRef.current) {\n                        clear(containerRef.current);\n                        const img = new Image();\n                        img.src = dataUrl;\n                        containerRef.current.appendChild(img);\n                    }\n                }\n            );\n        }\n    }, [isOpen]);\n\n    return (\n        <Modal isOpen={isOpen} onRequestClose={onRequestClose}>\n            {frameStatus && (\n                <div>\n                    {frameStatus.frame} of {frameStatus.totalFrames}\n                </div>\n            )}\n            <div ref={containerRef} />\n        </Modal>\n    );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport {\n    useAppState,\n    deleteGroupAction,\n    toggleVisiblityOfGroupAction,\n    NEW_LAYER,\n    deleteLayerAction,\n    toggleVisiblityOfLayerAction,\n    setFocusedLayerAction,\n    extendLayerViaMirrorAction\n} from \"../state\";\nimport { Layer as LayerData, ExtractedSpriteGroup } from \"../state/types\";\n\nimport styles from \"./layers.module.css\";\n\ninterface GroupProps {\n    group: ExtractedSpriteGroup;\n    onDelete: () => void;\n    onToggleVisibility: () => void;\n}\n\nconst Group: React.FunctionComponent<GroupProps> = ({\n    group,\n    onDelete,\n    onToggleVisibility\n}) => {\n    return (\n        <div className={styles.group}>\n            {group.sprites[0].spriteMemoryIndex}{\" \"}\n            <button onClick={() => onDelete()}>delete</button>\n            <button onClick={() => onToggleVisibility()}>\n                {group.hidden ? \"show\" : \"hide\"}\n            </button>\n        </div>\n    );\n};\n\ninterface LayerProps {\n    layer: LayerData;\n    onGroupDelete: (group: ExtractedSpriteGroup) => void;\n    onGroupToggleVisibility: (group: ExtractedSpriteGroup) => void;\n    onDelete: () => void;\n    onToggleVisibility: () => void;\n    onClick: () => void;\n    onExtendViaMirror: () => void;\n    focused?: boolean;\n}\n\nconst Layer: React.FunctionComponent<LayerProps> = ({\n    layer,\n    onDelete,\n    onToggleVisibility,\n    onGroupDelete,\n    onGroupToggleVisibility,\n    onClick,\n    onExtendViaMirror,\n    focused\n}) => {\n    const groups = layer.groups.map((group, i) => (\n        <Group\n            key={i}\n            group={group}\n            onDelete={() => onGroupDelete(group)}\n            onToggleVisibility={() => onGroupToggleVisibility(group)}\n        />\n    ));\n\n    const classes = classnames(styles.layer, {\n        [styles.focused]: focused\n    });\n\n    return (\n        <div className={classes} onClick={() => onClick()}>\n            <div>\n                layer\n                <button onClick={() => onDelete()}>delete</button>\n                <button onClick={() => onToggleVisibility()}>\n                    {layer.hidden ? \"show\" : \"hide\"}\n                </button>\n                <button\n                    disabled={layer.extendedViaMirror}\n                    onClick={() => onExtendViaMirror()}\n                >\n                    extend via mirror\n                </button>\n            </div>\n            {groups}\n        </div>\n    );\n};\n\ninterface LayersProps {\n    className?: string;\n}\n\nexport const Layers: React.FunctionComponent<LayersProps> = ({ className }) => {\n    const [state, dispatch] = useAppState();\n\n    const classes = classnames(styles.root, className);\n\n    const layers = state.layers.map((layer, i) => (\n        <Layer\n            key={i}\n            layer={layer}\n            focused={i === state.focusedLayerIndex}\n            onClick={() => dispatch(setFocusedLayerAction(layer))}\n            onDelete={() => dispatch(deleteLayerAction(layer))}\n            onToggleVisibility={() =>\n                dispatch(toggleVisiblityOfLayerAction(layer))\n            }\n            onGroupDelete={group => dispatch(deleteGroupAction(group))}\n            onGroupToggleVisibility={group =>\n                dispatch(toggleVisiblityOfGroupAction(group))\n            }\n            onExtendViaMirror={() =>\n                dispatch(extendLayerViaMirrorAction(layer))\n            }\n        />\n    ));\n\n    return (\n        <div className={classes}>\n            <button onClick={() => dispatch(NEW_LAYER)}>new layer</button>\n            {layers}\n        </div>\n    );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { Crop } from \"../state/types\";\n\nimport styles from \"./cropRect.module.css\";\n\ninterface CropRectProps {\n    className?: string;\n    crop: Crop;\n    totalWidth: number;\n    totalHeight: number;\n}\n\nexport const CropRect: React.FunctionComponent<CropRectProps> = ({\n    className,\n    crop,\n    totalWidth,\n    totalHeight\n}) => {\n    const classes = classnames(styles.root, className);\n\n    const topRowStyle = {\n        height: crop[0].y,\n        gridColumn: \"1 / -1\",\n        gridRow: \"1\"\n    };\n\n    const leftCellStyle = {\n        width: crop[0].x,\n        height: crop[1].y - crop[0].y,\n        gridColumn: \"1\",\n        gridRow: \"2\"\n    };\n\n    const rightCellStyle = {\n        gridColumn: \"3\",\n        gridRow: \"2\",\n        width: totalWidth - crop[1].x\n    };\n\n    const cropStyle = {\n        width: crop[1].x - crop[0].x,\n        height: crop[1].y - crop[0].y,\n        gridColumn: \"2\",\n        gridRow: \"2\"\n    };\n\n    const bottomRowStyle = {\n        gridColumn: \"1 / -1\",\n        gridRow: \"3\",\n        flex: \"1\",\n        height: totalHeight - crop[1].y\n    };\n\n    return (\n        <div className={classes}>\n            <div className={styles.mask} style={topRowStyle} />\n            <div className={styles.mask} style={leftCellStyle} />\n            <div className={styles.crop} style={cropStyle} />\n            <div className={styles.mask} style={rightCellStyle} />\n            <div className={styles.mask} style={bottomRowStyle} />\n        </div>\n    );\n};\n","import React, { useState, useEffect } from \"react\";\nimport classnames from \"classnames\";\nimport { useDrop } from \"react-dnd\";\nimport { ExtractedSprite as ExtractedSpriteCmp } from \"./extractedSprite\";\nimport {\n    getBackdropNeoGeoColor,\n    neoGeoColorToCSS\n} from \"../palette/neoGeoPalette\";\nimport {\n    useAppState,\n    extractSpriteAction,\n    HANDLE_NEGATIVES,\n    setCropAction,\n    CLEAR_CROP\n} from \"../state\";\nimport { Layer, ExtractedSprite } from \"../state/types\";\nimport { BuildGifModal } from \"../gifBuilder/buildGifModal\";\nimport { Layers } from \"./layers\";\nimport { CropRect } from \"./cropRect\";\n\nimport styles from \"./composeScreen.module.css\";\n\ninterface ComposeScreenProps {\n    className?: string;\n}\n\nexport const ComposeScreen: React.FunctionComponent<ComposeScreenProps> = ({\n    className\n}) => {\n    const [animationCounter, setAnimationCounter] = useState({\n        animation: 0,\n        rafFrameCountdown: 0\n    });\n    const [runPreview, setRunPreview] = useState(false);\n    const [showBuildGifModal, setShowBuildGifModal] = useState(false);\n    const [state, dispatch] = useAppState();\n    const [divRef, setDivRef] = useState<null | HTMLDivElement>(null);\n    const [isCropping, setIsCropping] = useState(false);\n    const [upperLeftCrop, setUpperLeftCrop] = useState<null | {\n        x: number;\n        y: number;\n    }>(null);\n    const [lowerRightCrop, setLowerRightCrop] = useState<null | {\n        x: number;\n        y: number;\n    }>(null);\n\n    useEffect(() => {\n        if (runPreview) {\n            // minus one because on my machine the animation can't quite keep up\n            const frameCountdown =\n                window.Module._get_neogeo_frame_counter_speed() - 1;\n            requestAnimationFrame(() => {\n                const diff = animationCounter.rafFrameCountdown === 0 ? 1 : 0;\n\n                setAnimationCounter({\n                    animation: animationCounter.animation + diff,\n                    rafFrameCountdown:\n                        diff === 1\n                            ? frameCountdown\n                            : animationCounter.rafFrameCountdown - 1\n                });\n            });\n        }\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [_, dropRef] = useDrop({\n        accept: \"Sprite\",\n        drop: (item: any, monitor: any) => {\n            if (divRef) {\n                const x =\n                    monitor.getClientOffset().x -\n                    divRef.getBoundingClientRect().left;\n\n                const composedX = Math.floor(x / 16) * 16;\n                const spriteIndex = item.spriteIndex;\n                const pauseId = item.pauseId;\n\n                dispatch(extractSpriteAction(spriteIndex, composedX, pauseId));\n            }\n        },\n        canDrop() {\n            return !isCropping;\n        }\n    });\n\n    const extractedSprites = state.layers.reduce<ExtractedSprite[]>(\n        (b, layer) => {\n            if (layer.hidden) {\n                return b;\n            } else {\n                const sprites = layer.groups.reduce<ExtractedSprite[]>(\n                    (b, group) => {\n                        if (group.hidden) {\n                            return b;\n                        } else {\n                            return b.concat(group.sprites);\n                        }\n                    },\n                    []\n                );\n\n                return b.concat(sprites);\n            }\n        },\n        []\n    );\n\n    const sprites = extractedSprites.map(extractedSprite => (\n        <ExtractedSpriteCmp\n            key={extractedSprite.spriteMemoryIndex}\n            data={extractedSprite}\n            autoAnimate={runPreview}\n            animationCounter={animationCounter.animation}\n            canDrag={!isCropping}\n        />\n    ));\n\n    const backgroundColor = state.isPaused\n        ? neoGeoColorToCSS(getBackdropNeoGeoColor())\n        : \"transparent\";\n\n    const maxX = Math.max(...extractedSprites.map(es => es.composedX));\n    const width = Math.max(maxX + 48, 320);\n\n    const maxY = Math.max(\n        ...extractedSprites.map(es =>\n            Math.max(...es.tiles.map(t => t.composedY))\n        )\n    );\n    const height = Math.max(maxY + 48, 240);\n\n    const style = {\n        backgroundColor,\n        width,\n        height\n    };\n\n    const finalClassName = classnames(styles.root, className);\n\n    return (\n        <>\n            <BuildGifModal\n                isOpen={showBuildGifModal}\n                onRequestClose={() => setShowBuildGifModal(false)}\n            />\n            <div className={finalClassName}>\n                <div className={styles.toolbar}>\n                    <button\n                        disabled={isCropping}\n                        onClick={() => {\n                            setIsCropping(true);\n                            dispatch(CLEAR_CROP);\n                            setUpperLeftCrop(null);\n                            setLowerRightCrop(null);\n                        }}\n                    >\n                        crop\n                    </button>\n                    <button\n                        disabled={!state.crop}\n                        onClick={() => {\n                            dispatch(CLEAR_CROP);\n                            setUpperLeftCrop(null);\n                            setLowerRightCrop(null);\n                        }}\n                    >\n                        clear crop\n                    </button>\n                    <button onClick={() => setRunPreview(!runPreview)}>\n                        {runPreview ? \"stop\" : \"preview\"}\n                    </button>\n                    <button onClick={() => setShowBuildGifModal(true)}>\n                        build gif\n                    </button>\n                    <div>\n                        {animationCounter.animation} (\n                        {animationCounter.rafFrameCountdown})\n                    </div>\n                </div>\n                <Layers className={styles.layers} />\n                <div\n                    className={styles.bg}\n                    ref={div => {\n                        setDivRef(div);\n                        dropRef(div);\n                    }}\n                    style={style}\n                >\n                    {isCropping && (\n                        <div\n                            className={styles.captureLayer}\n                            onMouseDown={(\n                                e: React.MouseEvent<HTMLDivElement>\n                            ) => {\n                                if (isCropping) {\n                                    const rect = (e.target as HTMLDivElement).getBoundingClientRect() as DOMRect;\n\n                                    const rawX = e.clientX - rect.x;\n                                    const rawY = e.clientY - rect.y;\n\n                                    const x = Math.floor(rawX / 16) * 16;\n                                    const y = Math.floor(rawY / 16) * 16;\n\n                                    setUpperLeftCrop({ x, y });\n                                }\n                            }}\n                            onMouseMove={e => {\n                                if (isCropping && upperLeftCrop) {\n                                    const rect = (e.target as HTMLDivElement).getBoundingClientRect() as DOMRect;\n\n                                    const rawX = e.clientX - rect.x;\n                                    const rawY = e.clientY - rect.y;\n\n                                    const x = Math.floor(rawX / 16) * 16;\n                                    const y = Math.floor(rawY / 16) * 16;\n\n                                    setLowerRightCrop({ x, y });\n                                }\n                            }}\n                            onMouseUp={e => {\n                                if (\n                                    isCropping &&\n                                    upperLeftCrop &&\n                                    lowerRightCrop\n                                ) {\n                                    dispatch(\n                                        setCropAction([\n                                            upperLeftCrop,\n                                            lowerRightCrop\n                                        ])\n                                    );\n                                    setIsCropping(false);\n                                }\n                            }}\n                        />\n                    )}\n                    {sprites}\n                    {!!(\n                        (isCropping && upperLeftCrop && lowerRightCrop) ||\n                        state.crop\n                    ) && (\n                        <CropRect\n                            className={styles.cropRect}\n                            crop={\n                                state.crop || [upperLeftCrop!, lowerRightCrop!]\n                            }\n                            totalWidth={width}\n                            totalHeight={height}\n                        />\n                    )}\n                </div>\n                <button\n                    className={styles.handleNegatives}\n                    onClick={() => dispatch(HANDLE_NEGATIVES)}\n                >\n                    handle negatives\n                </button>\n            </div>\n        </>\n    );\n};\n","import React from \"react\";\nimport Modal from \"react-modal\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./App\";\n\nimport \"./index.css\";\n\nModal.setAppElement(\"#root\");\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n","import React from \"react\";\nimport * as Space from \"react-spaces\";\nimport { DndProvider } from \"react-dnd\";\nimport HTML5Backend from \"react-dnd-html5-backend\";\nimport { Provider as AppStateProvider } from \"./state\";\nimport { Emulator } from \"./emulator\";\nimport { SpriteTray } from \"./spriteTray\";\nimport { ComposeScreen } from \"./composeScreen\";\n\nexport const App: React.FunctionComponent = () => {\n    return (\n        <AppStateProvider>\n            <DndProvider backend={HTML5Backend}>\n                <Space.ViewPort>\n                    <Space.TopResizable size=\"50%\">\n                        <Space.LeftResizable size=\"30%\">\n                            <Emulator />\n                        </Space.LeftResizable>\n                        <Space.Fill>\n                            <ComposeScreen />\n                        </Space.Fill>\n                    </Space.TopResizable>\n                    <Space.Fill>\n                        <SpriteTray />\n                    </Space.Fill>\n                </Space.ViewPort>\n            </DndProvider>\n        </AppStateProvider>\n    );\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"composeScreen_root__3bwon\",\"layers\":\"composeScreen_layers__ioZ1g\",\"toolbar\":\"composeScreen_toolbar__1QlS0\",\"bg\":\"composeScreen_bg__1xmrl\",\"captureLayer\":\"composeScreen_captureLayer__1AfVW\",\"cropRect\":\"composeScreen_cropRect__3Yoa2\",\"handleNegatives\":\"composeScreen_handleNegatives__3RkzZ\"};"],"sourceRoot":""}