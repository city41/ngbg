{"version":3,"sources":["emulator/tile.module.css","emulator/neoGeoPalette.ts","emulator/tile.tsx","emulator/spriteData.ts","emulator/sprite.tsx","emulator/sprites.tsx","emulator/emulator.tsx","index.tsx","App.tsx","emulator/sprite.module.css","emulator/sprites.module.css"],"names":["module","exports","PALETTE_SIZE_IN_BYTES","getRgbFromNeoGeoPalette","paletteIndex","colorIndex","palAddr","window","Module","_get_current_pal_addr","palOffset","colorOffset","color","i","HEAPU8","col16","darkBit","convert","TILE_SIZE_BYTES","TILE_SIZE_INTS","map","0","1","2","3","4","5","6","7","Tile","tileY","y","tileIndex","horizontalFlip","verticalFlip","positioned","verticalScale","inlineStyle","transform","top","className","classnames","styles","ref","r","canvas","cromAddr","_get_rom_ctile_addr","tileOffset","tileData","width","height","context","getContext","imageData","getImageData","x","pixelPair","rightPixelColorIndex","leftPixel","rightPixel","length","data","putImageData","renderCanvas","style","SCB1_SPRITE_SIZE_BYTES","SCB2_BYTE_OFFSET","SCB3_BYTE_OFFSET","SCB4_BYTE_OFFSET","getTileData","spriteIndex","spriteSize","tileYs","tileRamAddr","_get_tile_ram_addr","spriteOffset","spriteData","w","firstWord","secondWord","push","getYSpriteSizeSticky","Error","spriteScb3Addr","scb3Word","sticky","rawY","yScale","fullmode","transformY","getScale","ignoreSticky","t","getX","xScale","spriteScb4Addr","options","spriteScb2Addr","scb2Word","Sprite","honorTileSize","tiles","getSpriteData","key","left","gridTemplateRows","spriteClassName","sprite","Sprites","useState","dumpCount","setDumpCount","setPositioned","setHonorTileSize","sprites","Array","fill","_","spritesClassName","type","checked","onChange","onClick","loadFile","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","name","readAsArrayBuffer","addFileToVirtualFS","a","FS_createDataFile","Uint8Array","Emulator","setBiosLoaded","setRomLoaded","gameName","setGameName","isPaused","setIsPaused","e","target","files","replace","id","overrideGameName","argv","stackAlloc","HEAP32","allocateUTF8OnStack","_run_rom","startGame","resumeMainLoop","pauseMainLoop","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.b3562de4.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"positioned\":\"tile_positioned__2WLPh\"};","// each palette has 16 colors, each color is a 32 bit rgb value\n// NOTE: this is due to using gngeo's pc palette instead of actual\n// neo geo palettes, which only have 16bit colors (Thanks gngeo!)\nconst PALETTE_SIZE_IN_BYTES = 16 * 2;\n\n/**\n * Convert from a neo geo palette color to a 32 rgb color\n * https://wiki.neogeodev.org/index.php?title=Colors\n */\nfunction convert(col16: number): number[] {\n    // the least significant bit is shared by each channel\n    // if it is zero, the entire color is a tad darker, hence the name \"dark bit\"\n    const darkBit = (col16 >> 15) & 1;\n\n    const upperB = (col16 & 0xf) << 2;\n    const lowerB = ((col16 >> 12) & 1) << 1;\n    const b5 = upperB | lowerB | darkBit;\n\n    const upperG = ((col16 >> 4) & 0xf) << 2;\n    const lowerG = ((col16 >> 13) & 1) << 1;\n    const g5 = upperG | lowerG | darkBit;\n\n    const upperR = ((col16 >> 8) & 0xf) << 2;\n    const lowerR = ((col16 >> 14) & 1) << 1;\n    const r5 = upperR | lowerR | darkBit;\n\n    // neo geo color channels are six bits (max value of 63), but need to map\n    // them to a 8 bit color channel (max value of 255)\n    const b = (b5 / 63) * 255;\n    const g = (g5 / 63) * 255;\n    const r = (r5 / 63) * 255;\n\n    return [r, g, b, 255];\n}\n\nexport function getRgbFromNeoGeoPalette(\n    paletteIndex: number,\n    colorIndex: number\n): number[] {\n    if (colorIndex === 0) {\n        return [0, 0, 0, 0];\n    }\n\n    const palAddr = window.Module._get_current_pal_addr();\n    const palOffset = paletteIndex * PALETTE_SIZE_IN_BYTES;\n    const colorOffset = colorIndex * 2;\n\n    const color: number[] = [];\n\n    for (let i = 0; i < 2; ++i) {\n        color[i] = window.HEAPU8[palAddr + palOffset + colorOffset + i];\n    }\n\n    const combinedColor = color[0] | (color[1] << 8);\n\n    return convert(combinedColor);\n}\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { getRgbFromNeoGeoPalette } from \"./neoGeoPalette\";\n\nimport styles from \"./tile.module.css\";\n\n// 16 rows, each row has 2 ints (32 bits each)\nconst TILE_SIZE_INTS = 2 * 16;\nconst TILE_SIZE_BYTES = TILE_SIZE_INTS * 4;\n\ninterface TileProps {\n    y: number;\n    tileIndex: number;\n    paletteIndex: number;\n    horizontalFlip?: boolean;\n    verticalFlip?: boolean;\n    positioned: boolean;\n}\n\nconst map: Record<string, number> = {\n    0: 3,\n    1: 2,\n    2: 1,\n    3: 0,\n    4: 7,\n    5: 6,\n    6: 5,\n    7: 4\n};\n\nexport const Tile: React.FunctionComponent<TileProps> = ({\n    y: tileY,\n    tileIndex,\n    paletteIndex,\n    horizontalFlip,\n    verticalFlip,\n    positioned\n}) => {\n    function renderCanvas(canvas: HTMLCanvasElement) {\n        const cromAddr = window.Module._get_rom_ctile_addr();\n        const tileOffset = TILE_SIZE_BYTES * tileIndex;\n\n        const tileData: number[] = [];\n\n        for (let i = 0; i < TILE_SIZE_BYTES; ++i) {\n            tileData[i] = window.HEAPU8[cromAddr + tileOffset + i];\n        }\n\n        canvas.width = 16;\n        canvas.height = 16;\n\n        const context = canvas.getContext(\"2d\")!;\n\n        const imageData = context.getImageData(0, 0, 16, 16);\n\n        for (let y = 0; y < 16; ++y) {\n            for (let x = 0; x < 8; ++x) {\n                const pixelPair = tileData[y * 8 + map[x]];\n\n                const leftPixelColorIndex = (pixelPair >> 4) & 0xf;\n                const rightPixelColorIndex = pixelPair & 0xf;\n\n                const leftPixel = getRgbFromNeoGeoPalette(\n                    paletteIndex,\n                    leftPixelColorIndex\n                );\n                const rightPixel = getRgbFromNeoGeoPalette(\n                    paletteIndex,\n                    rightPixelColorIndex\n                );\n\n                for (let i = 0; i < leftPixel.length; ++i) {\n                    imageData.data[(y * 16 + x * 2) * 4 + i] = leftPixel[i];\n                    imageData.data[(y * 16 + x * 2 + 1) * 4 + i] =\n                        rightPixel[i];\n                }\n            }\n        }\n\n        context.putImageData(imageData, 0, 0);\n    }\n\n    const horizontalScale = horizontalFlip ? -1 : 1;\n    const verticalScale = verticalFlip ? -1 : 1;\n\n    const inlineStyle = {\n        transform: `scale(${horizontalScale},${verticalScale})`,\n        top: tileY\n    };\n\n    const className = classnames({\n        [styles.positioned]: positioned\n    });\n\n    return (\n        <canvas\n            className={className}\n            ref={r => r && renderCanvas(r)}\n            style={inlineStyle}\n        />\n    );\n};\n","// ALERT!\n// vram addresses in the neo geo are word wide, not byte wide!\n// TODO: can probably just use HEAPU16 and make this all much simpler\n// ALERT!\n\n// in SCB1,\n// each sprite has 64, 16-bit, words\nconst SCB1_SPRITE_SIZE_BYTES = 64 * 2;\n\n// it starts at word $8000, so *2 to get byte address\nconst SCB2_BYTE_OFFSET = 0x8000 * 2;\n\n// it starts at word $8200, so *2 to get byte address\nconst SCB3_BYTE_OFFSET = 0x8200 * 2;\n\n// it starts at word $8400, so *2 to get byte address\nconst SCB4_BYTE_OFFSET = 0x8400 * 2;\n\ninterface TileData {\n    y: number;\n    tileIndex: number;\n    paletteIndex: number;\n    horizontalFlip: boolean;\n    verticalFlip: boolean;\n}\n\ninterface SpriteData {\n    tiles: TileData[];\n    x: number;\n    y: number;\n    sticky: boolean;\n}\n\nfunction getTileData(\n    spriteIndex: number,\n    spriteSize: number,\n    tileYs: number[]\n): TileData[] {\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const spriteOffset = SCB1_SPRITE_SIZE_BYTES * spriteIndex;\n\n    const spriteData: number[] = [];\n\n    for (let i = 0; i < spriteSize * 4; ++i) {\n        spriteData[i] = window.HEAPU8[tileRamAddr + spriteOffset + i];\n    }\n\n    const tileData = [];\n\n    for (let w = 0; w < spriteData.length; w += 4) {\n        const firstWord = spriteData[w] | (spriteData[w + 1] << 8);\n        const secondWord = spriteData[w + 2] | (spriteData[w + 3] << 8);\n\n        // first word = least sig bits of tile index\n        // second word, bits 4 through 7 = most sig bits of tile index\n        const tileIndex = firstWord | (((secondWord >> 4) & 0xf) << 16);\n\n        // top half of second word is the palette index\n        const paletteIndex = (secondWord >> 8) & 0xff;\n\n        const horizontalFlip = !!(secondWord & 1);\n        const verticalFlip = !!(secondWord & 2);\n\n        tileData.push({\n            y: tileYs[w / 4],\n            tileIndex,\n            paletteIndex,\n            horizontalFlip,\n            verticalFlip\n        });\n    }\n\n    return tileData;\n}\n\nfunction transformY(rawY: number, yScale: number, spriteSize: number): number {\n    let fullmode;\n\n    if (spriteSize === 0x20) {\n        fullmode = 1;\n    } else if (spriteSize >= 0x21) {\n        fullmode = 2;\n    } else {\n        fullmode = 0;\n    }\n\n    // getting the final screen y is very complicated and\n    // honestly don't fully understand it. This code was copied\n    // from gngeo, video.c#draw_screen()\n    let y = 0x200 - rawY;\n\n    if (y > 0x110) {\n        y -= 0x200;\n    }\n\n    if (fullmode === 2 || (fullmode === 1 && yScale === 0xff)) {\n        while (y < 0) {\n            y += (yScale + 1) << 1;\n        }\n    }\n\n    return y;\n}\n\nfunction getYSpriteSizeSticky(\n    spriteIndex: number\n): { y: number; tileYs: number[]; spriteSize: number; sticky: boolean } {\n    if (spriteIndex < 0) {\n        throw new Error(\"getYSpriteSizeSticky: sprite index under zero!\");\n    }\n\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const scb3StartAddr = tileRamAddr + SCB3_BYTE_OFFSET;\n\n    const spriteScb3Addr = scb3StartAddr + spriteIndex * 2;\n\n    const scb3Word =\n        window.HEAPU8[spriteScb3Addr] |\n        (window.HEAPU8[spriteScb3Addr + 1] << 8);\n\n    const sticky = !!((scb3Word >> 6) & 1);\n\n    if (sticky) {\n        return {\n            ...getYSpriteSizeSticky(spriteIndex - 1),\n            sticky\n        };\n    } else {\n        const yScale = getScale(spriteIndex, { ignoreSticky: true }).yScale;\n        const spriteSize = scb3Word & 0x3f;\n        const rawY = scb3Word >> 7;\n\n        const y = transformY(rawY, yScale, spriteSize);\n        const tileYs = [];\n\n        for (let t = 0; t < spriteSize; ++t) {\n            tileYs.push((y + 16 * t) % 512);\n        }\n\n        return { y, tileYs, spriteSize, sticky };\n    }\n}\n\nfunction getX(spriteIndex: number): number {\n    if (spriteIndex < 0) {\n        throw new Error(\"getX: sprite index under zero!\");\n    }\n\n    const sticky = getYSpriteSizeSticky(spriteIndex).sticky;\n\n    let x;\n\n    if (sticky) {\n        const xScale = getScale(spriteIndex).xScale;\n        x = getX(spriteIndex - 1) + xScale;\n    } else {\n        const tileRamAddr = window.Module._get_tile_ram_addr();\n        const scb4StartAddr = tileRamAddr + SCB4_BYTE_OFFSET;\n\n        const spriteScb4Addr = scb4StartAddr + spriteIndex * 2;\n\n        const scb4Word =\n            window.HEAPU8[spriteScb4Addr] |\n            (window.HEAPU8[spriteScb4Addr + 1] << 8);\n\n        x = scb4Word >> 7;\n    }\n\n    if (x >= 0x1f0) {\n        x -= 0x200;\n    }\n\n    return x;\n}\n\nfunction getScale(\n    spriteIndex: number,\n    options?: { ignoreSticky: boolean }\n): { yScale: number; xScale: number } {\n    if (spriteIndex < 0) {\n        throw new Error(\"getScale: sprite index under zero!\");\n    }\n\n    if (!options || !options.ignoreSticky) {\n        const sticky = getYSpriteSizeSticky(spriteIndex).sticky;\n\n        if (sticky) {\n            return getScale(spriteIndex - 1);\n        }\n    }\n\n    const tileRamAddr = window.Module._get_tile_ram_addr();\n    const scb2StartAddr = tileRamAddr + SCB2_BYTE_OFFSET;\n    const spriteScb2Addr = scb2StartAddr + spriteIndex * 2;\n\n    const scb2Word =\n        window.HEAPU8[spriteScb2Addr] |\n        (window.HEAPU8[spriteScb2Addr + 1] << 8);\n\n    const yScale = scb2Word & 0xff;\n    const xScale = ((scb2Word >> 8) & 0xf) + 1;\n\n    return { yScale, xScale };\n}\n\nexport function getSpriteData(\n    spriteIndex: number,\n    honorTileSize: boolean\n): SpriteData {\n    const { y, tileYs, spriteSize } = getYSpriteSizeSticky(spriteIndex);\n\n    return {\n        tiles: getTileData(\n            spriteIndex,\n            honorTileSize ? spriteSize : 32,\n            tileYs\n        ),\n        x: getX(spriteIndex),\n        sticky: false,\n        y\n    };\n}\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport { Tile } from \"./tile\";\nimport { getSpriteData } from \"./spriteData\";\n\nimport styles from \"./sprite.module.css\";\n\ninterface SpriteProps {\n    spriteIndex: number;\n    positioned: boolean;\n    honorTileSize: boolean;\n}\n\nexport const Sprite: React.FunctionComponent<SpriteProps> = ({\n    spriteIndex,\n    positioned,\n    honorTileSize\n}) => {\n    const spriteData = getSpriteData(spriteIndex, honorTileSize);\n\n    if (spriteData.tiles.length === 0) {\n        return null;\n    }\n\n    const tiles = spriteData.tiles.map((tileData, i) => (\n        <Tile\n            key={i}\n            positioned={positioned}\n            y={tileData.y - spriteData.y}\n            tileIndex={tileData.tileIndex}\n            paletteIndex={tileData.paletteIndex}\n            horizontalFlip={tileData.horizontalFlip}\n            verticalFlip={tileData.verticalFlip}\n        />\n    ));\n\n    const style = {\n        top: spriteData.y,\n        left: spriteData.x,\n        gridTemplateRows: `repeat(${spriteData.tiles.length}, 16px)`\n    };\n\n    const spriteClassName = classnames(styles.sprite, {\n        [styles.positioned]: positioned\n    });\n\n    return (\n        <div className={spriteClassName} style={style}>\n            {tiles}\n        </div>\n    );\n};\n","import React, { useState } from \"react\";\nimport classnames from \"classnames\";\nimport { Sprite } from \"./sprite\";\n\nimport styles from \"./sprites.module.css\";\n\nconst SPRITE_CHUNK_SIZE = 448;\n\nexport const Sprites: React.FunctionComponent = () => {\n    const [dumpCount, setDumpCount] = useState(0);\n    const [positioned, setPositioned] = useState(true);\n    const [honorTileSize, setHonorTileSize] = useState(true);\n\n    const sprites = new Array(dumpCount ? SPRITE_CHUNK_SIZE : 0)\n        .fill(1, 0, SPRITE_CHUNK_SIZE)\n        .map((_, i) => {\n            return (\n                <Sprite\n                    key={i}\n                    spriteIndex={i}\n                    positioned={positioned}\n                    honorTileSize={honorTileSize}\n                />\n            );\n        });\n\n    const spritesClassName = classnames(styles.sprites, {\n        [styles.positioned]: positioned\n    });\n\n    return (\n        <>\n            <input\n                type=\"checkbox\"\n                checked={positioned}\n                onChange={() => setPositioned(!positioned)}\n            />\n            positioned\n            <input\n                type=\"checkbox\"\n                checked={honorTileSize}\n                onChange={() => setHonorTileSize(!honorTileSize)}\n            />\n            honor tile size\n            <button\n                onClick={() => {\n                    setDumpCount(dumpCount + 1);\n                }}\n            >\n                dump sprites\n            </button>\n            <div className={spritesClassName}>{sprites}</div>\n        </>\n    );\n};\n","import React, { useState } from \"react\";\nimport { Sprites } from \"./sprites\";\n\ninterface EmulatorProps {\n    className?: string;\n}\n\nfunction loadFile<T>(file: File): Promise<T> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.addEventListener(\"load\", () => {\n            if (reader.result) {\n                resolve((reader.result as unknown) as T);\n            } else {\n                reject(`Failed to load: ${file.name}`);\n            }\n        });\n\n        reader.readAsArrayBuffer(file);\n    });\n}\n\nasync function addFileToVirtualFS(file: File) {\n    const data: ArrayBuffer = await loadFile(file);\n\n    window.Module.FS_createDataFile(\n        \"/virtualfs\",\n        file.name,\n        new Uint8Array(data),\n        true,\n        true\n    );\n}\n\nexport const Emulator: React.FunctionComponent<EmulatorProps> = () => {\n    const [biosLoaded, setBiosLoaded] = useState(false);\n    const [romLoaded, setRomLoaded] = useState(false);\n    const [gameName, setGameName] = useState(\"\");\n    const [isPaused, setIsPaused] = useState(false);\n\n    function togglePause() {\n        if (isPaused) {\n            window.Module.resumeMainLoop();\n        } else {\n            window.Module.pauseMainLoop();\n        }\n\n        setIsPaused(!isPaused);\n    }\n\n    async function loadBiosFile(e: React.ChangeEvent<HTMLInputElement>) {\n        const file = e.target && e.target.files && e.target.files[0];\n\n        if (!file) {\n            return;\n        }\n\n        await addFileToVirtualFS(file);\n        setBiosLoaded(true);\n    }\n\n    async function loadROMFile(e: React.ChangeEvent<HTMLInputElement>) {\n        const file = e.target && e.target.files && e.target.files[0];\n\n        if (!file) {\n            return;\n        }\n\n        await addFileToVirtualFS(file);\n        setRomLoaded(true);\n        setGameName(file.name.replace(\".zip\", \"\"));\n    }\n\n    function startGame(overrideGameName?: string) {\n        const argv = window.stackAlloc(3 * 4);\n\n        window.HEAP32[argv >> 2] = window.allocateUTF8OnStack(\"gngeo\");\n        window.HEAP32[(argv >> 2) + 1] = window.allocateUTF8OnStack(\n            overrideGameName || gameName\n        );\n        window.HEAP32[(argv >> 2) + 2] = 0;\n\n        window.Module._run_rom(2, argv);\n    }\n\n    let debugButton = null;\n\n    if (process.env.NODE_ENV !== \"production\") {\n        debugButton = (\n            <button onClick={() => startGame(\"samsho2\")}>samsho2</button>\n        );\n    }\n\n    return (\n        <>\n            <canvas id=\"canvas\" />\n            <div>\n                BIOS\n                <input type=\"file\" onChange={loadBiosFile} />\n            </div>\n            <div>\n                ROM\n                <input type=\"file\" onChange={loadROMFile} />\n            </div>\n            {debugButton}\n            <button onClick={() => startGame()}>start emulation</button>\n            <button onClick={togglePause}>\n                {isPaused ? \"resume\" : \"pause\"}\n            </button>\n            <Sprites />\n        </>\n    );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n","import React from \"react\";\nimport { Emulator } from \"./emulator\";\n\nexport const App: React.FunctionComponent = () => {\n    return <Emulator />;\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sprite\":\"sprite_sprite__3KcA3\",\"positioned\":\"sprite_positioned__3ip5P\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sprites\":\"sprites_sprites__1RtnD\",\"positioned\":\"sprites_positioned__3qOrZ\"};"],"sourceRoot":""}